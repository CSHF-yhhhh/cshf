{"pages":[],"posts":[{"title":"HTTP更改客户端IP的方式","text":"HTTP头 描述 对应PHP字段 X-Forwarded-For 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_X_FORWARDED_FOR’] X-Remote-Addr 访问端（有可能是用户，有可能是代理的）IP $_SERVER[‘REMOTE_ADDR’] X-Client-IP 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_CLIENT_IP’]","link":"/2021/02/03/HTTP%E6%9B%B4%E6%94%B9%E5%AE%A2%E6%88%B7%E7%AB%AFIP%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"PE文件","text":"前言PE 的全称是 Portable Executable，意为可移植的可执行的文件，常见的 EXE、DLL、OCX、SYS、COM 都是 PE 文件，PE 文件是微软 Windows 操作系统上的程序文件（可能是间接被执行，如 DLL）。PE 是一种数据结构，其中封装了 Windows OS 加载程序管理包装的可执行代码所需的信息。 RVA(relative virtual address)相对虚拟内存地址（Reverse Virtual Address , RVA）是相对于基地址的偏移，即 RVA 是虚拟内存中用来定位某个特定位置的地址，该地址的值是这个特定位置距离某个模块基地址的偏移量，所以说 RVA 是针对某个模块而存在的。 PE 文件的基本结构 这些部分是 PE 文件中真正用于 Win32 的部分，为了与 DOS 系统的文件格式兼容，在这部分的前面又加上了一个标准的 DOS MZ 格式的可执行部分，所有这些部分合起来组成了现在使用的 PE 文件。 1. DOS 文件头和 DOS 块（图中的 ①） PE 文件中包括一个标准的 DOS 可执行文件部分，该部分是用来向下兼容，如果在 DOS 下执行一个 PE 文件，系统可以将文件解释为 DOS 下的.exe 可执行格式，并执行 DOS 部分的代码。 PE 文件中的 DOS 部分由 MZ 格式的文件头和可执行代码部分组成，可执行代码被称为“DOS 块”（DOS stub）。 如果 e_magic 字段为 5A4DH 表示 DOS MZ header 有效。且 e_lfarlc 字段表示的是PE header的地址。 2. PE 文件头（也称 NT 文件头）（图中的 ②） PE 文件头是由 IMAGE_NT_HEADERS 结构定义的 如图 PE 文件头的第一个双字 Signature 是一个标志，它被定义为00004550h，也就是字符“P”，“E”加上两个 0。这也是“PE”这个称呼的由来，大部分的文件属性由标志后面的IMAGE_FILE_HEADER和IMAGE_OPTIONAL_HEADER32结构来定义。虽然这两个 PE 文件表头结构是可选的，但实际上这个名称是名不符实的，因为它总是存在于每个 PE 文件中。 IMAGE_FILE_HEADER 结构 标准IMAGE_FILE_HEADER紧跟在PE头标识后，即位于IMAGE_DOS_HEADER的e_lfanew值+4 的位置。由此位置开始的20个字节为数据结构标准 PE 头IMAGE_FILE_HEADER的内容。 Machine字段：来指定文件的运行平台 [点此查看预定义值] NumberOfSections字段：指出文件中存在的节的数量 TimeDateStamp字段：编译器创建此文件的时间，它的数值是从 1969 年 12 月 31 日下午 4：00 开始到创建时间为止的总秒数。 PointerToSymbolTable和NumberOfSymbols字段：这两个字段并不重要，它们与调试用的符号表有关。 SizeOfOptionalHeader字段：紧接在当前结构下面的IMAGE_OPTIONAL_HEADER32结构的长度，这个值等于00e0h。 Characteristics字段：属性标志字段，它的不同数据位定义了不同的文件属性 [点此查看预定义值] IMAGE_OPTIONAL_HEADER32 结构 AddressOfEntryPoit 字段指出文件被执行时的入口地址（这是一个 RVA 地址）。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码就可以了。 ImageBase 字段指出文件的优先装入地址。也就是说当文件被执行时，如果可能的话，Windows 优先将文件装入到由ImageBase字段指定的地址中，只有指定的地址已经被其他模块使用时，文件才被装入到其他地址中。 SectionAlignment 字段和 FileAlignment 字段SectionAlignment字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。而 FileAlignment 字段指定了节存储在磁盘文件中时的对齐单位。 Subsystem 字段指定使用界面的子系统。这个字段决定了系统如何为程序建立初始的界面。 DataDirectory 字段这个字段可以说是最重要的字段之一，它由 16 个相同的IMAGE_DATA_DIRECTORY结构组成，虽然 PE 文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这 16 个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。 如果将这 16 个 IMAGE_DATA_DIRECTORY 结构按照排列顺序编号为索引号 0 到 15，那么其用途和索引号是一一对应的，其对应关系如下表 索引 索引值在 Windows.inc 中的预定义值 对应的数据块 0 IMAGE_DIRECTORY_ENTRY_EXPORT 导出表地址和大小 1 IMAGE_DIRECTORY_ENTRY_IMPORT 导入表地址和大小 2 IMAGE_DIRECTORY_ENTRY_RESOURCE 资源表地址和大小 3 IMAGE_DIRECTORY_ENTRY_EXCEPTION 异常表地址和大小 4 IMAGE_DIRECTORY_ENTRY_SECURITY 属性证书数据地址和大小 5 IMAGE_DIRECTORY_ENTRY_BASERELOC 基地址重定位表地址和大小 6 IMAGE_DIRECTORY_ENTRY_DEBUG 调试信息地址和大小 7 IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 版权信息 8 IMAGE_DIRECTORY_ENTRY_GLOBALPTR 指向全局指针寄存器的值 9 IMAGE_DIRECTORY_ENTRY_TLS 线程局部存储地址和大小 10 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 加载配置表地址和大小 11 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定导入表地址和大小 12 IMAGE_DIRECTORY_ENTRY_IAT 导入函数地址表 13 IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 延迟导入表地址和大小 14 IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR CLR 运行时头部数据地址和大小 15 未使用 例: 在 PE 文件中寻找特定的数据时就是从这些 IMAGE_DATA_DIRECTORY 结构开始的，比如要存取资源，那么必须从第 3 个 IMAGE_DATA_DIRECTORY 结构（索引为 2）中得到资源数据块的大小和位置；同理，如果要查看 PE 文件导入了哪些 DLL 文件的哪些 API 函数，那就必须首先从第 2 个 IMAGE_DATA_DIRECTORY 结构得到导入表的位置和大小。 3. 节表 节表头紧跟在IMAGE_NT_HEADERS后面 PE 文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。 节表被存放在紧接在 PE 文件头的地方，也就是从 PE 文件头 （注意：不是文件本身的头部） 开始的偏移为00f8h的地方。 PE 文件中的数据按照装入内存后的页面属性被划分成多个节，并由节表中的数据来描述这些节。一个节中的数据仅仅是属性相同而已，并不一定就是同一种用途的，比如导入表、导出表等就有可能和只读常量一起被放在同一个节中，因为它们的属性同是可读不可写的。其次，由于不同用途的数据可能被放在同一个节中，仅仅依靠节表是无法确定它们的存放位置的，PE 文件中依靠文件头中IMAGE_OPTIONAL_HEADER32结构内的数据目录表来指出它们的位置，可以由数据目录表来定位的数据包括导入表、导出表、资源、重定位表和 TLS 等 15 种数据。 节表中IMAGE_SECTION_HEADER结构的总数由 PE 文件头IMAGE_NT_HEADERS结构中的FileHeader.NumberOfSections字段指定。 IMAGE_SECTION_HEADER 结构的定义如下： 结构中的有些字段是供 COFF 格式的 obj 文件使用的，对可执行文件来说不代表任何意义，在分析的时候可以不予理会，真正有用的几个字段说明如下。 字段名 作用 备注 Name1 表示节的名称 每个节的名称是唯一的，不能有同名的两个节(，在 MASM32 产生的可执行文件中，代码节被命名为“.text”；可读写的数据节被命名为“.data”；包含只读数据、导入表以及导出表的节被命名为“.rdata”；而资源节被命名为“.rsrc”等。但是在其他一些编译器中，导入表被单独放在“.idata”中；而代码节可能被命名为“.code”。) VirtualSize 代表节的大小 这是节的数据在没有进行对齐处理前的实际大小 PointerToRawData 指出节在磁盘文件中的所处的位置 这个数值是从文件头开始算起的偏移量 SizeOfRawData 指出节在磁盘文件中所占的空间大小 ，这个数值等于 VirtualSize 字段的值按照 FileAlignment 的值对齐以后的大小 Characteristics 这是节的属性标志字段，其中的不同数据位代表了不同的属性 通过 Name1 、VirtualSize、PointerToRawData、SizeOfRawData ，装载器就可以从 PE 文件中找出某个节（从 PointerToRawData 偏移开始的 SizeOfRawData 字节）的数据，并将它映射到内存中去（映射到从模块基地址开始偏移 VirtualAddress 的地方，并占用以 VirtualSize 的值按照页的尺寸对齐后的空间大小）。 导入表 定义在 Win32 编程中常常用到“导入函数”（Import functions），导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个 DLL 中，在调用者程序中只保留一些函数信息，包括函数名及其驻留的 DLL 名等，导入表中保存的正是函数名和其驻留的 DLL 名等动态链接所必需的信息。 导入表的位置导入表的位置和大小可以从 PE 文件头中IMAGE_OPTIONAL_HEADER32结构的数据目录字段中获取，对应的项目是 DataDirectory 字段的第 2 个IMAGE_DATA_DIRECTORY结构(也就是IMAGE_DIRECTORY_ENTRY_IMPORT) 导入表的结构 结构中的Name1字段指向此结构所对应的 DLL 文件 的名称，这个文件名是一个以NULL结尾的字符串。 OriginalFirstThunk字段和FirstThunk字段都指向一个包含一系列IMAGE_THUNK_DATA结构的数组，数组中的每个IMAGE_THUNK_DATA结构定义了一个导入函数的信息，数组的最后以一个内容为 0 的IMAGE_THUNK_DATA结构作为结束。 IMAGE_THUNK_DATA结构如下一个IMAGE_THUNK_DATA结构实际上就是一个双字，之所以把它定义成结构，是因为它在不同的时刻有不同的含义 最高位为 1 时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号。 当双字的最高位为 0 时，表示函数以字符串类型的函数名方式导入(这时双字的值是一个 RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构) OriginalFirstThunk指向的IMAGE_THUNK_DATA数组包含导入信息，在这个数组中只有Ordinal和AddressOfData是有用的，因此可以通过OriginalFirstThunk查找到函数的地址。 FirstThunk则略有不同，在 PE 文件加载以前或者说在导入表未处理以前，他所指向的数组与OriginalFirstThunk中的数组虽不是同一个，但是内容却是相同的，都包含了导入信息，而在加载之后，FirstThunk中的Function开始生效，他指向实际的函数地址，因为FirstThunk实际上指向IAT中的一个位置，IAT就充当了IMAGE_THUNK_DATA数组，加载完成后，这些 IAT 项就变成了实际的函数地址，即 Function 的意义。看图可能更方便与理解 导入地址表 IAT IMAGE_IMPORT_DESCRIPTOR结构中FirstThunk字段指向的数组最后会被替换成导入函数的真正入口地址，暂且把这个数组称为导入地址数组。在 PE 文件中，所有 DLL 对应的导入地址数组在位置上是被排列在一起的，全部这些数组的组合也被称为导入地址表（Import Address Table，或者简称为 IAT），导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk字段指向的就是 IAT 的起始地址。 还有一个方法可以更方便地找到 IAT 的地址，那就是通过数据目录表。数据目录表中的第 13 项（索引值为 12/IMAGE_DIRECTORY_ENTRY_IAT）直接用来定义 IAT 数据块的位置和大小。 扩展知识 装载 PE 文件的主要步骤 当 PE 文件被执行，PE 装载器检查 DOS MZ Header 里的 PE Header 偏移量，如果找到就跳转到 PE Heardr。 PE 装载器检查 PE Header 的有效性，如果有效就跳转到 PE Header 的尾部 下面紧跟 PE Heardr 的是节表。PE 装载器读取其中的节信息，并采用文件映射方法将这些节映射到内存，同时附上节表里指定的节属性。 PE 文件映射入内存后，PE 装载器将处理 PE 文件中类似 Import Tabel(引入表)逻辑部分。 检验 PE 文件的有效性 首先检验文件头部第一个字e_magic的值是否等于 5A4DH , 如果是，则检查第二项。 一旦证明文件的 DOS header 有效后，就用e_lfanew来定位 PE header 。比较 PE header 的 Signature 是否为 00004550h；是则可以认为该文件是一个有效的 PE 文件。 例: 查看 PE 文件 本次使用的是Detect it Easy，该软件为开源软件，有兴趣的可以去阅读源代码。 软件界面如下 选中程序后,点击 PE 按钮即可查看完整 PE 信息, 如图: 查看 PE 文件的导入表上面在IMAGE_OPTIONAL_HEADER32)中说过, IMAGE_OPTIONAL_HEADER32 中的 DataDirectory 里面的第二个 IMAGE_DATA_DIRECTORY 即为导入表。如图：在这里可以看到导入表的 16 进制信息,当然,这个软件将导入表的信息处理好放在 Import 下,让我们更好查看:在这个模块中,也将导入函数的相关信息等,还是比较方便的。 参考 《Windows 环境下 32 位汇编语言程序设计(典藏版)》 罗云彬[著] 《Windows PE 权威指南》戚利[著] 微软官方文档 PE 文件查看器Detect it Easy(点击转到下载地址)","link":"/2021/05/04/PE%E6%96%87%E4%BB%B6/"},{"title":"基于 Kivy&#x2F;Kivymd 开发的成语学习APP","text":"本项目已成功打包,使用的打包环境请参考nkiiiid的文章buildozer.spec文件请参考/MainApp/buildozer.spec项目和成功成功打包的APK已上传至github ,可自行下载 环境说明 Kivy==1.11.1kivy-deps.glew==0.3.0kivy-deps.gstreamer==0.3.1kivy-deps.sdl2==0.3.1Kivy-Garden==0.1.4kivymd==0.104.1Django==3.1openpyxl==3.0.6 本地运行 server服务端 服务端使用Diango框架,通过json来传输数据 12#如果需要部署在服务器上记得在服务器中开放使用的端口python ./server/manage.py runserver ip:port #eg: python manage.py 0.0.0.0:12345 MainApp/client/client.py 在这个文件夹中设置服务器的地址和端口 启动app 在MainApp下,通过以下命令运行 1python main.py","link":"/2021/04/23/%E5%9F%BA%E4%BA%8E-Kivy-Kivymd-%E5%BC%80%E5%8F%91%E7%9A%84%E6%88%90%E8%AF%AD%E5%AD%A6%E4%B9%A0APP/"},{"title":"网站信息泄露","text":"常见的网站源码泄露 备份常见备份文件名 web website backup back www wwwroot temp 备份文件的后缀 tar tar.gz zip rar 使用文件名与后缀的组合来测试是否有备份文件 版本控制访问 /.git/.svn VIM当我们在使用vim编辑的时候，vim会在被编辑文件同一目录下，创建一个名为filename.swp的文件，记录我们的动作，比如在编辑index.php的时候会存在一个index.php.swp的文件,可以访问改文件来查看源码 其他 /editor /tz.php","link":"/2021/02/03/%E7%BD%91%E7%AB%99%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"}],"tags":[{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"更改客户端IP","slug":"更改客户端IP","link":"/tags/%E6%9B%B4%E6%94%B9%E5%AE%A2%E6%88%B7%E7%AB%AFIP/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"PE","slug":"PE","link":"/tags/PE/"},{"name":"kivy","slug":"kivy","link":"/tags/kivy/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"app","slug":"app","link":"/tags/app/"},{"name":"信息搜集","slug":"信息搜集","link":"/tags/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"}],"categories":[{"name":"WEB","slug":"WEB","link":"/categories/WEB/"},{"name":"Other","slug":"WEB/Other","link":"/categories/WEB/Other/"},{"name":"更改客户端IP","slug":"WEB/Other/更改客户端IP","link":"/categories/WEB/Other/%E6%9B%B4%E6%94%B9%E5%AE%A2%E6%88%B7%E7%AB%AFIP/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"信息搜集","slug":"WEB/信息搜集","link":"/categories/WEB/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"},{"name":"kivy","slug":"python/kivy","link":"/categories/python/kivy/"}]}